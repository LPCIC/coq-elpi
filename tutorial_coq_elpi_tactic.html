<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.22.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Enrico Tassi" />
<title>Tutorial on Coq tactics</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.20.0+0.20.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-coq-tactics">
<h1 class="title">Tutorial on Coq tactics</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<script>
var style = document.createElement('style');
style.textContent = `
  table.docinfo {
     border-top: none;
     border-bottom: none;
     margin: auto;
  }
  #alectryon-toggle-0 {
     display: none;
  }
  label[for="alectryon-toggle-0"] {
     display: none;
  }
  .alectryon-io {
     border-left-style: dotted;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  pre.alectryon-block {
     padding-left: 1em;
  }
  label.alectryon-input.alectryon-failed {
     text-decoration: red wavy underline;
  }
  .alectryon-io label.alectryon-input::after , .alectryon-banner .alectryon-bubble::before {
    content: '';
    background: url("data:image/svg+xml,%3Csvg width='14' height='14' viewBox='0 0 3.704 3.704' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill-rule='evenodd' stroke='%23000' stroke-width='.264'%3E%3Cpath d='M.794.934h2.115M.794 1.463h1.455M.794 1.992h1.852'/%3E%3C/g%3E%3Cpath d='M.132.14v2.646h.794v.661l.926-.661h1.72V.14z' fill='none' stroke='%23000' stroke-width='.265'/%3E%3C/svg%3E") top right no-repeat;
    height: 14px;
    width: 14px;
    border-style: none;
    border-radius: 0px;
  }
  code.coq , code.elpi {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.note, div.tip {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
  .ghref {
    cursor: help;
    text-decoration: underline dotted;
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
  }

  .elpi {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
   }

  .highlight .-ElpiFunction , .highlight .n-ElpiFunction { color: #795E26 }
  .highlight .-ElpiVariable , .highlight .n-ElpiVariable { color: #0000ff }
  .highlight .k-ElpiKeyword { color: #AF00DB }
  .highlight .k-ElpiMode { color: #811f3f }
  .highlight .m-ElpiInteger { color: #098658 }
  .highlight .si { color: rgb(94, 93, 93) }

  .elpi .n-ElpiFunction { color: #795E26 }
  .elpi .n-ElpiVariable { color: #0000ff }
  .elpi .k-ElpiKeyword { color: #AF00DB }
  .elpi .k-ElpiMode { color: #811f3f }
  .elpi .m-ElpiInteger { color: #098658 }
  .elpi .s2 { color: #a31515 }
  .elpi .c { color: #008000 }
  .elpi .kt { color: #2b91af }
  .elpi .si { color: rgb(94, 93, 93) }

  .admonition-title:after { content: ":" }
  .admonition-title { display: inline; margin-right: 0.5em }
  .admonition-title + p { display: inline }

  .important .admonition-title { color: rgb(197, 70, 91) }
  .important { background-color: rgb(272, 237, 243) }

  .note .admonition-title { color: rgb(42, 134, 57) }
  .note { background-color: rgb(222, 247, 222); }

   h1 {
      font-size: 28px;
      font-weight: 500;
      letter-spacing: 0;
      line-height: 1.5em;
      padding-bottom: 15px;
      position: relative;
      font-family: "Gill Sans Extrabold", sans-serif;
   }
   h1:before {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      height: 5px;
      width: 55px;
      background-color: #111;
   }
   h1:after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 2px;
      height: 1px;
      width: 95%;
      background-color: #333;
   }

   h2 {
      font-size: 24px;
      font-weight: 500;
      letter-spacing: 0;
      line-height: 1.5em;
      padding-bottom: 15px;
      position: relative;
      font-family: "Gill Sans Extrabold", sans-serif;
   }
   h2:before {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      height: 3px;
      width: 55px;
      background-color: #111;
   }
   h2:after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 2px;
      height: 1px;
      width: 95%;
      background-color: #333;
   }

   h3 {
      font-size: 20px;
      font-weight: 500;
      letter-spacing: 0;
      line-height: 1.5em;
      padding-bottom: 15px;
      position: relative;
      font-family: "Gill Sans Extrabold", sans-serif;
   }
   h3:after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 2px;
      height: 1px;
      width: 95%;
      background-color: #333;
   }
`;
document.getElementsByTagName('head')[0].appendChild(style);

</script><!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with programming constructs that are
designed to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq specific data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This tutorial focuses on the implementation of Coq tactics.</p>
<p>This tutorial assumes the reader is familiar with Elpi and the HOAS
representation of Coq terms; if it is not the case, please take a look at
these other tutorials first:
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_elpi_lang.html">Elpi tutorial</a>
and <a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_HOAS.html">Coq HOAS tutorial</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title"><a class="reference internal" href="#top">Contents</a></p>
<ul class="simple">
<li><a class="reference internal" href="#defining-tactics" id="toc-entry-1">Defining tactics</a><ul>
<li><a class="reference internal" href="#integration-with-ltac" id="toc-entry-2">Integration with Ltac</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arguments-and-tactic-notation" id="toc-entry-3">Arguments and Tactic Notation</a><ul>
<li><a class="reference internal" href="#ltac-arguments-to-elpi-arguments" id="toc-entry-4">Ltac arguments to Elpi arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#failure" id="toc-entry-5">Failure</a></li>
<li><a class="reference internal" href="#examples" id="toc-entry-6">Examples</a><ul>
<li><a class="reference internal" href="#let-s-code-assumption-in-elpi" id="toc-entry-7">Let's code <code class="highlight coq"><span class="bp">assumption</span></code> in Elpi</a></li>
<li><a class="reference internal" href="#let-s-code-set-in-elpi" id="toc-entry-8">Let's code <code class="highlight coq"><span class="nb">set</span></code> in Elpi</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-proof-engine-1" id="toc-entry-9">The proof engine</a><ul>
<li><a class="reference internal" href="#multi-goal-tactics" id="toc-entry-10">multi-goal tactics</a></li>
<li><a class="reference internal" href="#lcf-tacticals" id="toc-entry-11">LCF tacticals</a></li>
<li><a class="reference internal" href="#setting-arguments-for-a-tactic" id="toc-entry-12">Setting arguments for a tactic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tactics-in-terms" id="toc-entry-13">Tactics in terms</a></li>
</ul>
</div>
<div class="section" id="defining-tactics">
<h1><a class="toc-backref" href="#toc-entry-1">Defining tactics</a></h1>
<p>In Coq a proof is just a term, and an incomplete proof is just a term
with holes standing for the open goals.</p>
<p>When a proof starts there is just one hole (one goal) and its type
is the statement one wants to prove. Then proof construction makes
progress by instantiation: a term possibly containing holes is
grafted to the hole corresponding to the current goal. What a tactic
does behind the scenes is to synthesize this partial term.</p>
<p>Let's define a simple tactic that prints the current goal.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk0"><span class="kn">From</span> <span class="nb">elpi</span> <span class="kn">Require Import</span> <span class="nb">elpi</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Serlib plugin: rocq-<span class="nb">elpi</span>.<span class="nb">elpi</span> <span class="kr">is</span> not available: serlib support <span class="kr">is</span> missing.
Incremental checking <span class="kr">for</span> commands <span class="kr">in</span> this plugin will be impacted.</blockquote><blockquote class="alectryon-message">[Loading ML file rocq-<span class="nb">elpi</span>.<span class="nb">elpi</span> ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> show.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_Trigger</span><span class="w"> </span><span class=" -ElpiVariable">Type</span><span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;Goal:&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class="s2">&quot;|-&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class="s2">&quot;:&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Type</span>.

<span class="si">}}</span>.</span></span></pre><p>The tactic declaration is made of 3 parts.</p>
<p>The first one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Tactic</span> <span class="n">show</span><span class="o">.</span></code> sets the current program to <code class="highlight coq"><span class="n">show</span></code>.
Since it is declared as a <code class="highlight coq"><span class="n">Tactic</span></code> some code is loaded automatically:</p>
<ul class="simple">
<li>APIs (eg <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L554">coq.say</a>) and data types (eg Coq <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L199">term</a> s) are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/builtin-doc/coq-builtin.elpi">coq-builtin.elpi</a></li>
<li>some utilities, like <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/coq-lib.elpi#L98">copy</a> or <a class="reference external libred ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-reduction.elpi#L15">whd1</a> are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-tactic-template.elpi">elpi-command-template.elpi</a></li>
</ul>
<p>The second one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> loads some extra code.
The <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> family of commands lets one accumulate code
taken from:</p>
<ul class="simple">
<li>verbatim text <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="si">lp:{{</span><span class="w"> </span>code<span class="w"> </span><span class="si">}}</span></code></li>
<li>source files <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">File</span> <span class="n">path</span></code></li>
<li>data bases (Db) <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">Db</span> <span class="n">name</span></code></li>
</ul>
<p>Accumulating code via inline text or file is equivalent, the AST of <code class="highlight coq"><span class="n">code</span></code>
is stored in the .vo file (the external file does not need to be installed).
We invite the reader to look up the description of data bases in the tutorial
about commands.</p>
<p>When some code is accumulated Elpi verifies that the
code does not contain the most frequent kind of mistakes, via some
type checking and linting. Some mistakes are minor and Elpi only warns about
them. You can pass <code class="highlight coq"><span class="o">-</span><span class="n">w</span> <span class="o">+</span><span class="n">elpi</span><span class="o">.</span><span class="n">typecheck</span></code> to <code class="highlight coq"><span class="n">coqc</span></code> to turn these warnings into
errors.</p>
<p>The entry point for tactics is called <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L186">solve</a> which maps a <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L380">goal</a>
into a list of <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L381">sealed-goal</a> (representing subgoals).</p>
<p>Tactics written in Elpi can be invoked by prefixing its name with <code class="highlight coq"><span class="n">elpi</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1"><span class="kn">Lemma</span> <span class="nf">tutorial</span> <span class="nv">x</span> <span class="nv">y</span>  : x + <span class="mi">1</span> = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + <span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2"><span class="nb">elpi</span> show.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Goal</span>: 
[decl c1 `y` (<span class="kn">global</span> (indt ¬´nat¬ª)), decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))] 
|- X0 c0 c1 : 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app
   [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
    app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], c1]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>In the Elpi code up there <code class="e elpi"><span class="n-ElpiVariable">Proof</span></code> is the hole for the current goal,
<code class="e elpi"><span class="n-ElpiVariable">Type</span></code> the statement to be proved and <code class="e elpi"><span class="n-ElpiVariable">Ctx</span></code> the proof context (the list of
hypotheses). Since we don't assign <code class="e elpi"><span class="n-ElpiVariable">Proof</span></code> the tactic makes no progress.
Elpi prints somethinglike this:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Goal: 
[decl c1 `y` (global (indt ¬´nat¬ª)), decl c0 `x` (global (indt ¬´nat¬ª))] 
|- X0 c0 c1 : 
app
 [global (indt ¬´eq¬ª), global (indt ¬´nat¬ª), 
  app
   [global (const ¬´Nat.add¬ª), c0, 
    app [global (indc ¬´S¬ª), global (indc ¬´O¬ª)]], c1]</pre><p>The first line is the proof context:
proof variables are bound Elpi variables (here <code class="e elpi">c0</code> and <code class="e elpi">c1</code>), the context
is a list of predicates holding on them (their type in Coq). For example:</p>
<pre class="code literal-block">
decl&nbsp;c0&nbsp;`x`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª))
</pre>
<p>asserts that <code class="e elpi">c0</code> (pretty printed as <code class="highlight coq"><span class="n">x</span></code>) has type <code class="highlight coq"><span class="n">nat</span></code>.</p>
<p>Then we see that the value of <code class="e elpi"><span class="n-ElpiVariable">Proof</span></code> is <code class="e elpi"><span class="n-ElpiVariable">X0</span><span class="w"> </span>c0<span class="w"> </span>c1</code>. This means that the
proof of the current goal is represented by Elpi's variable <code class="e elpi"><span class="n-ElpiVariable">X0</span></code> and that
the variable has <code class="e elpi">c0</code> and <code class="e elpi">c1</code> in scope (the proof term can use them).</p>
<p>Finally we see the type of the goal <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">y</span></code>.</p>
<p>The <code class="e elpi"><span class="n-ElpiVariable">_Trigger</span></code> component, which we did not print, is a variable that, when
assigned, triggers the elaboration of its value against the type of the goal
and obtains a value for <code class="e elpi"><span class="n-ElpiVariable">Proof</span></code> this way.</p>
<p>Keeping in mind that the <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L186">solve</a> predicate relates one goal to a list of
subgoals, we implement our first tactic which blindly tries to solve the goal.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="si">{{</span><span class="mi">0</span><span class="si">}}</span>.
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="si">{{</span>I<span class="si">}}</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3"><span class="kn">Lemma</span> <span class="nf">test_blind</span> : <span class="kt">True</span> * nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk7"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(I, <span class="mi">0</span>)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Since the assignment of a term to <code class="e elpi"><span class="n-ElpiVariable">Trigger</span></code> triggers its elaboration against
the expected type (the goal statement), assigning the wrong proof term
results in a failure which in turn results in the other rule being tried.</p>
<p>For now, this is all about the low level mechanics of tactics which is
developed further in the section <a class="reference internal" href="#the-proof-engine">The-proof-engine</a>.</p>
<p>We now focus on how to better integrate tactics written in Elpi with Ltac.</p>
<div class="section" id="integration-with-ltac">
<h2><a class="toc-backref" href="#toc-entry-2">Integration with Ltac</a></h2>
<p>For a simple tactic like <code class="highlight coq"><span class="n">blind</span></code> the list of subgoals is easy to write, since
it is empty, but in general one should collect all the holes in
the value of <code class="e elpi"><span class="n-ElpiVariable">Proof</span></code> (the checked proof term) and build goals out of them.</p>
<p>There is a family of APIs named after <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a>, the mother of all
tactics, in 
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-ltac.elpi">elpi-ltac.elpi</a>
which does this job for you.</p>
<p>Usually a tactic builds a (possibly partial) term and calls
<a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a> on it.</p>
<p>Let's rewrite the <code class="highlight coq"><span class="n">blind</span></code> tactic using this schema.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> blind2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>refine<span class="w"> </span><span class="si">{{</span><span class="mi">0</span><span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>refine<span class="w"> </span><span class="si">{{</span>I<span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk8"><span class="kn">Lemma</span> <span class="nf">test_blind2</span> : <span class="kt">True</span> * nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk9"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>This schema works even if the term is partial, that is if it contains holes
corresponding to missing sub proofs.</p>
<p>Let's write a tactic which opens a few subgoals, for example
let's implement the <code class="highlight coq"><span class="nb">split</span></code> tactic.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Elpi's equality (that is, unification) on Coq terms corresponds to
alpha equivalence, we can use that to make our tactic less blind.</p>
</div>
<p>The head of a rule for the solve predicate is <em>matched</em> against the
goal. This operation cannot assign unification variables in the goal, only
variables in the rule's head.
As a consequence the following rule for <code class="highlight coq"><span class="kp">solve</span></code> is only used when
the statement features an explicit conjunction.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkc"><span class="kn">About</span> conj. <span class="c">(* remark the implicit arguments *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">conj : <span class="kr">forall</span> [A B : <span class="kt">Prop</span>], A -&gt; B -&gt; A /\ B

conj <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> conj [A B]%type_scope _ _
Expands to: Constructor Coq.Init.Logic.conj</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="si">{{</span> _ /\ _ <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!,</span>
<span class="w">    </span><span class="c">% conj has 4 arguments, but two are implicits</span>
<span class="w">    </span><span class="c">% (_ are added for them and are inferred from the goal)</span>
<span class="w">    </span>refine<span class="w"> </span><span class="si">{{</span> conj _ _ <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% This signals a failure in the Ltac model. A failure</span>
<span class="w">    </span><span class="c">% in Elpi, that is no more clauses to try, is a fatal</span>
<span class="w">    </span><span class="c">% error that cannot be caught by Ltac combinators like repeat.</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;not a conjunction&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkd"><span class="kn">Lemma</span> <span class="nf">test_split</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chke"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkf"><span class="kp">repeat</span> <span class="nb">elpi</span> <span class="nb">split</span>. <span class="c">(* The failure is caught by Ltac&#39;s repeat *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Remark that the last goal is left untouched, since</span>
<span class="c">   it did not match the pattern {{ _ /\ _ }}. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk10"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(ex_intro (<span class="kr">fun</span> <span class="nv">t</span> : <span class="kt">Prop</span> =&gt; <span class="kt">True</span> /\ <span class="kt">True</span> /\ t) <span class="kt">True</span>
   (conj I (conj I I)))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The tactic <code class="highlight coq"><span class="nb">split</span></code> succeeds twice, stopping on the two identical goals <code class="highlight coq"><span class="kt">True</span></code> and
the one which is an evar of type <code class="highlight coq"><span class="kt">Prop</span></code>.</p>
<p>We then invoke <code class="highlight coq"><span class="n">blind</span></code> on all goals. In the third case the type checking
constraint triggered by assigning <code class="highlight coq"><span class="o">{{</span><span class="mi">0</span><span class="o">}}</span></code> to <code class="highlight coq"><span class="n">Trigger</span></code> fails because
its type <code class="highlight coq"><span class="n">nat</span></code> is not of sort <code class="highlight coq"><span class="kt">Prop</span></code>, so it backtracks and picks <code class="highlight coq"><span class="o">{{</span><span class="n">I</span><span class="o">}}</span></code>.</p>
<p>Another common way to build an Elpi tactic is to synthesize a term and
then call some Ltac piece of code finishing the work.</p>
<p>The API <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L43">coq.ltac.call</a> invokes some Ltac piece
of code passing to it the desired
arguments. Then it builds the list of subgoals.</p>
<p>Here we pass an integer, which in turn is passed to <code class="highlight coq"><span class="kp">fail</span></code>, and a term,
which in turn is passed to <code class="highlight coq"><span class="nb">apply</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">helper_split2</span> n t := <span class="kp">fail</span> n || <span class="nb">apply</span> t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> split2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="si">{{</span> _ /\ _ <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.call<span class="w"> </span><span class="s2">&quot;helper_split2&quot;</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>int<span class="w"> </span><span class="mi">0</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>trm<span class="w"> </span><span class="si">{{</span> conj <span class="si">}}</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;not a conjunction&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk11"><span class="kn">Lemma</span> <span class="nf">test_split2</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk12"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk13"><span class="kp">repeat</span> <span class="nb">elpi</span> split2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
</div>
<div class="section" id="arguments-and-tactic-notation">
<h1><a class="toc-backref" href="#toc-entry-3">Arguments and Tactic Notation</a></h1>
<p>Elpi tactics can receive arguments. Arguments are received as a list, which
is the last argument of the goal constructor. This suggests that arguments
are attached to the current goal being observed, but we will dive into
this detail later on.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> print_args.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Args</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">Args</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">test_print_args</span> : <span class="kt">True</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk14"><span class="nb">elpi</span> print_args <span class="mi">1</span> x <span class="s2">&quot;a b&quot;</span> (<span class="mi">1</span> = <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[int <span class="mi">1</span>, str x, str a b, 
 trm
  (app
    [<span class="kn">global</span> (indt ¬´eq¬ª), X0, 
     app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], <span class="kn">global</span> (indc ¬´O¬ª)])]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>The convention is that numbers like <code class="highlight coq"><span class="mi">1</span></code> are passed as <code class="e elpi">int<span class="w"> </span><span class="mi">1</span></code>,
identifiers or strings are passed as <code class="e elpi">str<span class="w"> </span><span class="s2">&quot;arg&quot;</span></code> and terms
have to be put between parentheses.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>terms are received in raw format, eg before elaboration</p>
<p class="last">Indeed the type argument to <code class="highlight coq"><span class="n">eq</span></code> is a variable.
One can use APIs like <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L1476">coq.elaborate-skeleton</a> to infer holes like
<code class="e elpi"><span class="n-ElpiVariable">X0</span></code>.</p>
</div>
<p>See the <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L66">argument</a> data type
for a detailed description of all the arguments a tactic can receive.</p>
<p>Now let's write a tactic which behaves pretty much like the <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a>
one from Coq, but prints what it does using the API <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L1740">coq.term-&gt;string</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="nb">refine</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% check S elaborates to T of type Ty (the goal)</span>
<span class="w">    </span>coq.elaborate-skeleton<span class="w"> </span><span class=" -ElpiVariable">S</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span>ok<span class="k k-ElpiKeyword">,</span>

<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;Using&quot;</span><span class="w"> </span>{coq.term-&gt;string<span class="w"> </span><span class=" -ElpiVariable">T</span>}
<span class="w">            </span><span class="s2">&quot;of type&quot;</span><span class="w"> </span>{coq.term-&gt;string<span class="w"> </span><span class=" -ElpiVariable">Ty</span>},

<span class="w">    </span><span class="c">% since T is already checked, we don&#39;t check it again</span>
<span class="w">    </span>refine.no_check<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">]</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class=" -ElpiVariable">Msg</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span>{coq.term-&gt;string<span class="w"> </span><span class=" -ElpiVariable">S</span>} <span class="k k-ElpiKeyword">^</span><span class="w"> </span><span class="s2">&quot; does not fit&quot;</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Msg</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk15"><span class="kn">Lemma</span> <span class="nf">test_refine</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) : Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-tactic-v-chk16"><span class="nb">elpi</span> <span class="nb">refine</span> (H).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Tactic</span> failure: H does not fit.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk17"><span class="nb">elpi</span> <span class="nb">refine</span> (H _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Using H <span class="nl">?p</span> of type Q</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><div class="section" id="ltac-arguments-to-elpi-arguments">
<h2><a class="toc-backref" href="#toc-entry-4">Ltac arguments to Elpi arguments</a></h2>
<p>It is customary to use the Tactic Notation command to attach a nicer syntax
to Elpi tactics.</p>
<p>In particular <code class="highlight coq"><span class="n">elpi</span> <span class="n">tacname</span></code> accepts as arguments the following <a class="reference external" href="https://coq.inria.fr/doc/master/refman/proof-engine/ltac.html#syntactic-values">bridges
for Ltac values</a> :</p>
<ul class="simple">
<li><code class="highlight coq"><span class="n">ltac_string</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="n">string</span></code> or <code class="highlight coq"><span class="kn">ident</span></code>)</li>
<li><code class="highlight coq"><span class="n">ltac_int</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="n">int</span></code> or <code class="highlight coq"><span class="n">integer</span></code>)</li>
<li><code class="highlight coq"><span class="n">ltac_term</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="kp">constr</span></code> or <code class="highlight coq"><span class="n">open_constr</span></code> or <code class="highlight coq"><span class="kp">uconstr</span></code> or <code class="highlight coq"><span class="n">hyp</span></code>)</li>
<li><code class="highlight coq"><span class="n">ltac_</span><span class="o">(</span><span class="n">string</span><span class="o">|</span><span class="n">int</span><span class="o">|</span><span class="n">term</span><span class="o">)</span><span class="n">_list</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="n">list</span></code> of ...)</li>
</ul>
<p>Note that the Ltac type associates some semantics to the action of passing
the arguments. For example <code class="highlight coq"><span class="n">hyp</span></code> will accept an identifier only if it is
an hypotheses of the context. While <code class="highlight coq"><span class="kp">uconstr</span></code> does not type check the term,
which is the recommended way to pass terms to an Elpi tactic (since it is
likely to be typed anyway by the Elpi tactic).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;use&quot;</span> <span class="kp">uconstr</span>(t) :=
  <span class="nb">elpi</span> <span class="nb">refine</span> ltac_term:(t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;use&quot;</span> hyp(t) :=
  <span class="nb">elpi</span> <span class="nb">refine</span> ltac_term:(t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk18"><span class="kn">Lemma</span> <span class="nf">test_use</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) (<span class="nv">p</span> : P) : Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk19">use (H _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Using H <span class="nl">?p</span> of type Q</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-tactic-v-chk1a">use q.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">No such hypothesis: q</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1b">use p.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Using p of type P</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;print&quot;</span> uconstr_list_sep(l, <span class="s2">&quot;,&quot;</span>) :=
  <span class="nb">elpi</span> print_args ltac_term_list:(l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1c"><span class="kn">Lemma</span> <span class="nf">test_print</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) (<span class="nv">p</span> : P) : Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1d">print P, p, (H p).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[trm c0, trm c3, trm (app [c2, c3])]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
</div>
<div class="section" id="failure">
<h1><a class="toc-backref" href="#toc-entry-5">Failure</a></h1>
<p>The <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L569">coq.error</a> aborts the execution of both
Elpi and any enclosing Ltac context. This failure cannot be caught
by Ltac.</p>
<p>On the contrary the <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L1613">coq.ltac.fail</a> builtin can be used to
abort the execution of Elpi code in such a way that Ltac can catch it.
This API takes an integer akin to Ltac's fail depth together with
the error message to be displayed to the user.</p>
<p>Library functions of the <code class="highlight coq"><span class="nb">assert</span><span class="o">!</span></code> family call, by default, <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L569">coq.error</a>.
The flag <code class="highlight coq"><span class="o">&#64;</span><span class="n">ltacfail</span><span class="o">!</span> <span class="n">N</span></code> can be set to alter this behavior and turn errors into
calls to <code class="highlight coq"><span class="n">coq</span><span class="o">.</span><span class="kp">ltac</span><span class="o">.</span><span class="kp">fail</span> <span class="n">N</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> abort.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.error<span class="w"> </span><span class="s2">&quot;uncatchable&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1e"><span class="kn">Goal</span> <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1f"><span class="kn">Fail</span> <span class="nb">elpi</span> abort || <span class="kp">idtac</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
uncatchable</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="kp">fail</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>int<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">]</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="s2">&quot;catchable&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk20"><span class="kn">Goal</span> <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk21"><span class="nb">elpi</span> <span class="kp">fail</span> <span class="mi">0</span> || <span class="kp">idtac</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk22"><span class="kn">Fail</span> <span class="nb">elpi</span> <span class="kp">fail</span> <span class="mi">1</span> || <span class="kp">idtac</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
<span class="kn">Tactic</span> failure: catchable.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#toc-entry-6">Examples</a></h1>
<div class="section" id="let-s-code-assumption-in-elpi">
<h2><a class="toc-backref" href="#toc-entry-7">Let's code <code class="highlight coq"><span class="bp">assumption</span></code> in Elpi</a></h2>
<p><code class="highlight coq"><span class="bp">assumption</span></code> is a very simple tactic: we look up in the proof
context for an hypothesis which unifies with the goal.
Recall that <code class="highlight coq"><span class="n">Ctx</span></code> is made of <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L276">decl</a> and <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L277">def</a>
(here, for simplicity, we ignore the latter case).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% H is the name for hyp, Ty is the goal</span>
<span class="w">    </span>std.mem<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class="p">(</span>decl<span class="w"> </span><span class=" -ElpiVariable">H</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>refine<span class="w"> </span><span class=" -ElpiVariable">H</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;no such hypothesis&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk23"><span class="kn">Lemma</span> <span class="nf">test_assumption</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk24"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk25"><hr></label><div class="goal-conclusion">id Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk26"><span class="nb">elpi</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-tactic-v-chk27"><span class="nb">elpi</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Tactic</span> failure: no such hypothesis.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>As we hinted before, Elpi's equality is alpha equivalence. In the second
goal the assumption has type <code class="highlight coq"><span class="n">Q</span></code> but the goal has type <code class="highlight coq"><span class="n">id</span> <span class="n">Q</span></code> which is
convertible (unifiable, for Coq's unification) to <code class="highlight coq"><span class="n">Q</span></code>.</p>
<p>Let's improve our tactic by looking for an assumption which is unifiable with
the goal, and not just alpha convertible. The <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L1472">coq.unify-leq</a>
calls Coq's unification for types (on which cumulativity applies, hence the
<code class="highlight coq"><span class="o">-</span><span class="n">leq</span></code> suffix). The <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/elpi-builtin.elpi#L643">std.mem</a> utility, thanks to backtracking,
eventually finds an hypothesis that satisfies the following predicate
(ie unifies with the goal).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> assumption2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% std.mem is backtracking (std.mem! would stop at the first hit)</span>
<span class="w">    </span>std.mem<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class="p">(</span>decl<span class="w"> </span><span class=" -ElpiVariable">H</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty&#39;</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>coq.unify-leq<span class="w"> </span><span class=" -ElpiVariable">Ty&#39;</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="w"> </span>ok<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>refine<span class="w"> </span><span class=" -ElpiVariable">H</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;no such hypothesis&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk28"><span class="kn">Lemma</span> <span class="nf">test_assumption2</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk29"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk2a"><hr></label><div class="goal-conclusion">id Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> assumption2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p><a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a> does unify the type of goal with the type of the term,
hence we can simplify the code further. We obtain a
tactic very similar to our initial <code class="highlight coq"><span class="n">blind</span></code> tactic, which picks
candidates from the context rather than from the program itself.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> assumption3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>std.mem<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class="p">(</span>decl<span class="w"> </span><span class=" -ElpiVariable">H</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>refine<span class="w"> </span><span class=" -ElpiVariable">H</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;no such hypothesis&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2b"><span class="kn">Lemma</span> <span class="nf">test_assumption3</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2c"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk2d"><hr></label><div class="goal-conclusion">id Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> assumption3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="let-s-code-set-in-elpi">
<h2><a class="toc-backref" href="#toc-entry-8">Let's code <code class="highlight coq"><span class="nb">set</span></code> in Elpi</a></h2>
<p>The <code class="highlight coq"><span class="nb">set</span></code> tactic takes a term, possibly with holes, and
makes a let-in out of it.</p>
<p>It gives us the occasion to explain the <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/coq-lib.elpi#L98">copy</a> utility.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> find.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">  </span><span class="k k-ElpiKeyword">pi</span><span class="w"> </span><span class=" -ElpiVariable">x</span>\
<span class="w">    </span><span class="p">((</span>copy<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="w"> </span>x<span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">==&gt;</span><span class="w"> </span>copy<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">Tabs</span><span class="w"> </span>x<span class="p">))</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>if<span class="w"> </span><span class="p">(</span>occurs<span class="w"> </span>x<span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">Tabs</span><span class="w"> </span>x<span class="p">))</span>
<span class="w">       </span><span class="p">(</span>coq.say<span class="w"> </span><span class="s2">&quot;found&quot;</span><span class="w"> </span>{coq.term-&gt;string<span class="w"> </span><span class=" -ElpiVariable">X</span>})
<span class="w">       </span><span class="p">(</span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;not found&quot;</span><span class="p">)</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2e"><span class="kn">Lemma</span> <span class="nf">test_find</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P /\ P) \/ (P /\ Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P \/ P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2f"><span class="nb">elpi</span> find (P).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">found P</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P \/ P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-tactic-v-chk30"><span class="nb">elpi</span> find (Q /\ _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Tactic</span> failure: not found.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk31"><span class="nb">elpi</span> find (P /\ _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">found P /\ P</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P \/ P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>This first approximation only prints the term it found, or better the first
instance of the given term.</p>
<p>Now lets focus on <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/coq-lib.elpi#L98">copy</a>. An excerpt:</p>
<pre class="code elpi literal-block">
copy<span class="w"> </span><span class="n-ElpiVariable">X</span><span class="w"> </span><span class="n-ElpiVariable">X</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w"> </span>name<span class="w"> </span><span class="n-ElpiVariable">X</span><span class="o">.</span><span class="w">     </span><span class="c">% checks X is a bound variable
</span>copy<span class="w"> </span><span class="p">(</span>global<span class="w"> </span><span class="n-ElpiVariable">_</span><span class="w"> </span><span class="k-ElpiKeyword">as</span><span class="w"> </span><span class="n-ElpiVariable">C</span><span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">C</span><span class="o">.</span><span class="w">
</span>copy<span class="w"> </span><span class="p">(</span>fun<span class="w"> </span><span class="n-ElpiVariable">N</span><span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">F</span><span class="p">)</span><span class="w"> </span><span class="p">(</span>fun<span class="w"> </span><span class="n-ElpiVariable">N</span><span class="w"> </span><span class="n-ElpiVariable">T1</span><span class="w"> </span><span class="n-ElpiVariable">F1</span><span class="p">)</span><span class="o">.</span><span class="w">
  </span>copy<span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">T1</span><span class="k-ElpiKeyword">,</span><span class="w"> </span><span class="k-ElpiKeyword">pi</span><span class="w"> </span><span class="n-ElpiVariable">x</span>\<span class="w"> </span>copy<span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">F</span><span class="w"> </span>x<span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">F1</span><span class="w"> </span>x<span class="p">)</span><span class="o">.</span><span class="w">
</span>copy<span class="w"> </span><span class="p">(</span>app<span class="w"> </span><span class="n-ElpiVariable">L</span><span class="p">)</span><span class="w"> </span><span class="p">(</span>app<span class="w"> </span><span class="n-ElpiVariable">L1</span><span class="p">)</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w"> </span><span class="k-ElpiKeyword">!,</span><span class="w"> </span>std.map<span class="w"> </span><span class="n-ElpiVariable">L</span><span class="w"> </span>copy<span class="w"> </span><span class="n-ElpiVariable">L1</span><span class="o">.</span>
</pre>
<p>Copy implements the identity: it builds, recursively, a copy of the first
term into the second argument. Unless one loads in the context a new rule,
which takes precedence over the identity ones. Here we load:</p>
<pre class="code elpi literal-block">
copy<span class="w"> </span><span class="n-ElpiVariable">X</span><span class="w"> </span>x
</pre>
<p>which, at run time, looks like</p>
<pre class="code elpi literal-block">
copy<span class="w"> </span><span class="p">(</span>app<span class="w"> </span><span class="k-ElpiKeyword">[</span>global<span class="w"> </span><span class="p">(</span>indt<span class="w"> </span><span class="err">¬´</span>andn<span class="err">¬ª</span><span class="p">)</span><span class="k-ElpiKeyword">,</span><span class="w"> </span>sort<span class="w"> </span>prop<span class="k-ElpiKeyword">,</span><span class="w"> </span>sort<span class="w"> </span>prop<span class="k-ElpiKeyword">,</span><span class="w"> </span>c0<span class="k-ElpiKeyword">,</span><span class="w"> </span><span class="n-ElpiVariable">X0</span><span class="w"> </span>c0<span class="w"> </span>c1<span class="k-ElpiKeyword">]</span><span class="p">)</span><span class="w"> </span>c2
</pre>
<p>and that rule masks the one for <a class="reference external constructor ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L213">app</a> when the 
sub-term being copied matches <code class="highlight coq"><span class="o">(</span><span class="n">P</span> <span class="o">/\</span> <span class="n">_</span><span class="o">)</span></code>. The first time this rule
is used <code class="e elpi"><span class="n-ElpiVariable">X0</span></code> is assigned, making the rule represent the term <code class="highlight coq"><span class="o">(</span><span class="n">P</span> <span class="o">/\</span> <span class="n">P</span><span class="o">)</span></code>.</p>
<p>Now let's refine the tactic to build a let-in, and complain if the
desired name is already taken.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="nb">set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">ID</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>trm<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">  </span><span class="k k-ElpiKeyword">pi</span><span class="w"> </span><span class=" -ElpiVariable">x</span>\
<span class="w">    </span><span class="p">((</span>copy<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="w"> </span>x<span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">==&gt;</span><span class="w"> </span>copy<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">Tabs</span><span class="w"> </span>x<span class="p">))</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>if<span class="w"> </span><span class="p">(</span>occurs<span class="w"> </span>x<span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">Tabs</span><span class="w"> </span>x<span class="p">))</span>
<span class="w">       </span><span class="p">(</span>if<span class="w"> </span><span class="p">(</span>coq.ltac.id-free?<span class="w"> </span><span class=" -ElpiVariable">ID</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span>true
<span class="w">           </span><span class="p">(</span>coq.warn<span class="w"> </span><span class=" -ElpiVariable">ID</span><span class="w"> </span><span class="s2">&quot;is already taken, Elpi will make a name up&quot;</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span>
<span class="w">        </span>coq.id-&gt;name<span class="w"> </span><span class=" -ElpiVariable">ID</span><span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">,</span>
<span class="w">        </span><span class=" -ElpiVariable">Hole</span><span class="w"> </span>x<span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="si">{{</span> _ : <span class="si">lp:{{</span><span class="w"> </span><span class=" -ElpiVariable">Tabs</span><span class="w"> </span>x<span class="w"> </span><span class="si">}}</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class="c">% a hole with a type</span>
<span class="w">        </span>refine<span class="w"> </span><span class="p">(</span><span class="k k-ElpiKeyword">let</span><span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">X</span><span class="w"> </span><span class=" -ElpiVariable">x\</span><span class="w"> </span><span class=" -ElpiVariable">Hole</span><span class="w"> </span>x<span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;not found&quot;</span><span class="p">)</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk32"><span class="kn">Lemma</span> <span class="nf">test_set</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P /\ P) \/ (P /\ Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P \/ P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk33"><span class="nb">elpi</span> <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x /\ x \/ x /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk34"><span class="nb">unfold</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P \/ P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-tactic-v-chk35"><span class="nb">elpi</span> <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (Q /\ _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Tactic</span> failure: not found.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk36"><span class="nb">elpi</span> <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (P /\ _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">x <span class="kr">is</span> already taken, <span class="kn">Elpi</span> will make a name up
[lib,<span class="nb">elpi</span>,default]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br><span><var>elpi_ctx_entry_4_</var><span><span class="hyp-body"><b>:= </b><span>P /\ P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">elpi_ctx_entry_4_ \/ P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>For more examples of (basic) tactics written in Elpi see the
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/tree/master/apps/eltac">eltac app</a>.</p>
</div>
</div>
<div class="section" id="the-proof-engine-1">
<span id="the-proof-engine"></span><h1><a class="toc-backref" href="#toc-entry-9">The proof engine</a></h1>
<p>In this section we dive into the details of the proof engine, that is
how goals are represented in Elpi and how things are wired up behind the scenes.</p>
<p>Let's inspect the proof state a bit deeper:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> show_more.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_Trigger</span><span class="w"> </span><span class=" -ElpiVariable">Type</span><span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;Goal:&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class="s2">&quot;|-&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class="s2">&quot;:&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Type</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;Proof state:&quot;</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.sigma.print.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk37"><span class="kn">Lemma</span> <span class="nf">test_show_more</span> <span class="nv">x</span> : x + <span class="mi">1</span> = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + <span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk38"><span class="nb">elpi</span> show_more.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Goal</span>: [decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))] |- X0 c0 : 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app
   [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
    app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], <span class="kn">global</span> (indc ¬´O¬ª)]</blockquote><blockquote class="alectryon-message"><span class="kn">Proof</span> state:</blockquote><blockquote class="alectryon-message">{c0} : decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))
  ?- <span class="nb">evar</span> (X1 c0) 
      (app
        [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
         app
          [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
           app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], 
         <span class="kn">global</span> (indc ¬´O¬ª)]) (X0 c0)  /* suspended on X1, X0 */</blockquote><blockquote class="alectryon-message">EVARS:
 <span class="nl">?X57</span>==[x |- x + <span class="mi">1</span> = <span class="mi">0</span>] (goal <span class="nb">evar</span>) {<span class="nl">?Goal</span>}
 <span class="nl">?X56</span>==[ |- =&gt; <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="nl">?Goal</span>] (goal <span class="nb">evar</span>)
 <span class="nl">?X55</span>==[x |- =&gt; nat] (parameter A of eq)
 <span class="nl">?X54</span>==[ |- =&gt; nat] (<span class="kp">type of</span> x)

SHELF:||
FUTURE GOALS STACK:
 ||
</blockquote><blockquote class="alectryon-message">Rocq-<span class="kn">Elpi</span> mapping:
RAW:
<span class="nl">?X57</span> &lt;-&gt; c0 \ X1 c0 ELAB:
<span class="nl">?X57</span> &lt;-&gt; X0 </blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>In addition to the goal we print the Elpi and Coq proof state,
plus the link between them.
The proof state is the collection of goals together with their types.</p>
<p>On the Elpi side this state is represented by constraints for the <code class="e elpi">evar</code>
predicate.</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->{c0} : decl c0 `x` (global (indt ¬´nat¬ª))
  ?- evar (X1 c0) 
      (app
        [global (indt ¬´eq¬ª), global (indt ¬´nat¬ª), 
         app
          [global (const ¬´Nat.add¬ª), c0, 
           app [global (indc ¬´S¬ª), global (indc ¬´O¬ª)]], 
         global (indc ¬´O¬ª)]) (X0 c0)  /* suspended on X1, X0 */</pre><p>One can recognize the set of bound variables <code class="highlight coq"><span class="o">{</span><span class="n">c0</span><span class="o">}</span></code>, the hypothetical
context of rules about these variable (that also corresponds to the proof
context), and finally the suspended goal <code class="e elpi">evar<span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">X1</span><span class="w"> </span>c0<span class="p">)</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">X0</span><span class="w"> </span>c0<span class="p">)</span></code>.</p>
<p>The set of constraints on <code class="highlight coq"><span class="nb">evar</span></code> represents the Coq data structure called
sigma (sometimes also called evd or evar_map) that is used to
represent the proof state in Coq. It is printed just afterwards:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->EVARS:
 ?X57==[x |- x + 1 = 0] (goal evar) {?Goal}
 ?X56==[ |- =&gt; fun x : nat =&gt; ?Goal] (goal evar)
 ?X55==[x |- =&gt; nat] (parameter A of eq)
 ?X54==[ |- =&gt; nat] (type of x)

SHELF:||
FUTURE GOALS STACK:
 ||
</pre><pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Rocq-Elpi mapping:
RAW:
?X57 &lt;-&gt; c0 \ X1 c0 ELAB:
?X57 &lt;-&gt; X0 </pre><p>Here <code class="highlight coq"><span class="nl">?X57</span></code> is a Coq evar linked with Elpi's <code class="e elpi"><span class="n-ElpiVariable">X0</span></code> and <code class="e elpi"><span class="n-ElpiVariable">X1</span></code>.
<code class="e elpi"><span class="n-ElpiVariable">X1</span></code> represents the goal (the trigger) while <code class="e elpi"><span class="n-ElpiVariable">X0</span></code> represent the proof.
The meaning of the <code class="e elpi">evar</code> Elpi predicate linking the two is that the term
assigned to the trigger <code class="e elpi"><span class="n-ElpiVariable">X1</span></code> has to be elaborated to the final proof term
<code class="e elpi"><span class="n-ElpiVariable">X0</span></code>, that should be a well typed term of type <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">0</span></code>.
This means that when an Elpi tactic assigns a value to <code class="e elpi"><span class="n-ElpiVariable">X1</span></code> some procedure to
turn that value into <code class="e elpi"><span class="n-ElpiVariable">X0</span></code> is triggered. That procedure is called
elaboration and it is currently implemented by calling the
<a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L1476">coq.elaborate-skeleton</a> API.</p>
<p>Given this set up, it is impossible to use a term of the wrong type as a
Proof. Let's rewrite the <code class="highlight coq"><span class="nb">split</span></code> tactic without using <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> split_ll.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class="si">{{</span> <span class="si">lp:</span><span class=" -ElpiVariable">A</span> /\ <span class="si">lp:</span><span class=" -ElpiVariable">B</span> <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!,</span>
<span class="w">    </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="si">{{</span> conj _ _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class="c">% triggers elaboration, filling Proof</span>
<span class="w">    </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="si">{{</span> conj <span class="si">lp:</span><span class=" -ElpiVariable">Pa</span> <span class="si">lp:</span><span class=" -ElpiVariable">Pb</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>seal<span class="w"> </span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>seal<span class="w"> </span><span class=" -ElpiVariable">G2</span><span class="k k-ElpiKeyword">],</span>
<span class="w">    </span><span class=" -ElpiVariable">G1</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">A</span><span class="w"> </span><span class=" -ElpiVariable">Pa</span><span class="w"> </span><span class="k k-ElpiKeyword">[],</span>
<span class="w">    </span><span class=" -ElpiVariable">G2</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">B</span><span class="w"> </span><span class=" -ElpiVariable">Pb</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;not a conjunction&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk39"><span class="kn">Lemma</span> <span class="nf">test_split_ll</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3a"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3b"><span class="kp">repeat</span> <span class="nb">elpi</span> split_ll.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Crafting by hand the list of subgoal is not easy.
In particular here we did not set up the new trigger for <code class="e elpi"><span class="n-ElpiVariable">Pa</span></code> and <code class="e elpi"><span class="n-ElpiVariable">Pb</span></code>,
nor seal the goals appropriately (we did not bind proof variables).</p>
<p>The <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L1618">coq.ltac.collect-goals</a> API helps us doing this.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> split_ll_bis.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class="si">{{</span> <span class="si">lp:</span><span class=" -ElpiVariable">A</span> /\ <span class="si">lp:</span><span class=" -ElpiVariable">B</span> <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!,</span>
<span class="w">    </span><span class="c">% this triggers the elaboration</span>
<span class="w">    </span><span class=" -ElpiVariable">Trigger</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class="si">{{</span> conj _ _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span><span class="w">                   </span>
<span class="w">    </span><span class="c">% we only take main goals</span>
<span class="w">    </span>coq.ltac.collect-goals<span class="w"> </span><span class=" -ElpiVariable">Proof</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class=" -ElpiVariable">_ShelvedGL</span>.
<span class="w">  </span>solve<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;not a conjunction&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3c"><span class="kn">Lemma</span> <span class="nf">test_split_ll_bis</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3d"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3e"><span class="kp">repeat</span> <span class="nb">elpi</span> split_ll_bis.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>At the light of that, <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a> is simply:</p>
<pre class="code elpi literal-block">
refine<span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class="n-ElpiVariable">_</span><span class="w"> </span><span class="n-ElpiVariable">RawEv</span><span class="w"> </span><span class="n-ElpiVariable">_</span><span class="w"> </span><span class="n-ElpiVariable">Ev</span><span class="w"> </span><span class="n-ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">GS</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w">
  </span><span class="n-ElpiVariable">RawEv</span><span class="w"> </span><span class="k-ElpiKeyword">=</span><span class="w"> </span><span class="n-ElpiVariable">T</span><span class="k-ElpiKeyword">,</span><span class="w"> </span>coq.ltac.collect-goals<span class="w"> </span><span class="n-ElpiVariable">Ev</span><span class="w"> </span><span class="n-ElpiVariable">GS</span><span class="w"> </span><span class="n-ElpiVariable">_</span><span class="o">.</span>
</pre>
<p>Now that we know the low level plumbing, we can use <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L10">refine</a> ;-)</p>
<p>The only detail we still have to explain is what exactly a
<a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L381">sealed-goal</a> is. A sealed goal wraps into a single object all
the proof variables and the assumptions about them, making this object easy
(or better, sound) to pass around.</p>
<div class="section" id="multi-goal-tactics">
<h2><a class="toc-backref" href="#toc-entry-10">multi-goal tactics</a></h2>
<p>Since Coq 8.4 tactics can see more than one goal (multi-goal tactics).
You can access this feature by using <code class="highlight coq"><span class="kp">all</span><span class="o">:</span></code> goal selector:</p>
<ul class="simple">
<li>if the tactic is a regular one, it will be used on each goal independently</li>
<li>if the tactic is a multi-goal one, it will receive all goals</li>
</ul>
<p>In Elpi you can implement a multi-goal tactic by providing a rule for
the <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L187">msolve</a> predicate. Since such a tactic will need to manipulate
multiple goals, potentially living in different proof context, it receives
a list of <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L381">sealed-goal</a>, a data type which seals a goal and
its proof context.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> ngoals.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>msolve<span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;#goals =&quot;</span><span class="w"> </span>{std.length<span class="w"> </span><span class=" -ElpiVariable">GL</span>},
<span class="w">    </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3f"><span class="kn">Lemma</span> <span class="nf">test_undup</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk40"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk41"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk42"><span class="kp">all</span>: <span class="nb">elpi</span> ngoals.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">#goals = <span class="mi">2</span></blockquote><blockquote class="alectryon-message">[nabla c0 \
  nabla c1 \
   seal
    (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X0 c0 c1) c0 
      (X1 c0 c1) []), 
 nabla c0 \
  nabla c1 \
   seal
    (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X2 c0 c1) c1 
      (X3 c0 c1) [])]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk43"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>This simple tactic prints the number of goals it receives, as well as
the list itself. We see something like:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->#goals = 2</pre><pre class="alectryon-block highlight"><!-- Generator: Alectryon --><span class="k k-ElpiKeyword">[</span>nabla<span class="w"> </span>c0<span class="w"> </span>\
<span class="w">  </span>nabla<span class="w"> </span>c1<span class="w"> </span>\
<span class="w">   </span>seal
<span class="w">    </span><span class="p">(</span>goal<span class="w"> </span><span class="k k-ElpiKeyword">[</span>decl<span class="w"> </span>c1<span class="w"> </span>`Q`<span class="w"> </span><span class="p">(</span>sort<span class="w"> </span>prop<span class="p">)</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>decl<span class="w"> </span>c0<span class="w"> </span>`P`<span class="w"> </span><span class="p">(</span>sort<span class="w"> </span>prop<span class="p">)</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">X0</span><span class="w"> </span>c0<span class="w"> </span>c1<span class="p">)</span><span class="w"> </span>c0<span class="w"> </span>
<span class="w">      </span><span class="p">(</span><span class=" -ElpiVariable">X1</span><span class="w"> </span>c0<span class="w"> </span>c1<span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>
<span class="w"> </span>nabla<span class="w"> </span>c0<span class="w"> </span>\
<span class="w">  </span>nabla<span class="w"> </span>c1<span class="w"> </span>\
<span class="w">   </span>seal
<span class="w">    </span><span class="p">(</span>goal<span class="w"> </span><span class="k k-ElpiKeyword">[</span>decl<span class="w"> </span>c1<span class="w"> </span>`Q`<span class="w"> </span><span class="p">(</span>sort<span class="w"> </span>prop<span class="p">)</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>decl<span class="w"> </span>c0<span class="w"> </span>`P`<span class="w"> </span><span class="p">(</span>sort<span class="w"> </span>prop<span class="p">)</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">X2</span><span class="w"> </span>c0<span class="w"> </span>c1<span class="p">)</span><span class="w"> </span>c1<span class="w"> </span>
<span class="w">      </span><span class="p">(</span><span class=" -ElpiVariable">X3</span><span class="w"> </span>c0<span class="w"> </span>c1<span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="p">)</span><span class="k k-ElpiKeyword">]</span></pre><p><a class="reference external constructor ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L382">nabla</a> binds all proof variables, then <a class="reference external constructor ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L383">seal</a>
holds a regular goal, which in turn carries the proof context.</p>
<p>In order to operate inside a goal one can use the <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L85">coq.ltac.open</a> utility,
which postulates all proof variables using <code class="e elpi"><span class="k-ElpiKeyword">pi</span><span class="w"> </span><span class="n-ElpiVariable">x</span>\<span class="w"> </span></code> and loads the proof
context using <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code>.</p>
<p>Operating on multiple goals at the same time is doable, but not easy.
In particular the two proof context have to be related in some way.</p>
<p>The following simple multi goal tactic shrinks the list of goals by
removing duplicates. As one can see, there is much room for improvement
in the <code class="e elpi">same-ctx</code> predicate.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> undup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">same-goal</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">sealed-goal</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">sealed-goal</span>.
<span class="w">  </span>same-goal<span class="w"> </span><span class="p">(</span>nabla<span class="w"> </span><span class=" -ElpiVariable">G1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span>nabla<span class="w"> </span><span class=" -ElpiVariable">G2</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% TODO: proof variables could be permuted</span>
<span class="w">    </span><span class="k k-ElpiKeyword">pi</span><span class="w"> </span><span class=" -ElpiVariable">x</span>\<span class="w"> </span>same-goal<span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">G1</span><span class="w"> </span>x<span class="p">)</span><span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">G2</span><span class="w"> </span>x<span class="p">)</span>.
<span class="w">  </span>same-goal<span class="w"> </span><span class="p">(</span>seal<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx1</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty1</span><span class="w"> </span><span class=" -ElpiVariable">P1</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G1</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span>seal<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx2</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Ty2</span><span class="w"> </span><span class=" -ElpiVariable">P2</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G2</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>same-ctx<span class="w"> </span><span class=" -ElpiVariable">Ctx1</span><span class="w"> </span><span class=" -ElpiVariable">Ctx2</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class="c">% this is an elpi builtin, aka same_term, which does not</span>
<span class="w">    </span><span class="c">% unify but rather compare two terms without assigning variables</span>
<span class="w">    </span><span class=" -ElpiVariable">Ty1</span><span class="w"> </span><span class="k k-ElpiKeyword">==</span><span class="w"> </span><span class=" -ElpiVariable">Ty2</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class=" -ElpiVariable">P1</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span><span class=" -ElpiVariable">P2</span>.

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">same-ctx</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">goal-ctx</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">goal-ctx</span>.
<span class="w">  </span>same-ctx<span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span>.
<span class="w">  </span>same-ctx<span class="w"> </span><span class="k k-ElpiKeyword">[</span>decl<span class="w"> </span><span class=" -ElpiVariable">V</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">C1</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>decl<span class="w"> </span><span class=" -ElpiVariable">V</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">T2</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">C2</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% TODO: we could compare up to permutation...</span>
<span class="w">    </span><span class="c">% TODO: we could try to relate def and decl</span>
<span class="w">    </span><span class=" -ElpiVariable">T1</span><span class="w"> </span><span class="k k-ElpiKeyword">==</span><span class="w"> </span><span class=" -ElpiVariable">T2</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>same-ctx<span class="w"> </span><span class=" -ElpiVariable">C1</span><span class="w"> </span><span class=" -ElpiVariable">C2</span>.

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">undup</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">sealed-goal</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">list</span><span class="w"> </span><span class="kt">sealed-goal</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">list</span><span class="w"> </span><span class="kt">sealed-goal</span>.
<span class="w">  </span>undup<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span>.
<span class="w">  </span>undup<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GN</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">GN</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>same-goal<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">G1</span>.
<span class="w">  </span>undup<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GN</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GL</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>undup<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GN</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="w">  </span>msolve<span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GS</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GL</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class="c">% TODO: we could find all duplicates, not just</span>
<span class="w">    </span><span class="c">% copies of the first goal...</span>
<span class="w">    </span>undup<span class="w"> </span><span class=" -ElpiVariable">G1</span><span class="w"> </span><span class=" -ElpiVariable">GS</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk44"><span class="kn">Lemma</span> <span class="nf">test_undup</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ Q /\ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk45"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk46"><hr></label><div class="goal-conclusion">Q</div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk47"><hr></label><div class="goal-conclusion">P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk48"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">fun</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) =&gt;
 conj <span class="nl">?Goal</span> (conj <span class="nl">?Goal0</span> <span class="nl">?Goal1</span>))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk49"><span class="kp">all</span>: <span class="nb">elpi</span> undup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk4a"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4b"><span class="kn">Show</span>  <span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">fun</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) =&gt;
 conj <span class="nl">?Goal</span> (conj <span class="nl">?Goal0</span> <span class="nl">?Goal</span>))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The two calls to show proof display, respectively:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->(fun (P Q : Prop) (p : P) (q : Q) =&gt;
 conj ?Goal (conj ?Goal0 ?Goal1))</pre><pre class="alectryon-block highlight"><!-- Generator: Alectryon -->(fun (P Q : Prop) (p : P) (q : Q) =&gt;
 conj ?Goal (conj ?Goal0 ?Goal))</pre><p>the proof term is the same but for the fact that after the tactic the first
and last missing subterm (incomplete proof tree branch) are represented by
the same hole <code class="highlight coq"><span class="nl">?Goal</span></code>. Indeed by solving one, we can also solve the other.</p>
</div>
<div class="section" id="lcf-tacticals">
<h2><a class="toc-backref" href="#toc-entry-11">LCF tacticals</a></h2>
<p>On the notion of sealed-goal it is easy to define the usual LCF combinators,
also known as Ltac tacticals. Tacticals usually take in input one or more
tactic, here the precise type definition:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">typeabbrev</span><span class="w"> </span><span class="n-ElpiFunction">tactic</span><span class="w"> </span><span class="kt">(sealed-goal</span><span class="w"> </span><span class="kt">-&gt;</span><span class="w"> </span><span class="kt">(list</span><span class="w"> </span><span class="kt">sealed-goal</span><span class="w"> </span><span class="kt">-&gt;</span><span class="w"> </span><span class="k-ElpiMode">prop</span><span class="kt">))</span>.
</pre>
<p>A few tacticals can be found in the
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-ltac.elpi">elpi-ltac.elpi file</a>.
For example this is the code of <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L58">try</a>:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span><span class="w"> </span><span class="n-ElpiFunction">try</span><span class="w"> </span><span class="k-ElpiMode">i:</span><span class="kt">tactic</span><span class="k-ElpiMode">,</span><span class="w"> </span><span class="k-ElpiMode">i:</span><span class="kt">sealed-goal</span><span class="k-ElpiMode">,</span><span class="w"> </span><span class="k-ElpiMode">o:</span><span class="kt">list</span><span class="w"> </span><span class="kt">sealed-goal</span>.<span class="w">
</span>try<span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">G</span><span class="w"> </span><span class="n-ElpiVariable">GS</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">G</span><span class="w"> </span><span class="n-ElpiVariable">GS</span><span class="o">.</span><span class="w">
</span>try<span class="w"> </span><span class="n-ElpiVariable">_</span><span class="w"> </span><span class="n-ElpiVariable">G</span><span class="w"> </span><span class="k-ElpiKeyword">[</span><span class="n-ElpiVariable">G</span><span class="k-ElpiKeyword">]</span><span class="o">.</span>
</pre>
</div>
<div class="section" id="setting-arguments-for-a-tactic">
<h2><a class="toc-backref" href="#toc-entry-12">Setting arguments for a tactic</a></h2>
<p>As we hinted before, tactic arguments are attached to the goal since
they can mention proof variables. So the Ltac code:</p>
<pre class="code coq literal-block">
<span class="nb">intro</span> <span class="n">H</span><span class="o">;</span> <span class="nb">apply</span> <span class="n">H</span><span class="o">.</span>
</pre>
<p>has to be seen as 3 steps, starting from a goal <code class="highlight coq"><span class="n">G</span></code>:</p>
<ul class="simple">
<li>introduction of <code class="highlight coq"><span class="n">H</span></code>, obtaining <code class="highlight coq"><span class="n">G1</span></code></li>
<li>setting the argument <code class="highlight coq"><span class="n">H</span></code>, obtaining <code class="highlight coq"><span class="n">G2</span></code></li>
<li>calling apply, obtaining <code class="highlight coq"><span class="n">G3</span></code></li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> argpass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="c">% this directive lets you use short names</span>
<span class="k k-ElpiKeyword">shorten</span><span class="w"> </span>coq.ltac.{ open<span class="k k-ElpiKeyword">,</span><span class="w"> </span>thenl<span class="k k-ElpiKeyword">,</span><span class="w"> </span>all<span class="w"> </span>}.

<span class="k k-ElpiKeyword">type</span><span class="w"> </span><span class=" -ElpiFunction">intro</span><span class="w"> </span><span class="kt">open-tactic</span>.<span class="w"> </span><span class="c">% goal -&gt; list sealed-goal</span>
intro<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>refine<span class="w"> </span><span class="si">{{</span> <span class="kr">fun</span> <span class="nv">H</span> =&gt; _ <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="k k-ElpiKeyword">type</span><span class="w"> </span><span class=" -ElpiFunction">set-arg-n-hyp</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">-&gt;</span><span class="w"> </span><span class="kt">open-tactic</span>.
set-arg-n-hyp<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">SG1</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">  </span>std.nth<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class=" -ElpiVariable">Ctx</span><span class="w"> </span><span class="p">(</span>decl<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span>
<span class="w">  </span>coq.ltac.set-goal-arguments<span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class="p">(</span>seal<span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">SG1</span>.

<span class="k k-ElpiKeyword">type</span><span class="w"> </span><span class=" -ElpiFunction">apply</span><span class="w"> </span><span class="kt">open-tactic</span>.
apply<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>refine<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

msolve<span class="w"> </span><span class=" -ElpiVariable">SG</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">  </span>all<span class="w"> </span><span class="p">(</span>thenl<span class="w"> </span><span class="k k-ElpiKeyword">[</span><span class="w"> </span>open<span class="w"> </span>intro<span class="k k-ElpiKeyword">,</span>
<span class="w">               </span>open<span class="w"> </span><span class="p">(</span>set-arg-n-hyp<span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span>
<span class="w">               </span>open<span class="w"> </span>apply<span class="w"> </span><span class="k k-ElpiKeyword">]</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">SG</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4e"><span class="kn">Lemma</span> <span class="nf">test_argpass</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : P -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> argpass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Of course the tactic playing the role of <code class="highlight coq"><span class="nb">intro</span></code> could communicate back
a datum to be passed to what follows</p>
<pre class="code elpi literal-block">
thenl<span class="w"> </span><span class="k-ElpiKeyword">[</span><span class="w"> </span>open<span class="w"> </span><span class="p">(</span>tac1<span class="w"> </span><span class="n-ElpiVariable">Datum</span><span class="p">)</span><span class="k-ElpiKeyword">,</span><span class="w"> </span>open<span class="w"> </span><span class="p">(</span>tac2<span class="w"> </span><span class="n-ElpiVariable">Datum</span><span class="p">)</span><span class="w"> </span><span class="k-ElpiKeyword">]</span>
</pre>
<p>but the binder structure of <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/builtin-doc/coq-builtin.elpi#L381">sealed-goal</a> would prevent <code class="e elpi"><span class="n-ElpiVariable">Datum</span></code>
to mention proof variables, that would otherwise escape the sealing.</p>
<p>The utility <a class="reference external libtac ghref" href="https://github.com/LPCIC/coq-elpi/blob/9d9fc5185c6fff8e37ebad2ab32ebfec6202b869/elpi/elpi-ltac.elpi#L49">set-goal-arguments</a>:</p>
<pre class="code elpi literal-block">
coq.ltac.set-goal-arguments<span class="w"> </span><span class="n-ElpiVariable">Args</span><span class="w"> </span><span class="n-ElpiVariable">G</span><span class="w"> </span><span class="n-ElpiVariable">G1</span><span class="w"> </span><span class="n-ElpiVariable">G1wArgs</span>
</pre>
<p>tries to move <code class="e elpi"><span class="n-ElpiVariable">Args</span></code> from the context of <code class="e elpi"><span class="n-ElpiVariable">G</span></code> to the one of <code class="e elpi"><span class="n-ElpiVariable">G1</span></code>.
Relating the two proof contexts is not obvious: you may need to write your
own procedure if the two contexts are very distant.</p>
</div>
</div>
<div class="section" id="tactics-in-terms">
<h1><a class="toc-backref" href="#toc-entry-13">Tactics in terms</a></h1>
<p>Elpi tactics can be used inside terms via the usual <code class="highlight coq"><span class="kp">ltac</span><span class="o">:(...)</span></code>
quotation, but can also be exported to the term grammar.</p>
<p>Here we write a simple tactic for default values, which
optionally takes a bound to the search depth.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">default</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">term</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">int</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">term</span>.

<span class="w">  </span>default<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.ltac.fail<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;max search depth reached&quot;</span>.
<span class="w">  </span>default<span class="w"> </span><span class="si">{{</span> nat <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="si">{{</span> <span class="mi">46</span> <span class="si">}}</span>.
<span class="w">  </span>default<span class="w"> </span><span class="si">{{</span> bool <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="si">{{</span> false <span class="si">}}</span>.
<span class="w">  </span>default<span class="w"> </span><span class="si">{{</span> list <span class="si">lp:</span><span class=" -ElpiVariable">A</span> <span class="si">}}</span><span class="w"> </span><span class=" -ElpiVariable">Max</span><span class="w"> </span><span class="si">{{</span> cons <span class="si">lp:</span><span class=" -ElpiVariable">D</span> nil <span class="si">}}</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class=" -ElpiVariable">Max&#39;</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span><span class=" -ElpiVariable">Max</span><span class="w"> </span><span class="k k-ElpiKeyword">-</span><span class="w"> </span><span class="mi">1</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>default<span class="w"> </span><span class=" -ElpiVariable">A</span><span class="w"> </span><span class=" -ElpiVariable">Max&#39;</span><span class="w"> </span><span class=" -ElpiVariable">D</span>.

<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>default<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class="mi">9999</span><span class="w"> </span><span class=" -ElpiVariable">P</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>refine<span class="w"> </span><span class=" -ElpiVariable">P</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">foo</span> : nat := default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4f"><span class="kn">Print</span> foo.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">foo = <span class="mi">46</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bar</span> : list bool := default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk50"><span class="kn">Print</span> bar.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bar = (false :: nil)%list
     : list bool</blockquote></div></div></small></span></pre><p>The grammar entries for Elpi tactics in terms take an arbitrary
number of arguments with the limitation that they are all terms:
you can't pass a string or an integer as one would normally do.</p>
<p>Here we use Coq's primitive integers to pass the search depth
(in a compact way).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> default <span class="si">lp:{{</span>
<span class="w">  </span>solve<span class="w"> </span><span class="p">(</span>goal<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class="p">(</span>primitive<span class="w"> </span><span class="p">(</span>uint63<span class="w"> </span><span class=" -ElpiVariable">Max</span><span class="p">))</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">as</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">GL</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.uint63-&gt;int<span class="w"> </span><span class=" -ElpiVariable">Max</span><span class="w"> </span><span class=" -ElpiVariable">MaxI</span><span class="k k-ElpiKeyword">,</span><span class="w">    </span>
<span class="w">    </span>default<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">MaxI</span><span class="w"> </span><span class=" -ElpiVariable">P</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>refine<span class="w"> </span><span class=" -ElpiVariable">P</span><span class="w"> </span><span class=" -ElpiVariable">G</span><span class="w"> </span><span class=" -ElpiVariable">GL</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk51"><span class="kn">From</span> <span class="nb">elpi</span>.core <span class="kn">Require Import</span> PrimInt63.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_core_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> uint63_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-tactic-v-chk52"><span class="kn">Definition</span> <span class="nf">baz</span> : list nat := default <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Tactic</span> failure: max search depth reached.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">baz</span> : list nat := default <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk53"><span class="kn">Print</span> baz.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">baz = (<span class="mi">46</span>%nat :: nil)%list
     : list nat</blockquote></div></div></small></span></pre><p>That is all folks!</p>
</div>
</div>
</div>
</div></body>
</html>
