/* elpi-ltac: building blocks for tactics                                    */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

shorten std.{rev, append, exists, exists2, do!, flatten, map}.

pred rawevar->evar i:term, o:term.

constraint declare-evar evar decl def cache rawevar->evar rm-evar {

  % TODO: nabla close the solution for G
  rule (E1 : _ ?- evar (uvar R _) _ (uvar X _))
     \ (E2 : rawevar->evar (uvar R L) G)
     | (std.forall L name)
    <=> (E2 : G = (uvar X L)).

   rule (evar _ _ _)
     \ (rawevar->evar (uvar R _) _)
    <=> (print_constraints, halt "not a raw uvar:" R).

}

typeabbrev tactic (goal -> (list goal -> prop)).

pred apply i:list goal, i:tactic , o:list goal.
apply [G|Gs] Tac O :- enter G Tac O1, apply Gs Tac O2, append O1 O2 O.
apply [] _ [].

pred distribute i:(term -> list goal), o:list goal.
distribute (_\ []) [].
distribute (x\ [X x| XS x]) [nabla X|R] :- distribute XS R.

pred enter i:goal, i:tactic, o:list goal.
enter (nabla G) T O :- (pi x\ enter (G x) T (NG x)), distribute NG O.
enter (goal _ _ _ _ as G) T O :- T G O.

pred refine i:term, i:goal, o:list goal.
refine T (goal Ctx _ _ _ as G) GS :- Ctx => coq.ltac1.refine T G GS.

pred assumption i:goal, o:list goal.
assumption (goal Ctx Ev _ _) [] :-
  exists Ctx (x\ (x = decl Ev _ _ ; x = def Ev _ _ _)).

pred constructor i:goal, o:list goal.
constructor (goal Ctx _ Ty _ as G) GS :- do! [
  Ctx => whd Ty [] (global (indt GR)) _,
  coq.env.indt GR _ _ _ _ Ks Kt,
  exists2 Ks Kt (k\ t\ sigma P\
    Ctx => saturate t (global (indc k)) P,
    refine P G GS)
].

pred intro i:name, i:goal, o:list goal.
intro N G GS :- refine (fun N Src_ Tgt_) G GS.

pred saturate i:term, i:term, o:term.
saturate Ty T O :- whd Ty [] (prod _ _ Tgt) [], !, coq.mk-app T [Hole_] R, pi x\ saturate (Tgt x) R O.
saturate _ X X.

pred try i:tactic, i:goal, o:list goal.
try T G GS :- enter G T GS.
try _ G [G].

pred repeat i:tactic, i:goal, o:list goal.
repeat T G GS :- enter G T GS1, apply GS1 (repeat T) GS.
repeat _ G [G].

pred repeat! i:tactic, i:goal, o:list goal.
repeat! T G GS :- enter G T GS1, !, apply GS1 (repeat T) GS.
repeat! _ G [G].

pred or i:list tactic, i:goal, o:list goal.
or TL G GS :- exists TL (t\ enter G t GS).

pred thenl i:list tactic, i:goal, o:list goal.
thenl [] G [G].
thenl [T|Ts] G GS :- enter G T NG, apply NG (thenl Ts) GS.
