/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace tc {

  % return if a gref is an existsing instance
  % TODO: this could be replaced with an API
  % coq.TC.get-class-of-inst i:gref, o:gref
  pred existing-instance i:gref.
  existing-instance InstGR :-
    coq.env.typeof InstGR InstTy,
    get-TC-of-inst-type InstTy ClassGR,
    coq.TC.class? ClassGR,
    coq.TC.db-for ClassGR DB, 
    std.mem! DB (tc-instance InstGR _).

  pred under-p-global i:term, o:gref.
  under-p-global (global GR) GR.
  under-p-global (pglobal GR _) GR.

  pred class-gref i:term, o:gref.
  class-gref T ClassGR :- 
    under-p-global T ClassGR, 
    coq.TC.class? ClassGR.

  % returns the TC from the type of an instance
  % TODO: This could be replaced with an api 
  % coq.TC.get-class-of-inst i:gref, o:gref
  pred get-TC-of-inst-type i:term, o:gref.
  get-TC-of-inst-type (prod _ _ A) ClassGR:- !,
    pi x\ get-TC-of-inst-type (A x) ClassGR.
  get-TC-of-inst-type T ClassGR :-
    coq.safe-dest-app T HD _,
    not (var HD), class-gref HD ClassGR.

  pred instances-of-current-section o:list gref.
  :name "MySectionEndHook"
  instances-of-current-section InstsFiltered :-
    coq.env.current-section-path SectionPath,
    std.findall (tc.instance SectionPath _ _ _) Insts,
    coq.env.section SectionVars,
    std.map-filter Insts (x\r\ sigma X\ tc.instance _ r _ _ = x, const X = r, not(std.mem SectionVars X)) InstsFiltered.

  pred is-instance-gr i:gref.
  is-instance-gr GR :-
    coq.env.typeof GR Ty,
    is-instance-term Ty.

  pred is-instance-term i:term.
  is-instance-term T :-
    get-TC-of-inst-type T TC,
    coq.TC.class? TC.

  % adds a clause to the tc.db DB at the passed grafting
  pred add-tc-db o:id, o:grafting, i:prop.  
  add-tc-db ClauseName Graft PR :-
    if (not (ground_term PR)) (coq.error "[TC] anomaly: open rule:" PR) true,
    coq.elpi.accumulate _ "tc.db" 
      (clause ClauseName Graft PR); coq.error "cannot add " PR " to tc.db".

  % takes a tc-instance and return the gref of the inst
  pred inst->gref i:tc-instance, o:gref.
  inst->gref (tc-instance Res _) Res.

  % returns all the instances of the passed ClassName
  pred get-inst-by-tc-name i:gref, o:list gref.
  get-inst-by-tc-name TC GRL:-
    coq.TC.db-for TC Inst,
    std.map Inst inst->gref GRL',
    std.rev GRL' GRL. 

  pred app-has-class i:term.
  app-has-class T :- 
    get-TC-of-inst-type T Hd, 
    coq.TC.class? Hd. 

  % TC preds are on the form tc-[PATH_TO_TC].tc-[TC-Name]
  pred gref->pred-name i:gref, o:string.
  gref->pred-name Gr S :-
    if (tc.is-option-active tc.oTC-clauseNameShortName)
      (Path = "")
      (coq.gref->path Gr [Hd | Tl], 
        if (Hd = "Coq") (Hd' = "Stdlib") (Hd' = Hd),
        std.string.concat "." [Hd'|Tl] Path',
        Path is Path' ^ ".tc-"),
    % CAVEAT : Non-ascii caractars can't be part of a pred
    %          name, we replace รถ with o
    rex.replace "รถ" "o" {coq.gref->id Gr} GrStr,
    S is "tc-" ^ Path ^ GrStr.

  /* 
  [make-tc.aux B Sol Head Body Rule] builds the rule with the given Head and body
                                    paying attention to the positivity of the
                                    clause  
  Note: if the Rule being constructed is negative (B = ff), then Rules returns a
        solution Sol used inside the proof. If the solution is already given, we
        do not run the premise. This would ask Sol to be ground (ground_term S).
        Here, for performance issues, we simply check that the solution is not a
        flexible term
  */
  pred make-tc.aux i:bool, i:term, i:prop, i:list prop, o:prop.
  make-tc.aux tt _ Head [] Head :- !.
  make-tc.aux ff Sol Head [] P :- !, P = if (var Sol) Head true.
  make-tc.aux tt _ Head Body (Head :- Body) :- !.
  make-tc.aux ff Sol Head Body P :- !, P = if (var Sol) (Body => Head) true.

  /*
    [make-tc InstTy Sol RuleBody IsPositive Rule]
    - InstTy is the type of a class where all prod have been eaten by the
      compiling phase. If some of these prod are type-classes then they are
      collected in `RuleBody`
    - Sol is the name of the instance being compiled
    - IsPositive tell if the we are in positive or negative position.
    - Rule is the rule to add in the database of instance, i.e. the compiled
      instance. Note that `Rule` is not a closed term, it contains quantified
      variables but no `pi` in front of it. It is the compiler which accumulates
  */
  pred make-tc i:term, i:term, i:list prop, i:bool, o:prop.
  make-tc InstTy Sol RuleBody IsPositive Rule :-
    coq.safe-dest-app InstTy Class Args,
    get-TC-of-inst-type Class ClassGR,
    gref->pred-name ClassGR ClassStr,
    std.append Args [Sol] ArgsSol, 
    coq.elpi.predicate ClassStr ArgsSol RuleHead,
    make-tc.aux IsPositive Sol RuleHead RuleBody Rule.

    pred unwrap-prio i:tc-priority, o:int.
    unwrap-prio (tc-priority-given Prio) Prio.
    unwrap-prio (tc-priority-computed Prio) Prio.

  % returns the priority of an instance from the gref of an instance
  pred get-inst-prio i:gref, o:int.
  get-inst-prio InstGR Prio :-
    coq.env.typeof InstGR InstTy,
    get-TC-of-inst-type InstTy ClassGR,
    unwrap-prio {coq.TC.get-inst-prio ClassGR InstGR} Prio.

  pred get-full-path i:gref, o:string.
  get-full-path Gr Res' :-
    coq.gref->string Gr Path,
    coq.env.current-section-path SectionPath,
    std.fold SectionPath "" (e\acc\r\ r is acc ^ "." ^ e) Res,
    Res' is Res ^ Path.

  pred constant->redflag i:prop, o:coq.redflag.
  constant->redflag (tc.unfold-constant C) (coq.redflags.const C).

  pred normalize-ty i:term, o:term.
  :name "normalize-ty"
  normalize-ty G1 G2 :-
    std.findall (tc.unfold-constant _) UnfoldFindall,
    std.map UnfoldFindall constant->redflag UnfoldRF,
    coq.redflags.add coq.redflags.nored [coq.redflags.beta, coq.redflags.delta | UnfoldRF] RF,
    @redflags! RF => coq.reduction.lazy.norm G1 G2.

  pred remove-clause i:string, i:prop, i:list prop.
  remove-clause ClauseName P Locality :-
    %Locality => add-tc-db _ (remove ClauseName) P.
    Locality => add-tc-db _ (replace ClauseName) (P :- fail).

  % [section-var->decl.aux L R] auxiliary function for `section-var->decl`
  pred section-var->decl.aux i:list constant, o:list prop.
  section-var->decl.aux [] [].
  section-var->decl.aux [X|XS] [Y|YS] :-
    coq.env.typeof (const X) Ty,
    Y = (decl (global (const X)) _ Ty),
    section-var->decl.aux XS YS.

  % [section-var->decl L] decl representing seciton variables with their types
  pred section-var->decl o:list prop.
  section-var->decl L :-
    section-var->decl.aux {coq.env.section} L.

  pred time-is-active i:(list string -> prop).
  :name "time-is-active"
  time-is-active _ :- coq.option.get ["Time", "TC", "Bench"] (coq.option.bool tt), !.
  time-is-active Opt :- tc.is-option-active Opt. 

  pred time-aux i:string, i:float.
  time-aux Msg Time :- !, coq.debug "[TC] - Time of" Msg "is" Time.

  pred give-res i:prop, o:prop.
  give-res P true :- P.
  give-res _ fail.

  pred time-res i:prop, o:float, o:prop.
  time-res P T Res :- std.time (give-res P Res) T.

  pred build-msg i:prop, i:string, o:string.
  build-msg true S S :- !.
  build-msg fail S S' :- S' is S ^ " fail".

  pred time-it i:(list string -> prop), i:prop, i:string.
  time-it Opt P Msg :- time-is-active Opt, !, time-res P Time Res, build-msg Res Msg Msg', time-aux Msg' Time, Res.
  time-it _ P _ :- P.

  kind range-arity type.
  type r-ar nat -> nat -> range-arity.

  type prod-range 
    term ->          % The current qunatified uvar 
    range-arity ->   % Its minimum and maximal application
    term.

  type maybe-eta-tm 
    term ->          % The current precompiled subterm
    list term ->     % The list of FV in the precomp subterm
    term.

  type maybe-llam-tm 
    term ->          % The current precompiled subterm: shape is app[app[X,PF],NPF]
    list term ->     % The eta-expanded version of X, from X^{len(PF)} to X^{len(PF)+len(NPF)}
    term.
}
