namespace tc {
  namespace link {
    pred relocate i:list term, i:list term, i:term, o:term.
    relocate [] [] T T' :- copy T T'.
    relocate [X|Xs] [Y|Ys] T T' :- (copy Y X :- !) => relocate Xs Ys T T'.

    pred get-vars i:term, o:list term.
    get-vars T R :-
      (pi X H L Ign\ fold-map X L X [H|L] :- var X H Ign, !) => 
        fold-map T [] _ R.

    pred split-pf i:list term, i:list term, o:list term, o:list term.
    split-pf [] _ [] [] :- !.
    split-pf [X|Xs] Old [X|Ys] L :- name X, not (std.mem! Old X), !, split-pf Xs [X|Old] Ys L.
    split-pf Xs _ [] Xs.

    % [build-eta-llam-links.aux LHS Scope Ty Names PF NPF OldLinks NewVar NewLinks]
    :index(_ _ _ _ 3)
    pred build-eta-llam-links.aux i:term, i:list term, o:term, i:list term, i:list term, i:list term, i:list prop, o:term, o:list prop.
    build-eta-llam-links.aux _   _ _       _     []  []  _  _  _ :-coq.error "MH?".
    build-eta-llam-links.aux LHS _ _       Names []  NPF OL HD [llam T (app [LHS | NPF]) | OL] :- !,
      prune T Names, var T HD _. 
    build-eta-llam-links.aux LHS SC (prod _ Ty _)       _    [X] []  OL HD [eta LHS (fun `_` Ty (x\ V x)) | OL] :- !,
      prune V SC, var (V X) HD _.
    build-eta-llam-links.aux LHS SC (prod _ Ty Bo) Names [X|XS] NPF OL HD [eta LHS (fun `_` Ty (x\ LHS' x)) | L] :- !,
      std.append SC [X] SC',
      prune LHS' SC, build-eta-llam-links.aux (LHS' X) SC' (Bo X) Names XS NPF OL HD L.
    build-eta-llam-links.aux LHS SC Ty Names ([_|_] as PF) NPF OL HD L :-
      % Ty is expected to be of (forall x, ...), however, this can be hidden 
      % under a definition to be unfolded. The unify-eq below is to perform the unfold
      Ty' = prod _ _ _, coq.unify-eq Ty Ty' ok, !,
      build-eta-llam-links.aux LHS SC Ty' Names PF NPF OL HD L.
    
    % [build-eta-llam-links T OldLinks X NewLinks]  
    % T = app[(uvar _ Scope) | S] this term is problematic and asks for the
    % creation of eta- and/or llam-links. Below some examples:

    % eta: when compiling t = (app [X, x, y]) and [x,y] are distinct_names, then
    %     the coq variable has not [x,y] in scope: it is applied to them.  
    %     The solution is to build the following links:  
    %     NewLinks = [X =η (λa.Y a),     a |- Y a =η (λb.Z a b)]
    %     and the exposed variable is G, given by `var G Z [x, y]`

    % llam: when compiling t = (app [X, a, x]) where a is a constant and x a
    %       name, we build a llam link.  
    %       The link will be: NewLinks ] = [T x =L X a x]  
    %       and the exposed variable is G, given by `var G T [x]`

    % eta-llam: here a combination of eta and llam:  
    %       let t = (app [X x y, z, c, w, d]) where X is a coq var with x and y
    %       in scope, z and w are names and c, d are constants.  
    %       In this case, the links should be:  
    %       NewLinks = [X x y =η (λa.Y x y a),   a |- Z x y a w =L (app[Y x y a, c w d])]  
    %       and the exposed variable is G, given by `var Z T [x, y, z, w]`  
    pred build-eta-llam-links i:term, i:list prop, o:term, o:list prop.
    build-eta-llam-links (app[(uvar _ Scope as V) | S] as T) Links G NewLinks :- !,
      coq.typecheck V Ty ok,
      split-pf S Scope PF NPF,
      free-names T Names,
      build-eta-llam-links.aux V Scope Ty Names PF NPF Links LhsHd NewLinks,
      prune G Names,
      var G LhsHd Names.
    build-eta-llam-links T _ _ _ :- coq.error "[TC] invalid call to build-eta-llam-links:" T.

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % ETA LINK                                                                 %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    namespace eta {
      pred eta-expand i:term, o:term.  
      eta-expand T1 (fun _ _ B) :- pi x\ coq.mk-app T1 [x] (B x). 

      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- name N, !.
      may-contract-to L N (uvar _ S) :- !,
          std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      :index (_ 1)
      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ uvar :- !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      maybe-eta-aux (uvar _ S) L :- std.forall L (std.mem! S).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      pred unify-left-right i:term, i:term.
      unify-left-right (fun _ _ A) (fun _ _ A') :- !, pi x\ unify-left-right (A x) (A' x).
      unify-left-right A (fun _ _ _ as T) :- !, eta-expand A Ae, pi x\ unify-left-right Ae T.
      unify-left-right A A' :- A = A'.

      pred progress-eta-left i:term, o:term.
      progress-eta-left (fun _ _ _ as A) B :- !, A = B.
      progress-eta-left A B :- eta-expand A A', !, A' = B.

      pred progress-eta-right? i:term, o:term.
      progress-eta-right? A A' :- coq.reduction.eta-contract A A', not (A = A'), !.
      progress-eta-right? A A :- not (maybe-eta A), !.

      pred scope-check i:term, i:term.
      scope-check (uvar _ L) T :- prune A L, A = T, !.

      pred unify-eta i:term, i:term.
      % unify-eta A B :- coq.say "Unify-eta" "A"A"B"B, fail.
      unify-eta (uvar _ _ as A) B :- !, A = B, !.
      unify-eta (fun _ _ A) (fun _ _ B) :- !, pi x\ unify-eta (A x) (B x).
      unify-eta A (fun _ _ _ as B) :- !, eta-expand A A', unify-eta A' B.
      unify-eta A B :- A = B.

      constraint eta solve-eta {
        rule solve-eta \ (eta A B _) <=> (unify-eta A B).
        rule \ solve-eta.
        % If two eta links have same lhs they rhs should unify
        rule (N1 :> G1 ?- eta (uvar X L1) (fun _ T1 B1) _) 
            \ (N2 :> G2 ?- eta (uvar X L2) (fun _ T2 B2) _) 
            | (pi x\ relocate L1 L2 (B2 x) (B2' x))
        <=> (N1 :> G1 ?- B1 = B2').
      }

      :index (0 1)
      pred eta i:term, i:term, i:list term.
      eta _ uvar _ :- coq.error "[TC] link.eta error, flexible rhs".
      eta A (fun _ _ B as T) _ :- not (var A), not (var B), !, unify-left-right A T.
      eta A (fun _ _ B as T) _ :- not (var (B _)), progress-eta-right? T T', !, A = T'. 
      eta A B                _ :- not (var A), !, progress-eta-left A B.
      eta (uvar as A) B Vars :- 
        scope-check A B, std.filter Vars (x\ var x) Vars', 
        declare_constraint (eta A B Vars') [_,A|Vars'].
    }

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % LLAM LINK                                                                %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    namespace llam {
      % A llam link is suspended on its lhs and the head of its rhs
      % Note: to avoid not pf elpi variable, the coq term `app[A, x, t]` where
      % A is a uvar, x a name and t a term, is represented with the llam rhs:
      % app[A' x, t] instead of (A' x t).
      pred llam i:term, i:term.
      llam A (uvar _ S as T) :- distinct_names S, !, A = T.
      llam (uvar as A) (app [(uvar as HD)|_] as T) :- !, 
        declare_constraint (llam A T) [_,A,HD].
      llam (fun _ _ _ as F) (app [(uvar _ Scope as H) | TL]) :- !, 
          std.drop-last 1 TL TL', 
          H = fun _ _Ty (x\ Bo'),  % TODO give a valid _Ty: should be: (Ty of dropped -> Ty of F)
          prune H' Scope,
          coq.mk-app H' TL' Bo',
          pi x\ llam F Bo'.
      llam A B :- !, tc.unify-eq A B.

      constraint solve-llam llam {
        rule solve-llam \ (llam A B) <=> (A = B).
        rule \ solve-llam.
        % If two llam links have same lhs they rhs should unify
        rule (N1 :> G1 ?- llam (uvar X L1) T1) 
            \ (N2 :> G2 ?- llam (uvar X L2) T2) 
            | (pi x\ relocate L1 L2 T2 T2')  
        <=> (N1 :> G1 ?- T1 = T2'). % TODO: instead of elpi unif, should use heuristics...
      }
    }

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % CS LINK                                                                  %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    namespace cs {
      pred reduce-cs i:term, i:term, i:term, i:constant.
      reduce-cs V (app [ProjT, T]) Record Proj :-
        coq.unify-eq T Record Err, Err = ok,
        Q = [coq.redflags.const Proj],
        coq.redflags.add coq.redflags.nored [coq.redflags.delta, coq.redflags.beta, coq.redflags.match | Q] RF,
        (@redflags! RF => coq.reduction.lazy.whd (app [ProjT, Record]) V'),
        not (V' = match _ _ _), !,
        cs V V'.
      reduce-cs V T _ _ :- V = T.

      pred cs i:term, i:term.
      cs T1 T2 :- not (var T1), !, coq.unify-eq T1 T2 ok.
      cs (uvar as V) (app [_, Arg] as T) :- not (ground_term Arg), !, get-vars T Vars, declare_constraint (cs V T) [_, V | Vars].
      cs (uvar as V) (app [HD, _Arg] as T) :- 
        tc.coercion-unify HD, !, 
        get-vars T Vars, declare_constraint (cs V T) [_, V | Vars].

      cs (uvar as V) (app [HD | TL] as T) :- 
        if (HD = global (const Proj), tc.proj->record Proj Record)
          (reduce-cs V T Record Proj)
          % Note: Below we cannot unify V and T since T may contain
          %       deep projections which must be considered as problematic terms
          %       To avoid the problem, we compile all subterms in TL, the probl
          %       subterms are replaced with variables put into links
          (tc.compile.goal (app TL) (app TL') Links, do Links, V = app [HD|TL']), !.
      cs T1 T2 :- not (T2 = app _), !, coq.unify-eq T1 T2 ok.

      pred unify-under-ctx i:list term, i:list term, i:term, i:term, i:term, i:term.
      unify-under-ctx [] [] A B V1 V2 :- copy A A', copy V1 V1', !, coq.unify-eq A' B ok, !, V1' = V2.
      unify-under-ctx [X|XS] [Y|YS] A B V1 V2:- (copy X Y :- !) => unify-under-ctx XS YS A B V1 V2.

      % TODO: there could be two same variables suspended on non unifyable
      % terms, this should be detected and raise a failure.
      % An example of this is in test/canonical_struct.v
      constraint cache def decl coq.unify-eq ?- solve-cs cs {
        rule solve-cs \ (Ctx ?- cs A B) <=> (Ctx => coq.unify-eq A B ok).
        rule (Ctx1 ?- cs (uvar A L1 as X) T1) \ (Ctx2 ?- cs (uvar A L2 as Y) T2) <=>
          (Ctx2 => unify-under-ctx L1 L2 T1 T2 X Y).
        rule \ solve-cs.
      }
    }

    % The last argument contain the list of vars on which the link is
    % suspended. In order to avoid a call to get-vars if the link is to be 
    % re-suspended, we explicetely pass this list once when the link is 
    % created
    pred eta i:term, i:term.
    eta A B :- !, get-vars B V, eta.eta A B [A|V].

    pred solve-eta.
    solve-eta :- declare_constraint solve-eta [_].

    pred llam i:term, i:term.
    llam A B :- llam.llam A B.

    pred solve-llam.
    solve-llam :- declare_constraint solve-llam [_].

    pred cs i:term, i:term.
    cs A B :- cs.cs A B.

    pred solve-cs.
    solve-cs :- declare_constraint solve-cs [_].
  }
}