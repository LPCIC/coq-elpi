namespace tc {
  namespace compile {
    namespace goal {
      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- !.
      % TODO: here we should do var V _ Scope and use scope: N can be in Scope but not in S
      may-contract-to L N (app [V|S]) :- var V, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      :index (_ 1)
      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ (app [N|_]) :- var N, !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      % TODO: here we should do var V _ Scope and use Scope: an elt in L can appear in Scope
      maybe-eta-aux (app[V|S]) L :- var V, !,
        std.forall L (x\ exists! S (y\ may-contract-to [] x y)).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      pred used i:term, i:term.
      used X (uvar _ S) :- std.mem! S X, !.
      used X (fun _ _ Bo) :- pi x\ used X (Bo x).

      pred close-term-prune-safe-fun i:(term -> list term), i:term, o:list term.
      close-term-prune-safe-fun (x\ []) _ [] :- !.
      close-term-prune-safe-fun (x\ [X x | Xs x]) Ty [fun _ _ X | Xs'] :-
        pi x\ used x (X x), !, close-term-prune-safe-fun Xs Ty Xs'.
      close-term-prune-safe-fun (x\ [X | Xs x]) Ty [X | Xs'] :-
        close-term-prune-safe-fun Xs Ty Xs'.

      pred compile-full-aux-close i:(term -> term), i:term, i:list prop, o:(term -> term), o:list prop.
      compile-full-aux-close Bo Ty L Bo' L' :-
        (pi x\ compile-full-aux (Bo x) [] (Bo' x) (BoL x)),
      % TODO: maybe attach to the links the list of used binders, to simply make this check?
      % Maybe L' is a pair list links and list binders per link, this way we can easily prune
        close-prop-no-prune-pi-decl BoL Ty BoL',
        std.append L BoL' L'.

      pred compile-full-aux i:term, i:list prop, o:term, o:list prop.
      compile-full-aux (global _ as G) L G L :- !.
      compile-full-aux (pglobal _ _ as G) L G L :- !.
      compile-full-aux (sort _ as G) L G L :- !.

      % Link for coercion
      compile-full-aux (app [HD|_] as G) L G' [tc.link.cs G' G | L] :- tc.coercion-unify HD, !.
      
      % Link for canonical structure
      compile-full-aux (app [global (const C) | _] as G) L G' [tc.link.cs G' G | L] :- coq.env.projection? C _, !.
      
      % Link for primitive projection
      compile-full-aux (app [primitive (proj P _) | _] as G) L G' [tc.link.cs G' G | L] :- coq.env.primitive-projection? P _, !.

      % Link for eta-redex
      compile-full-aux (fun Name_ Ty Bo as G) L G' [tc.link.eta G' (fun `_` Ty' Bo') | L'] :- maybe-eta G, !,
        compile-full-aux Ty L Ty' LTy,
        compile-full-aux-close Bo Ty LTy Bo' L'.

      compile-full-aux (fun Name Ty Bo) L (fun Name Ty' Bo') L' :- !,
        compile-full-aux Ty L Ty' LTy,
        compile-full-aux-close Bo Ty LTy Bo' L'.

      compile-full-aux (prod Name Ty Bo) L (prod Name Ty' Bo') L' :- !,
        compile-full-aux Ty L Ty' LTy,
        compile-full-aux-close Bo Ty LTy Bo' L'.

      % TODO: to avoid too many chain for the same var, maybe pass a list into the fold
      compile-full-aux (app [(uvar _ _ as V) | S]) L G' L'' :- !,
        std.fold-map S L compile-full-aux S' L', % L' = Links built for S
        tc.link.build-eta-llam-links (app [V|S']) L' G' L''.

      compile-full-aux (app L) A (app L1) A1 :- !, std.fold-map L A compile-full-aux L1 A1.

      compile-full-aux (let N T B F) A (let N T1 B1 F1) A3 :- !,
        compile-full-aux T A T1 A1, compile-full-aux B A1 B1 A2,
        compile-full-aux-close F T A2 F1 A3.
      
      compile-full-aux (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
        compile-full-aux Ty A Ty1 A1, 
        compile-full-aux-close F Ty A1 F1 A2.
      
      compile-full-aux (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
        compile-full-aux T A T1 A1,
        compile-full-aux Rty A1 Rty1 A2,
        std.fold-map B A2 compile-full-aux B1 A3.
      
      compile-full-aux (uvar _ _ as X) A X A :- !.
      compile-full-aux X A X A :- name X, !.

      compile-full-aux A B _ _ :- coq.error "Fail to compile-full-aux" A B.

      % takes a term t and returns a term t' and a list of links.
      pred compile-full i:term, o:term, o:list prop.
      compile-full Goal Goal' Links :- compile-full-aux Goal [] Goal' Links.
    }

    % [goal T T' L] takes a term T and returns a new term T' where problematic
    % subterms (see this: https://dl.acm.org/doi/10.1145/3678232.3678233)
    % are replaced with fresh variables. The list of links is L
    pred goal i:term, o:term, o:list prop.
    :name "compile-goal"
    goal Goal Goal' Links :- 
      goal.compile-full-aux Goal [] Goal' Links.
  }
}
