/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace tc {
  shorten tc.{pending-mode}.

  typeabbrev elpi-mode (pair argument_mode string).
  typeabbrev elpi-modeL (list elpi-mode).
  typeabbrev string-modeL (list string).
  macro @pending-mode! :- "pending mode".

  pred is-mode-ground i:string.
  is-mode-ground "plus".
  is-mode-ground "ground".
  is-mode-ground "g".
  is-mode-ground "+".

  pred is-mode-ouput i:string.
  is-mode-ouput "o".
  is-mode-ouput "-".
  is-mode-ouput "minus".

  pred is-mode-input i:string.
  is-mode-input "bang".
  is-mode-input "i".
  is-mode-input "!".

  pred string->coq-mode i:string, o:hint-mode.
  string->coq-mode S mode-ground :- is-mode-ground S, !.
  string->coq-mode S mode-output :- is-mode-ouput S, !.
  string->coq-mode S mode-input  :- is-mode-input S, !.
  string->coq-mode A B :- coq.error "[TC] string->coq-mode:" A "," B "is not a valid mode".

  pred string->elpi-mode i:string, o:elpi-mode.
  string->elpi-mode uvar uvar :- coq.error "[TC] string->elpi-mode call with 2 flex args".

  /*  
    this is an approximation!
    the input mode of coq tests that the arg has a rigid head.
    e.g. (tc-Eq (list nat) => tc-Eq (list X))
    in coq succeeds, in elpi it does not...
    to solve the issue we cast coq-input in elpi-output :-)
  */
  string->elpi-mode S (pr out "term")  :- is-mode-input S, !.

  /* 
    here another approximation!
    the ground-mode of coq tests that the args is ground.
    e.g (tc-CatchAll X => tc-CatchAll (list X))
    succeeds in elpi but not in coq...
  */
  string->elpi-mode S (pr in "term")  :- is-mode-ground S, !.

  /*
    output is the only compatible mode!
  */
  string->elpi-mode S (pr out "term") :- is-mode-ouput S, !.
  string->elpi-mode A B :- coq.error "[TC] the call `string->elpi-mode" A B "` is not valid".

  pred coq->string-mode i:hint-mode, o:string.
  coq->string-mode mode-ground "g".
  coq->string-mode mode-input "i".
  coq->string-mode mode-output "o".

  % Here we build the elpi modes a class CL. If CL has either zero or more than
  % one mode, then we consider all its parameter to be in output mode. If the
  % class has exactly one mode, then it is considered for the signature of the
  % predicate for CL 
  pred modes-of-class i:gref, o:list string.
  modes-of-class ClassGR Modes :- 
    coq.hints.modes ClassGR "typeclass_instances" CoqModesList,
    if (CoqModesList = [_,_|_])
      (coq.warning "TC.Modes" "an elpi predicate has one mode, the class" {coq.gref->string ClassGR} "has" {std.length CoqModesList} "(all arguments will be put in output mode)", fail)
      true,
    CoqModesList = [HintModesFst],
    std.append {std.map HintModesFst coq->string-mode} ["o"] Modes.
  modes-of-class ClassGR Modes :- 
    coq.env.typeof ClassGR ClassTy,
    N is {coq.count-prods ClassTy} + 1, % + 1 for the solution
    list-init N (x\r\ r = "o") Modes.

  pred add-pending-mode i:list string.
  add-pending-mode _ :-
    pending-mode _, 
    coq.error "[TC] A pending mode already exists. Build a class with that mode to avoid this error".
  add-pending-mode M :-
    tc.add-tc-db @pending-mode! _ (pending-mode M).

  pred remove-pending-mode.
  remove-pending-mode :-
    tc.remove-clause @pending-mode! (pending-mode []) [].

  pred check-pending-mode-arity i:gref, i:list A.
  check-pending-mode-arity GR L :-
    coq.env.typeof GR Ty,
    coq.count-prods Ty N,
    N' is N + 1,
    std.assert! (std.length L N') "Pending mode invalid for class GR".

  pred get-elpi-mode i:gref, i:tc.pending.modes, o:elpi-modeL, o:string-modeL.
  % empty pending mode list, means that we look for modes declared in coq
  get-elpi-mode ClassGR (tc.pending.modes []) EM SM :- !,
    modes-of-class ClassGR SM, 
    std.map SM string->elpi-mode EM.
  % we have 
  get-elpi-mode ClassGR (tc.pending.modes SM) EM SM :-
    check-pending-mode-arity ClassGR SM, 
    std.map SM string->elpi-mode EM.

  pred get-evars i:term, o:list term.
  get-evars T L :-
    (pi hd T L\ fold-map T L _ [hd | L] :- var T hd _, !) =>
    fold-map T [] _ L.

  pred evars o:term.

  pred action-to-accumulate i:string, i:term, o:list prop.
  action-to-accumulate _ T [evars HD] :- var T HD _, !.
  action-to-accumulate _ _ [].

  pred mode-check-ground i:term.
  % heuristic: all evars in T should only be in that argument
  mode-check-ground T :-
    std.findall-unary evars L,
    get-evars T EV,
    std.forall EV (x\ std.forall L (x'\ not (x == x'))).

  pred mode-check i:string, i:term.
  % approximation only at top level we check that the argument in ground mode
  % (for Coq) is groud. During the recursive calls, since we use elpi input
  % mode, we don't verify this property anymore
  mode-check S T :- is-mode-ground S, !, mode-check-ground T.

  % approximation: only at top level we check that the argument in input mode
  % (for Coq) is not flex (i.e. has a rigid head). During the recursive calls,
  % since we use elpi output mode (see rules for string->elpi-mode) we stop
  % verifying this property
  mode-check S uvar :- is-mode-input S, !, fail.
  mode-check _ _.

  pred modes-check.aux i:list string, i:list term.
  modes-check.aux [] [_|_] :- coq.error "[TC] modes-check invalid list length".
  modes-check.aux [_|_] [] :- coq.error "[TC] modes-check invalid list length".
  modes-check.aux [] [].
  modes-check.aux [X|XS] [Y|YS] :- std.do![
      mode-check X Y,                       % check on argument X wrt mode Y
      action-to-accumulate X Y P,           % action P to accumulate
      P => modes-check.aux XS YS            % accumulate P and iterate of XS YS 
    ].

  % used by the solver to check that the top level arguments respects the modes
  % declared in coq
  pred modes-check i:term.
  modes-check (global _).
  modes-check (pglobal _ _).
  modes-check (app [ClassTerm | Args]) :-
    tc.class-gref ClassTerm ClassGR,
    tc.get-mode ClassGR M,
    std.drop-last 1 M M',
    modes-check.aux M' Args.

  pred get-mode i:gref, o:list string.
  get-mode ClassGR M :- tc.class ClassGR _ _ M, !.
  get-mode ClassGR _ :- coq.error "[TC]" ClassGR "is an unknown class".
}
