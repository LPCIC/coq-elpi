/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace tc {
  shorten tc.{search-mode}.

  % The predicate of a class is local if inside a section and readded at section
  % end. This way, section variables are generalized
  pred get-class-locality o:list prop. 
  get-class-locality [@local!] :- coq.env.current-section-path [_ | _], !.
  get-class-locality [@global!].

  % [declare-class-in-elpi SearchMode ClassGR] adds the elpi predicate for the
  % given class  
  pred declare-class-in-elpi i:gref.
  declare-class-in-elpi ClassGR :- tc.class ClassGR _ _ _, !. % Nothing is done since the predicate already exists
  declare-class-in-elpi ClassGR :-
    std.assert! (coq.TC.class? ClassGR) "Only gref of type classes can be added as new predicates",
    tc.pending.get Mode Functionality_ SearchMode,
    tc.get-elpi-mode ClassGR Mode EM SM,
    tc.gref->pred-name ClassGR PredName,
    get-class-locality Locality, 
    Locality => (
      coq.elpi.add-predicate "tc.db" _ PredName EM,
      tc.add-tc-db _ _ (tc.class ClassGR PredName SearchMode SM)).

  pred add-class-str i:string.
  add-class-str ClassStr :-
    coq.locate ClassStr ClassGR,
    declare-class-in-elpi ClassGR.

  pred get-key-from-option i:prop, o:string. 
  get-key-from-option (get-option A tt) A :- !.
  get-key-from-option (get-option "i" ff) "o" :- !.
  get-key-from-option (get-option "o" ff) "i" :- !.
  get-key-from-option A _ :- coq.error A "should be an option".


  /* 
    CAVEAT: TC.Declare does not trasmit implicit arguments are not transmitted to the new created
    class in Coq.

    NOTE: when we declare a class in Coq, the listener (TC.Compiler) will be
    called in order to add the corresponding predicate in the elpi database.
    However, this call to the listener is not aware of the attributes (Modes,
    SearchMode, Functionality...) passed to the pragma TC.Declare. Therefore the
    `tc.class ClassGR PredName SearchMode RawModes'` is needed and has higher
    priority of the tc.class rule added by the subsequent call to
    `declare-class-in-coq`
  */
  pred declare-class-in-coq i:gref.
  declare-class-in-coq ClassGR :- 
    % TODO: Functional should be taken into account
    tc.pending.att-parser-for-pred (tc.pending.modes RawModes) _Functional SearchMode,

    if (RawModes = [])
      (
        % now modes declared with Pending_attributes command, take the one
        % declared in Coq
        tc.modes-of-class ClassGR RawModes'
      )(
        % The next row is a conversion from string list to hint-mode list
        std.map RawModes tc.string->coq-mode CoqModes,
        % the last is the output carrying the instance of the rule
        % this information must not be transmitted to coq mode signature
        std.drop-last 1 CoqModes CoqModes',
        coq.hints.add-mode ClassGR "typeclass_instances" CoqModes',
        RawModes = RawModes'
      ),
    
    % this triggers the observer TC.Compiler
    coq.TC.declare-class ClassGR,
    tc.gref->pred-name ClassGR PredName,
    get-class-locality Locality, 
    Locality => tc.add-tc-db _ (after "0") (tc.class ClassGR PredName SearchMode RawModes' :- !).

  pred declare-class i:indt-decl. 
  declare-class D :- !, 
    coq.env.add-indt D I,
    declare-class-in-coq (indt I).

  % Contains some instruction that are executed just after the creation of the
  % predicate for the class
  namespace dead-code-eta-reduction-aux {
    pred is-functional i:term.
    is-functional (prod _ _ _).

    pred replace i:list term, i:term, o:list term, o:term.
    replace [] _ [] _ :- !.
    replace [(fun _ _ _ as T) | Xs] X' [X' | Xs] T :- !.
    replace [X | XS] NEW [X | YS] S :- replace XS NEW YS S.

    % a call to compile builds a new rule for the given class where only one 
    % parameter P of function type is crafted. Compiled rules have only one
    % premise where P is possibly eta-contructed at runtime. The absence of bang
    % in the first rule (after is-functional T) allows to get all rules for and
    % functional parameter through the std.findall in the main predicate below.
    pred compile i:gref, i:term, i:bool, i:list term, o:prop.
    compile ClassGR (prod _ T Bo) ff L (pi name ty body\ Cl body ty name) :-
      is-functional T, pi name ty body x\ sigma Inp\
        Inp = (fun name ty body),
        compile ClassGR (Bo x) tt [Inp|L] (Cl name ty body).

    compile ClassGR (prod _ _ Bo) S L (pi x\ Cl x) :-
      pi x\ compile ClassGR (Bo x) S [x|L] (Cl x).

    compile ClassGR (sort _) tt L (pi sol new-term\ Cl new-term sol) :-
      pi solution new-term\ sigma Args Args' Q Q'\
        std.do![
          tc.gref->pred-name ClassGR PredName,
          std.rev [solution | L] Args,
          replace Args new-term Args' T,
          coq.elpi.predicate PredName Args Q,
          coq.elpi.predicate PredName Args' Q',
          (Cl new-term solution) =
            (Q :- [coq.reduction.eta-contract T new-term,
                  if (T == new-term) fail (Q')])
        ].

    % A debug predicate to print the genereted clauses
    pred generated-clauses.

    pred main i:string.
    main S :-
      coq.locate S ClassGR,
      coq.env.typeof ClassGR ClassTy,
      % a clause for eta contruction per argument of functional type is created
      % we get all the rules with the finall
      std.findall (compile ClassGR ClassTy ff [] _) SFindall,
      std.map SFindall (x\r\ compile _ _ _ _ r = x) SMap,
      if generated-clauses (coq.say SMap) true,
      std.forall SMap (tc.add-tc-db _ _).
  }
}