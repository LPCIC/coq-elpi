/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate base.

pred time-solve i:prop.
time-solve P :-
  std.time P Time,
  if-true (is-option-active oTC-time) 
    (coq.say "[TC] Total resolution time is:" Time).

msolve L N :- !,
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) {std.rev L} N).

% solve A L :- time-solve (solve-aux A L).

% [section-var->decl.aux L R] auxiliary function for `section-var->decl`
pred section-var->decl.aux i:list constant, o:list prop.
section-var->decl.aux [] [].
section-var->decl.aux [X|XS] [Y|YS] :-
  coq.env.typeof (const X) Ty,
  Y = (decl (global (const X)) _ Ty),
  section-var->decl.aux XS YS.

% [section-var->decl L] decl representing seciton variables with their types
pred section-var->decl o:list prop.
section-var->decl L :-
  section-var->decl.aux {coq.env.section} L.

% [build-hypotheses Ctx Hyps] returns the list of hypotheses, made of the
% variables in the context and the current section
pred build-hypotheses i:list prop, o:list prop.
:name "build-hypotheses"
build-hypotheses Ctx Clauses :-
  std.append Ctx {section-var->decl} CtxAndSection,
  compile-ctx CtxAndSection Clauses. 

pred tc-recursive-search.aux i:term, i:list term, i:list term, o:term.
tc-recursive-search.aux T _ _ Proof :-
  ho-preprocess T Ty PostProcess,
  std.do![
    coq.safe-dest-app Ty (global TC) TL',
    std.append TL' [Proof] TL,
    coq.elpi.predicate {gref->pred-name TC} TL Q], 
  do [Q | PostProcess].


% [tc-recursive-search Goal Solution] takes the type of the goal and solves it
pred tc-recursive-search i:term, o:term.
tc-recursive-search Goal Sol :- 
  std.time (
    tc-recursive-search.aux Goal PFVar PFVar Sol
  ) Time,
  if-true (is-option-active oTC-time-instance-search) 
    (coq.say "[TC] Instance search time is:" Time).

:if "solve-print-goal"
solve-aux (goal Ctx _ Ty _ _) _ :-
  coq.say "Ctx" Ctx "Ty" Ty, fail.

pred solve-aux i:goal, o:list sealed-goal.
solve-aux (goal _ _ (prod N _ _) _ _ as G) GL :- !,
  refine (fun N _ _) G GL1,
  coq.ltac.all (coq.ltac.open solve-aux) GL1 GL.
:name "solve-aux-base"
solve-aux (goal Ctx _ TyRaw Sol _ as G) GL :-
  var Sol,
  build-hypotheses Ctx Clauses,
  normalize-ty TyRaw Ty,
  if-true (print-goal) (coq.say "The goal is <<<" Ty ">>>"),
  Clauses => if (tc-recursive-search Ty Proof) 
    (
      if-true (print-solution) (coq.say "The proof is <<<" Proof ">>>"),
      if (is-option-active oTC-ignore-eta-reduction) 
        (Proof' = Proof) (coq.reduction.eta-contract Proof Proof'),
      std.time (refine Proof' G GL) Refine-Time, 
      if-true (is-option-active oTC-time-refine) 
        (coq.say "[TC] Refine time is:" Refine-Time);
      coq.error "illtyped solution:" {coq.term->string Proof}
    ) 
    (coq.ltac.fail _ "[TC] fail to solve" Ty).

main _.