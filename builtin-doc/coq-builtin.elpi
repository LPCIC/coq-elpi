

% Coq terms as the object language of elpi and basic API to access Coq
% license: GNU Lesser General Public License Version 2.1 or later
% -------------------------------------------------------------------------

% This file is automatically generated from
%  - coq-HOAS.elpi
%  - rocq_elpi_builtin.ml
% and contains the description of the data type of Coq terms and the
% API to access Coq.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%% coq-arg-HOAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This section contains the low level data types linking Coq and elpi.
% In particular the entry points for commands


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Entry points
%
% Command and tactic invocation
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Entry point for commands. Eg. "#[att=true] Elpi mycommand foo 3 (f x)." becomes
%   main [str "foo", int 3, trm (app[f,x])]
% in a context where
%   attributes [attribute "att" (leaf "true")]
% holds. The encoding of terms is described below.
% See also the coq.parse-attributes utility.
external pred main i:list argument.
external pred main-interp i:list argument, i:any.
external pred main-synterp i:list argument, o:any.
pred usage.
external pred attributes o:list attribute.

% see coq-lib.elpi for coq.parse-attributes generating the options below
external pred get-option o:string, o:A.

% The data type of arguments (for commands or tactics)
kind argument type.
external symbol int      : int    -> argument. % Eg. 1 -2.
external symbol str      : string -> argument. % Eg. x "y" z.w. or any Coq keyword/symbol
external symbol trm      : term   -> argument. % Eg. (t).
external symbol open-trm : int -> term -> argument.

% Extra arguments for commands. [Definition], [Axiom], [Record] and [Context]
% take precedence over the [str] argument above (when not "quoted").
%
% Eg. Record or Inductive
external symbol indt-decl : indt-decl -> argument.
% Eg. #[universes(polymorphic,...)] Record or Inductive
external symbol upoly-indt-decl : indt-decl -> upoly-decl -> argument.
% Eg. Definition or Axiom (when the body is none)
external symbol const-decl : id -> option term -> arity -> argument.
% Eg. #[universes(polymorphic,...)] Definition or Axiom
external symbol upoly-const-decl : id -> option term -> arity -> upoly-decl -> argument.
% Eg. Context A (b : A).
external symbol ctx-decl : context-decl -> argument.

% Declaration of inductive types %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

kind indt-decl type.
kind indc-decl type.
kind record-decl type.

% An arity is written, in Coq syntax, as:
%    (x : T1) .. (xn : Tn) : S1 -> ... -> Sn -> U
% This syntax is used, for example, in the type of an inductive type or
% in the type of constructors. We call the abstractions on the left of ":"
% "parameters" while we call the type following the ":" (proper) arity.

% Note: in some contexts, like the type of an inductive type constructor,
% Coq makes no distinction between these two writings
%    (xn : Tn) : forall y1 : S1, ...    and      (xn : Tn) (y1 : S1) : ...
% while Elpi is a bit more restrictive, since it understands user directives
% such as the implicit status of an arguments (eg, using {} instead of () around
% the binder), only on parameters.
% Moreover parameters carry the name given by the user as an "id", while binders
% in terms only carry it as a "name", an irrelevant pretty pringintg hint (see
% also the HOAS of terms). A user command can hence only use the names of
% parameters, and not the names of "forall" quantified variables in the arity.
%
% See also the arity->term predicate in coq-lib.elpi

kind arity type.
external symbol parameter   : id -> implicit_kind -> term -> (term -> arity) -> arity = "1".
external symbol arity       : term -> arity.

external symbol parameter   : id -> implicit_kind -> term -> (term -> indt-decl) -> indt-decl = "2".
external symbol inductive   : id -> bool -> arity -> (term -> list indc-decl) -> indt-decl. % tt means inductive, ff coinductive
external symbol record      : id -> term -> id -> record-decl -> indt-decl.

external symbol constructor : id -> arity -> indc-decl.

external symbol field       : field-attributes -> id -> term -> (term -> record-decl) -> record-decl.
external symbol end-record  : record-decl.

% Example.
% Remark that A is a regular parameter; y is a non-uniform parameter and t
% also features an index of type bool.
%
%  Inductive t (A : Type) | (y : nat) : bool -> Type :=
%  | K1 (x : A) {n : nat} : S n = y -> t A n true -> t A y true
%  | K2 : t A y false
%
% is written
%
%  (parameter "A" explicit {{ Type }} a\
%     inductive "t" tt (parameter "y" explicit {{ nat }} _\
%                     arity {{ bool -> Type }})
%      t\
%       [ constructor "K1"
%          (parameter "y" explicit {{ nat }} y\
%           (parameter "x" explicit a x\
%            (parameter "n" maximal {{ nat }} n\
%              arity {{ S lp:n = lp:y -> lp:t lp:n true -> lp:t lp:y true }})))
%       , constructor "K2"
%          (parameter "y" explicit {{ nat }} y\
%            arity {{ lp:t lp:y false }}) ])
%
% Remark that the uniform parameters are not passed to occurrences of t, since
% they never change, while non-uniform parameters are both abstracted
% in each constructor type and passed as arguments to t.
%
% The coq.typecheck-indt-decl API can be used to fill in implicit arguments
% an infer universe constraints in the declaration above (e.g. the hidden
% argument of "=" in the arity of K1).
%
% Note: when and inductive type declaration is passed as an argument to an
% Elpi command non uniform parameters must be separated from the uniform ones
% with a | (a syntax introduced in Coq 8.12 and accepted by rocq-elpi since
% version 1.4, in Coq this separator is optional, but not in Elpi).

% Context declaration (used as an argument to Elpi commands)
kind context-decl type.
% Eg. (x : T) or (x := B), body is optional, type may be a variable
external symbol context-item : id -> implicit_kind -> term -> option term -> (term -> context-decl) -> context-decl.
external symbol context-end  : context-decl.

typeabbrev field-attributes (list field-attribute).

macro @global!   :- get-option "coq:locality" "global".
macro @local!    :- get-option "coq:locality" "local".



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% coq-HOAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This section contains the low level data types linking Coq and elpi.
% In particular the data type for terms and the evar_map entries (a sequent)
% and the entry points for tactics

% Entry point for tactics. Eg. "elpi mytactic foo 3 (f x)." becomes
%   solve <goal> <new goals>
% Where [str "foo", int 3, trm (app[f,x])] is part of <goal>.
% The encoding of goals is described below.
% msolve is for tactics that operate on multiple goals (called via all: ).
external pred solve i:goal, o:list sealed-goal.
external pred msolve i:list sealed-goal, o:list sealed-goal.

% Extra arguments for tactics
external symbol tac : ltac1-tactic -> argument.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's terms
%
% Types of term formers
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -- terms --------------------------------------------------------------------
kind term type.

external symbol sort    : sort -> term. % Prop, Type@{i}

% constants: inductive types, inductive constructors, definitions
external symbol global  : gref -> term.
external symbol pglobal : gref -> univ-instance -> term.

% binders: to form functions, arities and local definitions
external symbol fun     : name -> term -> (term -> term) -> term.         % fun x : t =>
external symbol prod    : name -> term -> (term -> term) -> term.         % forall x : t,
external symbol let     : name -> term -> term -> (term -> term) -> term. % let x : T := v in

% other term formers: function application, pattern matching and recursion
external symbol app     : list term -> term.                   % app [hd|args]
external symbol match   : term -> term -> list term -> term.   % match t p [branch])
external symbol fix     : name -> int -> term -> (term -> term) -> term. % fix name rno ty bo

external symbol primitive : primitive-value -> term.

% NYI
%type cofix name -> term -> (term -> term) -> term. % cofix name ty bo

% Notes about (match Scrutinee TypingFunction Branches) when
%   Inductive i A : A -> nat -> Type := K : forall a : A, i A a 0
% and
%   Scrutinee be a term of type (i bool true 7)
%
% - TypingFunction has a very rigid shape that depends on i. Namely
%   as many lambdas as indexes plus one lambda for the inductive itself
%   where the value of the parameters are taken from the type of the scrutinee:
%     fun `a` (indt "bool") a\
%      fun `n` (indt "nat) n\
%       fun `i` (app[indt "i", indt "bool", a n) i\ ..
%   Such spine of fun cannot be omitted; else elpi cannot read the term back.
%   See also coq.bind-ind-arity-no-let in coq-lib.elpi, that builds such spine for you,
%   or the higher level api coq.build-match (same file) that also takes
%   care of branches.
% - Branches is a list of terms, the order is the canonical one (the order
%   of the constructors as they were declared). If the constructor has arguments
%   (excluding the parameters) then the corresponding term shall be a Coq
%   function. In this case
%      fun `x` (indt "bool") x\ ..

% -- helpers ------------------------------------------------------------------
macro @cast T TY :- (let `cast` TY T x\x).

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's evar_map
%
% Context and evar declaration
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% An evar_info (displayed as a Coq goal) is essentially a sequent:
%
% x : t
% y := v : x
% ----------
% p x y
%
% is coded as an Elpi query
%
% pi x1\ decl x1 `x` <t> =>
%  pi x2\ def x2 `y` x1 <v> =>
%   declare-evar
%      [def x2 `y` x1 <v> , decl x1 `x` <t>]
%      (RawEvar x1 x2) (<p> x1 x2) (Ev x1 x2)
%
% where, by default, declare-evar creates a syntactic constraint as
%
% {x1 x2} :
%   decl x1 `x` <t>, def x2 `y` x1 <v> ?-
%     evar (RawEvar x1 x2) (<p> x1 x2) (Ev x1 x2)  /* suspended on RawEvar, Ev */
%
% When the program is over, a remaining syntactic constraint like the one above
% is read back and transformed into the corresponding evar_info.

external func decl term -> name, term. % Var Name Ty
external func def  term -> name, term, term. % Var Name Ty Bo
external func cache term -> term.

external pred declare-evar i:list prop, i:term, i:term, i:term. % Ctx RawEvar Ty Evar

:name "default-declare-evar"
declare-evar Ctx RawEv Ty Ev :-
  declare_constraint (declare-evar Ctx RawEv Ty Ev) [RawEv].

% When a goal (evar _ _ _) is turned into a constraint the context is filtered
% to only contain decl, def, pp.  For now no handling rules for this set of
% constraints other than one to remove a constraint

external pred rm-evar i:term, i:term.
rm-evar (uvar as X) (uvar as Y):- !, declare_constraint (rm-evar X Y) [X,Y].
rm-evar _ _.

constraint declare-evar evar def decl cache rm-evar {

   % Override the actual context
   rule \ (declare-evar Ctx RawEv Ty Ev) <=> (Ctx => evar RawEv Ty Ev).

   rule \ (rm-evar (uvar X _) (uvar Y _)) (evar (uvar X _) _ (uvar Y _)).
   rule \ (rm-evar (uvar X _) (uvar Y _)).

}

% The (evar R Ty E) predicate suspends when R and E are flexible,
% and is solved otherwise.
% The client may want to provide an alternative implementation of
% the clause "default-assign-evar", for example to typechecks that the
% term assigned to E has type Ty, or that the term assigned to R
% elaborates to a term of type Ty that gets assigned to E.
% In tactic mode, elpi/coq-elaborator.elpi wires things up that way.

external pred evar i:term, i:term, o:term. % Evar Ty RefinedSolution
evar (uvar as X) T S :- var S _ VL, !,
  prune T VL, prune X VL, declare_constraint (evar X T S) [X, S].

:name "default-assign-evar"
evar _ _ _. % volatile, only unresolved evars are considered as evars

% To ease the creation of a context with decl and def
% Eg.  @pi-decl `x` <t> x1\ @pi-def `y` <t> <v> y\ ...
macro @pi-decl N T F :- pi x\ decl x N T => F x.
macro @pi-def N T B F :- pi x\ def x N T B => cache x B_ => F x.

% Converts an arity to a term
func coq.arity->term arity -> term.
coq.arity->term (parameter ID _ Ty Rest) (prod Name Ty R) :-
  coq.id->name ID Name,
  @pi-decl Name Ty x\ coq.arity->term (Rest x) (R x).
coq.arity->term (arity A) A.

macro @pi-parameter ID T F :-
  sigma N\ (coq.id->name ID N, pi x\ decl x N T => F x).
macro @pi-inductive ID A F :-
  sigma N\ (coq.id->name ID N, coq.arity->term A T, pi x\ decl x N T => F x).


% Sometimes it can be useful to pass to Coq a term with unification variables
% representing "untyped holes" like an implicit argument _. In particular
% a unification variable may exit the so called pattern fragment (applied
% to distinct variables) and hence cannot be reliably mapped to Coq as an evar,
% but can still be considered as an implicit argument.
% By loading in the context get-option "HOAS:holes" tt one forces that
% behavior. Here a convenience macro to be put on the LHS of =>
macro @holes! :- get-option "HOAS:holes" tt.

% Similarly, some APIs take a term skeleton in input. In that case unification
% variables are totally disregarded (not even mapped to Coq evars). They are
% interpreted as the {{ lib:elpi.hole }} constant, which represents an implicit
% argument. As a consequence these APIs don't modify the input term at all, but
% rather return a copy. Note that if {{ lib:elpi.hole }} is used directly, then
% it has to be applied to all variables in scope, since Coq erases variables
% that are not used. For example using {{ forall x : nat, lib:elpi.hole }} as
% a term skeleton is equivalent to {{ nat -> lib:elpi.hole }}, while
% {{ forall x : nat, lib:elpi.hole x lib:elpi.hole more args }} puts x in
% the scope of the hole (and passes to is more args).

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's goals and tactic invocation
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% A Coq goal is essentially a sequent, like the evar_info above, but since it
% has to be manipulated as first class Elpi data, it is represented in a slightly
% different way. For example
%
% x : t
% y := v : x
% ----------
% g x y
%
% is represented by the following term of type sealed-goal
%
%  nabla x1\
%   nabla x2\
%    seal
%      (goal
%         [def x2 `y` x1 <v> , decl x1 `x` <t>]
%         (RawEvar x1 x2) (<g> x1 x2) (Evar x1 x2)
%         (Arguments x1 x2))

kind goal type.
kind sealed-goal type.
external symbol nabla : (term -> sealed-goal) -> sealed-goal.
external symbol seal  : goal -> sealed-goal.

typeabbrev goal-ctx (list prop).
external symbol goal : goal-ctx -> term -> term -> term -> list argument -> goal.

% A sealed-goal closes with nabla the bound names of a
% 
%  (goal Ctx RawSolution Ty Solution Arguments)
%
% where Ctx is a list of decl or def and Solution is a unification variable
% to be assigned to a term of type Ty in order to make progress.
% RawSolution is used as a trigger: when a term is assigned to it, it is
% elaborated against Ty and the resulting term is assigned to Solution.
%
% Arguments contains data attached to the goal, which lives in its context
% and can be used by tactics to solve the goals.

% A tactic (an elpi predicate which makes progress on a Coq goal) is
% a predicate of type
%   sealed-goal -> list sealed-goal -> prop
% 
% while the main entry point for a tactic written in Elpi is solve
% which has type
%    goal -> list sealed-goal -> prop
%
% The utility (coq.ltac.open T G GL) postulates all the variables bounds
% by nabla and loads the goal context before calling T on the unsealed
% goal. The invocation of a tactic with arguments
%   3 x "y" (h x)
% on the previous goal results in the following Elpi query:
%
% (pi x1\ decl x1 `x` <t> =>
%   pi x2\ def x2 `y` x1 <v> =>
%    declare-evar
%       [def x2 `y` x1 <v> , decl x1 `x` <t>]
%       (RawEvar x1 x2) (<g> x1 x2) (Evar x1 x2)),
% (coq.ltac.open solve
%  (nabla x1\ nabla x2\ seal
%   (goal
%     [def x2 `y` x1 <v> , decl x1 `x` <t>]
%     (RawEvar x1 x2) (<g> x1 x2) (Evar x1 x2)
%     [int 3, str `x`, str`y`, trm (app[const `h`,x1])]))
%   NewGoals)
%
% If the goal sequent contains other evars, then a tactic invocation is
% an Elpi query made of the conjunction of all the declare-evar queries
% corresponding to these evars and the query corresponding to the goal
% sequent. NewGoals can be assigned to a list of goals that should be
% declared as open. Omitted goals are shelved. If NewGoals is not
% assigned, then all unresolved evars become new goals, but the order
% of such goals is not specified.

% The file elpi-ltac.elpi provides a few combinators (other than coq.ltac.open)
% in the tradition of LCF tacticals. The main difference is that the arguments
% of custom written tactics must not be passed as predicate arguments but rather
% put in the goal they receive. Indeed these arguments can contain terms, and
% their bound variables cannot escape the seal. coq.ltac.set-goal-arguments
% can be used to put an argument from the current goal context into another
% goal. The coq.ltac.call utility can call Ltac1 code (written in Coq) and
% pass arguments via this mechanism.

% Last, since Elpi is already a logic programming language with primitive
% support for unification variables, most of the work of a tactic can be
% performed without using tacticals (which work on sealed goals) but rather
% in the context of the original goal. The last step is typically to call
% the refine utility with a term synthesized by the tactic or invoke some
% Ltac1 code on that term (e.g. to call vm_compute, see also the example
% on the reflexive tactic).

% ----- Multi goals tactics. ----
% Coq provides goal selectors, such as all:, to pass to a tactic more than one
% goal. In order to write such a tactic, Coq-Elpi provides another entry point
% called msolve. To be precise, if there are two goals under focus, say <g1> and
% <g2>, then all: elpi tac <t> runs the following query
%
%   msolve [<g1>,<g2>] NewGoals ;                         % note the disjunction
%   coq.ltac.all (coq.ltac.open solve) [<g1>,<g2>] NewGoals
%
% So, if msolve has no clause, Coq-Elpi will use solve on all the goals
% independently. If msolve has a clause, then it can manipulate the entire list
% of sealed goals. Note that the argument <t> is in both <g1> and <g2> but
% it is interpreted in both contexts independently. If both goals have a proof
% variable named "x" then passing (@eq_refl _ x) as <t> equips both goals with
% a (raw) proof that "x = x", no matter what their type is.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Declarations for Coq's API (environment read/write access, etc).
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% tt = Yes, ff = No, unspecified = No (unspecified means "_" or a variable).
typeabbrev opaque?   bool.  macro @opaque! :- tt. macro @transparent! :- ff.

%%%%%%% Attributes to be passed to APIs as in @local! => coq.something %%%%%%%%

macro @keep-alg-univs! :- get-option "coq:keepalgunivs" tt.

macro @primitive! :- get-option "coq:primitive" tt. % primitive records
macro @reversible! :- get-option "coq:reversible" tt. % coercions
macro @no-tc! :- get-option "coq:no_tc" tt. % skip typeclass inference 

macro @uinstance! I :- get-option "coq:uinstance" I. % universe instance

% declaration of universe polymorphic constants
% The first list is the one of the universe variables being bound
% The first boolean is tt if this list can be extended by Coq (or it has to
% mention all universes actually used)
% The second list is the one with the constraints amond where universes
% The second boolean is tt if this list can be extended by Coq or it has to
% mention all universe constraints actually required to type check the
% declaration)
macro @udecl! Vs LV Cs LC       :- get-option "coq:udecl" (upoly-decl Vs LV Cs LC).
macro @udecl-cumul! Vs LV Cs LC :- get-option "coq:udecl-cumul" (upoly-decl-cumul Vs LV Cs LC).
macro @univpoly!       :- @udecl! [] tt [] tt.
macro @univpoly-cumul! :- @udecl-cumul! [] tt [] tt.

macro @ppwidth! N :- get-option "coq:ppwidth" N. % printing width
macro @ppall! :- get-option "coq:pp" "all". % printing all
macro @ppmost! :- get-option "coq:pp" "most". % printing most of contents
macro @pplevel! N :- get-option "coq:pplevel" N. % printing precedence (for parentheses)

macro @keepunivs! :- get-option "coq:keepunivs" tt. % skeletons elaboration
macro @dropunivs! :- get-option "coq:keepunivs" ff. % add-indt/add-const

macro @using! S :- get-option "coq:using" S. % like the #[using=S] attribute

macro @inline-at! N :- get-option "coq:inline" (coq.inline.at N). % like Inline(N)
macro @inline! N :- get-option "coq:inline" coq.inline.default. % like

macro @redflags! F :- get-option "coq:redflags" (F : coq.redflags). % for whd & co

% both arguments are strings eg "8.12.0" "use foo instead"
macro @deprecated! Since Msg :-
  get-option "coq:deprecated" (pr Since Msg).

macro @ltacfail! N :- get-option "ltac:fail" N.

% retrocompatibility macro for Coq v8.10
macro @coercion! :- [coercion reversible].


% Attributes for a record field. Can be left unspecified, see defaults
% below.
kind field-attribute type.
external symbol coercion : coercion-status -> field-attribute = "1".  % default off
external symbol canonical : bool -> field-attribute = "1".  % default true, if field is named

% Status of a record field w.r.t. coercions
kind coercion-status type.
external symbol regular : coercion-status = "1". 
external symbol reversible : coercion-status = "1". 
external symbol off : coercion-status = "1". 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% builtins %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This section contains the API to access Coq
% The marker *E* means *experimental*, i.e. use at your own risk, it may change
% substantially or even disappear in future versions.


% -- Misc ---------------------------------------------------------

% [coq.info ...] Prints an info message
external type coq.info variadic any fprop.

% [coq.notice ...] Prints a notice message
external type coq.notice variadic any fprop.

% [coq.say ...] Prints a notice message
external type coq.say variadic any fprop.

% [coq.debug ...] Prints a debug message
external type coq.debug variadic any fprop.

% [coq.warn ...] Prints a generic warning message
external type coq.warn variadic any fprop.

% [coq.warning Category Name ...] 
% Prints a warning message with a Name and Category which can be used
% to silence this warning or turn it into an error. See coqc -w command
% line option
external type coq.warning string -> string -> variadic any fprop.

% [coq.error ...] Prints and *aborts* the program. It is a fatal error for
% Elpi and Ltac
external type coq.error variadic any fprop.

% [coq.version VersionString Major Minor Patch] Fetches the version of Coq,
% as a string and as 3 numbers
external func coq.version -> string, int, int, int.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API for objects belonging to the logic
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -- Environment: names -----------------------------------------------

% To make the API more precise we use different data types for the names
% of global objects.
% Note: [ctype "bla"] is an opaque data type and by convention it is written
% [@bla].

% Global constant name
kind constant type.


% Inductive type name
kind inductive type.


% Inductive constructor name
kind constructor type.


% Global objects: inductive types, inductive constructors, definitions
kind gref type.
external symbol const : constant    -> gref. % Nat.add, List.append, ...
external symbol indt  : inductive   -> gref. % nat, list, ...
external symbol indc  : constructor -> gref. % O, S, nil, cons, ...

% [id] is a name that matters, we piggy back on Elpi's strings.
% Note: [name] is a name that does not matter.
typeabbrev id string.


% Name of a module /*E*/
kind modpath type.


% Name of a module type /*E*/
kind modtypath type.


% Result of coq.locate-all
kind located type.
external symbol loc-gref : gref -> located = "1". 
external symbol loc-modpath : modpath -> located = "1". 
external symbol loc-modtypath : modtypath -> located = "1". 
external symbol loc-abbreviation : abbreviation -> located = "1". 

% [coq.locate-all Name Located] finds all possible meanings of a string.
% Does not fail.
external func coq.locate-all id -> list located.

% [coq.locate Name GlobalReference] locates a global definition, inductive
% type or constructor via its name.
% It unfolds syntactic notations, e.g. "Notation old_name := new_name."
% It understands qualified names, e.g. "Nat.t".
% It understands Coqlib Registered names using the "lib:" prefix,
% eg "lib:core.bool.true".
% It's a fatal error if Name cannot be located.
external func coq.locate id -> gref.

% -- Environment: read ------------------------------------------------

% Note: The type [term] is defined in coq-HOAS.elpi

% [coq.env.typeof GR Ty] reads the type Ty of a global reference.
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
external func coq.env.typeof gref -> term.

% [coq.env.global GR T] turns a global reference GR into a term, or
% viceversa.
% T = (global GR) or, if GR points to a universe polymorphic term,
% T = (pglobal GR I).
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
external func coq.env.global -> gref, term.

external func coq.env.indt % reads the inductive type declaration for the environment.
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
  inductive        % reference to the inductive type
  -> bool,         % tt if the type is inductive (ff for co-inductive)
  int,             % number of parameters
  int,             % number of parameters that are uniform (<= parameters)
  term,            % type of the inductive type constructor including parameters
  list constructor, 
   % list of constructor names
  list term.       % list of the types of the constructors (type of KNames) including parameters
  
external func coq.env.indt-decl % reads the inductive type declaration for the environment.
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
  inductive % reference to the inductive type
  -> indt-decl.
   % HOAS description of the inductive type
  
% [coq.env.indc->indt K I N] finds the inductive I to which constructor K
% belongs and its position N among the other constructors
external func coq.env.indc->indt constructor -> inductive, int.

% [coq.env.indc GR ParamNo UnifParamNo Kno Ty] reads the type Ty of an
% inductive constructor GR, as well as
% the number of parameters ParamNo and uniform parameters
% UnifParamNo and the number of the constructor Kno (0 based).
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
external func coq.env.indc constructor -> int, int, int, term.

% [coq.env.informative? Ind] Checks if Ind is informative, that is, if
% it can be eliminated to build a Type. Inductive types in Type
% are
% informative, as well a singleton types in Prop (which are
% regarded as not non-informative).
external func coq.env.informative? inductive.

% [coq.env.record? Ind PrimProjs] checks if Ind is a record (PrimProjs = tt
% if Ind has primitive projections)
external func coq.env.record? inductive -> bool.

% [coq.env.recursive? Ind] checks if Ind is recursive
external func coq.env.recursive? inductive.

% [coq.env.opaque? GR] checks if GR is an opaque constant
external func coq.env.opaque? constant.

% [coq.env.univpoly? GR PolyArity] checks if GR is universe polymorphic and
% if so returns the number of universe variables
external func coq.env.univpoly? gref -> int.

% [coq.env.const GR Bo Ty] reads the type Ty and the body Bo of constant
% GR.
% Opaque constants have Bo = none.
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
external func coq.env.const constant -> option term, term.

% [coq.env.const-body GR Bo] reads the body of a constant, even if it is
% opaque.
% If such body is none, then the constant is a true axiom.
% Supported attributes:
% - @uinstance! I (default: fresh instance I)
external func coq.env.const-body constant -> option term.

% [coq.env.primitive? GR] tests if GR is a primitive constant (like uin63
% addition) or a primitive type (like uint63)
external func coq.env.primitive? constant.

% [coq.locate-module ModName ModPath] locates a module.  It's a fatal error
% if ModName cannot be located. *E*
external func coq.locate-module id -> modpath.

% [coq.locate-module-type ModName ModPath] locates a module.  It's a fatal
% error if ModName cannot be located. *E*
external func coq.locate-module-type id -> modtypath.

% Contents of a module
kind module-item type.
external symbol submodule : modpath -> list module-item -> module-item = "1". 
external symbol module-type : modtypath -> module-item = "1". 
external symbol gref : gref -> module-item = "1". 
external symbol module-functor : modpath -> list modtypath -> module-item = "1". 
external symbol module-type-functor : modtypath -> list modtypath ->
                                      module-item = "1". 

% [coq.env.module MP Contents] lists the contents of a module (recurses on
% submodules) *E*
external func coq.env.module modpath -> list module-item.

% [coq.env.module-type MTP Entries] lists the items made visible by module
% type (does not recurse on submodules) *E*
external func coq.env.module-type modtypath -> list id.

% [coq.env.section GlobalObjects] lists the global objects that are marked
% as to be abstracted at the end of the enclosing sections
external func coq.env.section -> list constant.

% [coq.env.dependencies GR MP Deps] Computes the direct dependencies of GR.
% If MP is given, Deps only contains grefs from that module
external func coq.env.dependencies gref, modpath -> coq.gref.set.

% [coq.env.transitive-dependencies GR MP Deps] Computes the transitive
% dependencies of GR. If MP is given, Deps only contains grefs from that
% module
external func coq.env.transitive-dependencies gref, 
                                             modpath -> coq.gref.set.

% [coq.env.term-dependencies T S] Computes all the grefs S occurring in the
% term T
external func coq.env.term-dependencies term -> coq.gref.set.

% [coq.env.current-path Path] lists the current module path
external func coq.env.current-path -> list string.

% [coq.env.current-section-path Path] lists the current section path
external func coq.env.current-section-path -> list string.

% Deprecated, use coq.env.opaque?
  pred coq.env.const-opaque? i:constant.
  coq.env.const-opaque? C :-
    coq.warning "elpi.deprecated" "elpi.const-opaque" "use coq.env.opaque? in place of coq.env.const-opaque?",
    coq.env.opaque? C.
  

% Deprecated, use coq.env.primitive?
  pred coq.env.const-primitive? i:constant.
  coq.env.const-primitive? C :-
    coq.warning "elpi.deprecated" "elpi.const-primitive" "use coq.env.primitive? in place of coq.env.const-primitive?",
    coq.env.primitive? C.
  

% -- Environment: write -----------------------------------------------

% Note: (monomorphic) universe constraints are taken from ELPI's
% constraints store. Use coq.univ-* in order to add constraints (or any
% higher level facility as coq.typecheck). Load in the context attributes
% such as @univpoly!, @univpoly-cumul!, @udecl! or @udecl-cumul! in order to
% declare universe polymorphic constants or inductives.

% [coq.env.add-const Name Bo Ty Opaque C] Declare a new constant: C gets a
% constant derived from Name
% and the current module; Ty can be left unspecified and in that case
% the
% inferred one is taken (as in writing Definition x := t); Bo can be
% left
% unspecified and in that case an axiom is added (or a section variable,
% if a section is open and @local! is used). Omitting the body and the type
% is
% an error. Note: using this API for declaring an axiom or a section
% variable is
% deprecated, use coq.env.add-axiom or coq.env.add-section-variable
% instead.
% Supported attributes:
% - @local! (default: false)
% - @using! (default: section variables actually used)
% - @univpoly! (default unset)
% - @udecl! (default unset)
% - @dropunivs! (default: false, drops all universe constraints from the
% store after the definition)
% 
external func coq.env.add-const id, term, term, opaque? -> constant.

% [coq.env.add-axiom Name Ty C] Declare a new axiom: C gets a constant
% derived from Name
% and the current module.
% Supported attributes:
% - @local! (default: false)
% - @univpoly! (default unset)
% - @using! (default: section variables actually used)
% - @inline! (default: no inlining)
% - @inline-at! N (default: no inlining)
external func coq.env.add-axiom id, term -> constant.

% [coq.env.add-section-variable Name I Ty C] Declare a new section variable:
% C gets a constant derived from Name
% and the current module.
% 
external func coq.env.add-section-variable id, implicit_kind, 
                                          term -> constant.


pred coq.env.add-context i:context-decl.
coq.env.add-context context-end.
coq.env.add-context (context-item Name I Ty none Rest) :-
  coq.env.add-section-variable Name I Ty C,
  coq.env.add-context (Rest {coq.env.global (const C)}).
coq.env.add-context (context-item Name _I Ty (some Bo) Rest) :-
  coq.env.add-const Name Bo Ty ff C,
  coq.env.add-context (Rest {coq.env.global (const C)}).


% [coq.env.add-indt Decl I] Declares an inductive type.
% Supported attributes:
% - @dropunivs! (default: false, drops all universe constraints from the
% store after the definition)
% - @primitive! (default: false, makes records primitive)
external func coq.env.add-indt indt-decl -> inductive.

% Interactive module construction

% Coq Module inline directive
kind coq.inline type.
external symbol coq.inline.no : coq.inline = "1".  % Coq's [no inline] (aka !)
external symbol coq.inline.default : coq.inline = "1".  % The default, can be omitted
external symbol coq.inline.at : int -> coq.inline = "1".  % Coq's [inline at <num>]

% [coq.env.fresh-global-id ID FID] Generates an id FID which is fresh in
% the current module and looks similar to ID, i.e. it is ID concatenated
% with a number, starting from 1.
% [coq.env.fresh-global-id X X] can be used to check if X is taken
external func coq.env.fresh-global-id id -> id.

external func coq.env.begin-module-functor % Starts a functor. bla bla
  id,                        % The name of the functor
  option modtypath,          % Its module type (optional)
  list (pair id modtypath).  % Parameters of the functor (optional)
  

func coq.env.begin-module id, option modtypath -> .
coq.env.begin-module Name MP :- coq.env.begin-module-functor Name MP [].


% [coq.env.end-module ModPath] end the current module that becomes known as
% ModPath *E*. bla bla
external func coq.env.end-module -> modpath.

external func coq.env.begin-module-type-functor % Starts a module type functor *E*. bla bla
  id,                        % The name of the functor
  list (pair id modtypath).  % The parameters of the functor (optional)
  

func coq.env.begin-module-type id ->.
coq.env.begin-module-type Name :-
  coq.env.begin-module-type-functor Name [].


% [coq.env.end-module-type ModTyPath] end the current module type that
% becomes known as ModPath *E*. bla bla
external func coq.env.end-module-type -> modtypath.

external func coq.env.apply-module-functor % Applies a functor *E*. bla bla
  id,                % The name of the new module
  option modtypath,  % Its module type (optional)
  modpath,           % The functor being applied (optional)
  list modpath,      % Its arguments (optional)
  coq.inline         % Arguments inlining (optional)
  -> modpath.        % The modpath of the new module
  
external func coq.env.apply-module-type-functor % Applies a type functor *E*. bla bla
  id,            % The name of the new module type
  modtypath,     % The functor (optional)
  list modpath,  % Its arguments (optional)
  coq.inline     % Arguments inlining (optional)
  -> modtypath.  % The modtypath of the new module type
  
% [coq.env.include-module ModPath Inline (optional)] is like the vernacular
% Include, Inline can be omitted *E*. bla bla
external func coq.env.include-module modpath, coq.inline.

% [coq.env.include-module-type ModTyPath Inline (optional)] is like the
% vernacular Include Type, Inline can be omitted  *E*. bla bla
external func coq.env.include-module-type modtypath, coq.inline.

% [coq.env.import-module ModPath] is like the vernacular Import *E*
external func coq.env.import-module modpath.

% [coq.env.export-module ModPath] is like the vernacular Export *E*
external func coq.env.export-module modpath.

% Support for sections is limited, in particular sections and
% Coq quotations may interact in surprising ways. For example
%   Section Test.
%   Variable x : nat.
%   Elpi Query lp:{{ coq.say {{ x }} }}.
% works since x is a global Coq term while
%   Elpi Query lp:{{
%     coq.env.begin-section "Test",
%     coq.env.add-const "x" _ {{ nat }} _ @local! GRX,
%     coq.say {{ x }}
%   }}.
% may work in a surprising way or may not work at all since
% x is resolved before the section is started hence it cannot
% denote the same x as before.

% [coq.env.begin-section Name] starts a section named Name *E*
external func coq.env.begin-section id.

% [coq.env.end-section] end the current section *E*
external func coq.env.end-section.

% [coq.env.projections StructureName Projections] given a record
% StructureName lists all projections
external func coq.env.projections inductive -> list (option constant).

% [coq.env.projection? Constant Number of parameters] if the constant is a
% projection, returns the number of parameters of its record.
external func coq.env.projection? constant -> int.

% [coq.env.primitive-projections StructureName Projections] given a record
% StructureName lists all primitive projections
external func coq.env.primitive-projections inductive -> list (option (pair projection int)).

% [coq.env.primitive-projection? Projection Compatibility constant Index]
% Relates a primitive projection to its compatibility constant. Index is set
% to the constructor argument extracted by the projection (starting from 0).
external func coq.env.primitive-projection? -> projection, constant, int.

% -- Sorts (and their universe level, if applicable) ----------------

% Warning: universe polymorphism has to be considered experimental *E* as
% a feature, not just as a set of APIs. Unfortunately some of the
% current complexity is exposed to the programmer, bare with us.
% 
% The big bang is that in Coq one has terms, types and sorts (which are
% the types of types). Some sorts (as of today only Type) some with
% a universe level, on paper Type_i for some i. At the sort level
% Coq features some form of subtyping: a function expecting a function
% to Type, e.g. nat -> Type, can receive a function to Prop, since
% Prop <= Type. So far, so good. But what are these levels i
% exactly?
% 
% Universe levels are said to be "algebraic", they are made of
% variables (see the next section) and the two operators +1 and max.
% This is a sort of internal optimization that leaks to the
% user/programmer. Indeed these universe levels cannot be (directly) used
% in all APIs morally expecting a universe level "i", in particular
% the current constraint engine cannot handle constraint with an
% algebraic level on the right, e.g. i <= j+1. Since some APIs only
% accept universe variables, we provide the coq.univ.variable API
% which is able to craft a universe variable which is roughly
% equivalent to an algebraic universe, e.g. k such that j+1 = k.
% 
% Rocq-Elpi systematically purges algebraic universes from terms (and
% types and sorts) when one reads them from the environment. This
% makes the embedding of terms less precise than what it could be.
% The different data types stay, since Coq will eventually become
% able to handle algebraic universes consistently, making this purging
% phase unnecessary.

% universe level (algebraic: max, +1, univ.variable)
kind univ type.


% Sorts (kinds of types)
kind sort type.
external symbol prop : sort = "1".  % impredicative sort of propositions
external symbol sprop : sort = "1".  % impredicative sort of propositions with definitional proof irrelevance
external symbol typ : univ -> sort = "1".  % predicative sort of data (carries a universe level)

% [coq.sort.leq S1 S2] constrains S1 <= S2
external func coq.sort.leq -> sort, sort.

% [coq.sort.eq S1 S2] constrains S1 = S2
external func coq.sort.eq -> sort, sort.

% [coq.sort.sup S1 S2] constrains S2 = S1 + 1
external func coq.sort.sup -> sort, sort.

% [coq.sort.pts-triple S1 S2 S3] constrains S3 = sort of product with domain
% in S1 and codomain in S2
external func coq.sort.pts-triple -> sort, sort, sort.

% [coq.univ.print] prints the set of universe constraints
external func coq.univ.print.

% [coq.univ.new U] A fresh universe.
external func coq.univ.new -> univ.

% [coq.univ.alg-super U V] relates a univ U to its algebraic successor V,
% that is U+1 and not any V s.t. U < V
external pred coq.univ.alg-super i:univ, o:univ.

% [coq.univ.alg-max U1 U2 UMax] relates univs U1 and U2 to their algebraic
% maximum UMax, that is max(U1, U2)
external pred coq.univ.alg-max i:univ, i:univ, o:univ.

% [coq.univ Name U] Finds a named unvierse. Can fail.
external func coq.univ -> id, univ.

% [coq.univ.global? U] succeeds if U is a global universe
external func coq.univ.global? univ.

% [coq.univ.constraints CL] gives the list of constraints, see also
% coq.univ.variable.constraints
external func coq.univ.constraints -> list univ-constraint.

% -- Universe variables ------

% universe level variable
kind univ.variable type.


% [coq.univ.variable U L] relates a univ.variable L to a univ U
external func coq.univ.variable -> univ, univ.variable.

% [coq.univ.variable.constraints L CL] gives the list of constraints on L.
% Can be used to craft a strict upoly-decl
external func coq.univ.variable.constraints univ.variable -> list univ-constraint.

% [coq.univ.variable.of-term T S] collects all univ.variables occurring in T
external func coq.univ.variable.of-term term -> coq.univ.variable.set.

% -- Universe instance (for universe polymorphic global terms) ------

% As of today a universe polymorphic constant can only be instantiated
% with universe level variables. That is f@{Prop} is not valid, nor
% is f@{u+1}. One can only write f@{u} for any u.
% 
% A univ-instance is morally a list of universe level variables,
% but its list syntax is hidden in the terms. If you really need to
% craft or inspect one of these, the following APIs can help you.
% 
% Most of the time the user is expected to use coq.env.global which
% crafts a fresh, appropriate, universe instance and possibly unify that
% term (of the instance it contains) with another one.

% Universes level instance for a universe-polymorphic constant
kind univ-instance type.


% [coq.univ-instance UI UL] relates a univ-instance UI and a list of
% universe level variables UL
external func coq.univ-instance -> univ-instance, list univ.variable.

% [coq.univ-instance.unify-eq GR UI1 UI2 Diagnostic] unifies the two
% universe instances for the same gref
external func coq.univ-instance.unify-eq gref, univ-instance, 
                                        univ-instance -> diagnostic.

% [coq.univ-instance.unify-leq GR UI1 UI2 Diagnostic] unifies the two
% universe instances for the same gref. Note: if the GR is not *cumulative*
% (see Cumulative or #[universes(cumulative)]) then this API imposes an
% equality constraint.
external func coq.univ-instance.unify-leq gref, univ-instance, 
                                         univ-instance -> diagnostic.

% -- Declaration of universe polymorphic global terms -----------

% These are the data types used to declare how constants
% and inductive types should be declared (see also the @udecl!
% and
% @udecl-cumul! macros). Note that only inductive types can be
% declared as cumulative.

% Constraint between two universes level variables
kind univ-constraint type.
external symbol lt : univ.variable -> univ.variable -> univ-constraint = "2". 
external symbol le : univ.variable -> univ.variable -> univ-constraint = "1". 
external symbol eq : univ.variable -> univ.variable -> univ-constraint = "2". 

% Variance of a universe level variable
kind univ-variance type.
external symbol auto : univ.variable -> univ-variance = "1". 
external symbol covariant : univ.variable -> univ-variance = "1". 
external symbol invariant : univ.variable -> univ-variance = "1". 
external symbol irrelevant : univ.variable -> univ-variance = "1". 

% Constraints for a non-cumulative declaration. Boolean tt means loose
% (e.g. the '+' in f@{u v + | u < v +})
kind upoly-decl type.
external symbol upoly-decl : list univ.variable -> bool ->
                             list univ-constraint -> bool -> upoly-decl = "1". 
external symbol upoly-decl-cumul : list univ-variance -> bool ->
                                   list univ-constraint -> bool ->
                                   upoly-decl = "1". 

% -- Primitive --------------------------------------------------------

kind uint63 type.


kind float64 type.


kind pstring type.


kind projection type.


% Primitive values
kind primitive-value type.
external symbol uint63 : uint63 -> primitive-value = "1".  % unsigned integers over 63 bits
external symbol float64 : float64 -> primitive-value = "1".  % double precision foalting points
external symbol pstring : pstring -> primitive-value = "1".  % primitive string
external symbol proj : projection -> int -> primitive-value = "1".  % primitive projection

% [coq.uint63->int U I] Transforms a primitive unsigned integer U into an
% elpi integer I. Fails if it does not fit.
external func coq.uint63->int uint63 -> int.

% [coq.int->uint63 I U] Transforms an elpi integer I into a primitive
% unsigned integer U. Fails if I is negative.
external func coq.int->uint63 int -> uint63.

% [coq.float64->float F64 F] Transforms a primitive float on 64 bits to an
% elpi one. Currently, it should not fail.
external func coq.float64->float float64 -> float.

% [coq.float->float64 F F64] Transforms an elpi float F to a primitive float
% on 64 bits. Currently, it should not fail.
external func coq.float->float64 float -> float64.

% [coq.primitive.projection-unfolded P PU] Relates a primitive projection P
% to its unfolded version PU. PU is still a primitive projection, but it is
% displayed as a match and some Ltac code can see that.
external func coq.primitive.projection-unfolded -> projection, projection.

% [coq.pstring->string PS S] Transforms a Coq primitive string to an elpi
% string. It does not fail.
external func coq.pstring->string pstring -> string.

% [coq.string->pstring S PS] Transforms an elpi string into a Coq primitive
% string. It fails if the lenght of S is greater than the maximal primitive
% string length.
external func coq.string->pstring string -> pstring.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API for extra logical objects
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -- Databases (TC, CS, Coercions) ------------------------------------

% Pattern for canonical values
kind cs-pattern type.
external symbol cs-gref : gref -> cs-pattern = "1". 
external symbol cs-prod : cs-pattern = "1". 
external symbol cs-default : cs-pattern = "1". 
external symbol cs-sort : sort -> cs-pattern = "1". 

% Canonical Structure instances: (cs-instance Proj ValPat Inst)
kind cs-instance type.
external symbol cs-instance : gref -> cs-pattern -> gref -> cs-instance = "1". 

% [coq.CS.declare-instance GR] Declares GR as a canonical structure
% instance.
% Supported attributes:
% - @local! (default: false)
external func coq.CS.declare-instance gref.

% [coq.CS.db Db] reads all instances
external func coq.CS.db -> list cs-instance.

% [coq.CS.db-for Proj Value Db] reads all instances for a given Projection
% or canonical Value, or both
external func coq.CS.db-for gref, cs-pattern -> list cs-instance.

% [coq.CS.canonical-projection? Projection] Tells if the projection can be
% used for CS inference.
external func coq.CS.canonical-projection? constant.

% [coq.CS.canonical-projection? Projection] Tells if the projection can be
% used for CS inference.
external pred coq.CS.canonical-projection? i:constant.

% [coq.TC.declare-class GR] Declare GR as a type class
external func coq.TC.declare-class gref.

% [coq.elpi.toposort Graph Nodes in toposort order] takes a graph and
% returns the nodes in topological order
external func coq.elpi.toposort list (pair A (list A)) -> list A.

% Type class instance with priority
kind tc-instance type.
external symbol tc-instance : gref -> int -> tc-instance = "1". 

% [coq.TC.declare-instance GR Priority] Declare GR as a Global type class
% instance with Priority.
% Supported attributes:
% - @global! (default: true)
external func coq.TC.declare-instance gref, int.

% [coq.TC.db Instances] reads all type class instances
external func coq.TC.db -> list tc-instance.

% [coq.TC.db-tc TypeClasses] reads all type classes
external func coq.TC.db-tc -> list gref.

% [coq.TC.db-for GR InstanceList] reads all instances of the given class GR.
% Instances are in their precedence order.
external func coq.TC.db-for gref -> list tc-instance.

% [coq.TC.get-inst-prio ClassGR InstGR InstPrio] reads the priority of an
% instance
external func coq.TC.get-inst-prio gref, gref -> int.

% [coq.TC.class? GR] checks if GR is a class
external func coq.TC.class? gref.

% Node of the coercion graph
kind class type.
external symbol funclass : class = "1". 
external symbol sortclass : class = "1". 
external symbol grefclass : gref -> class = "1". 

% Edge of the coercion graph
kind coercion type.
external symbol coercion : gref -> int -> gref -> class -> coercion = "2".  % ref, nparams, src, tgt

% [coq.coercion.declare C] Declares C = (coercion GR NParams From To) as a
% coercion From >-> To.
% NParams can always be omitted, since it is inferred.
% If From or To is unspecified, then the endpoints are inferred.
% Supported attributes:
% - @global! (default: false)
% - @nonuniform! (default: false)
% - @reversible! (default: false)
external func coq.coercion.declare coercion.

% [coq.coercion.db L] reads all declared coercions
external func coq.coercion.db -> list coercion.

% [coq.coercion.db-for From To L] L is a path From -> To
external func coq.coercion.db-for class, class -> list (pair gref int).

% Deprecated, use coq.env.projections
pred coq.CS.canonical-projections i:inductive, o:list (option constant).
coq.CS.canonical-projections I L :-
  coq.warning "elpi.deprecated" "elpi.canonical-projections" "use coq.env.projections in place of coq.CS.canonical-projections",
  coq.env.projections I L.


% -- Coq's Hint DB -------------------------------------

% Locality of hints is a delicate matter since the Coq default
% is, in some cases, to make an hint active even if the module it belongs
% to is not imported (just merely required, which can happen
% transitively).
% Coq is aiming at changing the default to #[export], that makes an
% hint active only when its enclosing module is imported.
% See:
% https://coq.discourse.group/t/change-of-default-locality-for-hint-commands-in-coq-8-13/1140
% 
% This old behavior is available via the @global! flag, but is discouraged.
% 

% Hint Mode
kind hint-mode type.
external symbol mode-ground : hint-mode = "1".  % No Evar
external symbol mode-input : hint-mode = "1".  % No Head Evar
external symbol mode-output : hint-mode = "1".  % Anything

% [coq.hints.add-mode GR DB Mode] Adds a mode declaration to DB about
% GR.
% Supported attributes:
% - @local! (default is export)
% - @global! (discouraged, may become deprecated)
external func coq.hints.add-mode gref, string, list hint-mode.

% [coq.hints.modes GR DB Modes] Gets all the mode declarations in DB about
% GR
external func coq.hints.modes gref, string -> list (list hint-mode).

% [coq.hints.set-opaque C DB Opaque] Like Hint Opaque C : DB (or Hint
% Transparent, if the boolean is ff).
% Supported attributes:
% - @local! (default is export)
% - @global! (discouraged, may become deprecated)
external func coq.hints.set-opaque constant, string, bool.

% [coq.hints.opaque C DB Opaque] Reads if constant C is opaque (tt) or
% transparent (ff) in DB
external func coq.hints.opaque constant, string -> bool.

% [coq.hints.add-resolve GR DB Priority Pattern] Like Hint Resolve GR |
% Priority Pattern : DB.
% Supported attributes:
% - @local! (default is export)
% - @global! (discouraged, may become deprecated)
external func coq.hints.add-resolve gref, string, int, term.

% -- Coq's notational mechanisms -------------------------------------

% Implicit status of an argument
kind implicit_kind type.
external symbol implicit : implicit_kind = "1".  % regular implicit argument, eg Arguments foo [x]
external symbol maximal : implicit_kind = "1".  % maximally inserted implicit argument, eg Arguments foo {x}
external symbol explicit : implicit_kind = "1".  % explicit argument, eg Arguments foo x

% [coq.arguments.implicit GR Imps] reads the implicit arguments declarations
% associated to a global reference. See also the [] and {} flags for the
% Arguments command.
external func coq.arguments.implicit gref -> list (list implicit_kind).

% [coq.arguments.set-implicit GR Imps] sets the implicit arguments
% declarations associated to a global reference.
% Unspecified means explicit.
% See also the [] and {} flags for the Arguments command.
% Supported attributes:
% - @global! (default: false)
external func coq.arguments.set-implicit gref, list (list implicit_kind).

% [coq.arguments.set-default-implicit GR] sets the default implicit
% arguments declarations associated to a global reference.
% See also the "default implicits" flag to the Arguments command.
% Supported attributes:
% - @global! (default: false)
external func coq.arguments.set-default-implicit gref.

% [coq.arguments.name GR Names] reads the Names of the arguments of a global
% reference. See also the (f (A := v)) syntax.
external func coq.arguments.name gref -> list (option id).

% [coq.arguments.set-name GR Names] sets the Names of the arguments of a
% global reference.
% See also the :rename flag to the Arguments command.
% Supported attributes:
% - @global! (default: false)
external func coq.arguments.set-name gref, list (option id).

% [coq.arguments.scope GR Scopes] reads the notation scope of the arguments
% of a global reference. See also the %scope modifier for the Arguments
% command
external func coq.arguments.scope gref -> list (list id).

% [coq.arguments.set-scope GR Scopes] sets the notation scope of the
% arguments of a global reference.
% Scope can be a scope name or its delimiter.
% See also the %scope modifier for the Arguments command.
% Supported attributes:
% - @global! (default: false)
external func coq.arguments.set-scope gref, list (list id).

% Strategy for simplification tactics
kind simplification_strategy type.
external symbol never : simplification_strategy = "1".  % Arguments foo : simpl never
external symbol when : list int -> option int -> simplification_strategy = "1".  % Arguments foo .. / .. ! ..
external symbol when-nomatch : list int -> option int ->
                               simplification_strategy = "1".  % Arguments foo .. / .. ! .. : simpl nomatch

% [coq.arguments.simplification GR Strategy] reads the behavior of the
% simplification tactics. Positions are 0 based. See also the ! and /
% modifiers for the Arguments command
external func coq.arguments.simplification gref -> option simplification_strategy.

% [coq.arguments.set-simplification GR Strategy] sets the behavior of the
% simplification tactics.
% Positions are 0 based.
% See also the ! and / modifiers for the Arguments command.
% Supported attributes:
% - @global! (default: false)
external func coq.arguments.set-simplification gref, 
                                              simplification_strategy.

% [coq.locate-abbreviation Name Abbreviation] locates an abbreviation.  It's
% a fatal error if Name cannot be located.
external func coq.locate-abbreviation id -> abbreviation.

% Name of an abbreviation
kind abbreviation type.


% [coq.notation.add-abbreviation Name Nargs Body OnlyParsing Abbreviation]
% Declares an abbreviation Name with Nargs arguments.
% The term must begin with at least Nargs "fun" nodes whose domain is
% ignored, eg (fun _ _ x\ fun _ _ y\ app[global "add",x,y]).
% Supported attributes:
% - @deprecated! (default: not deprecated)
% - @warn! (default: no warning)
% - @global! (default: false)
external func coq.notation.add-abbreviation id, int, term, 
                                           bool -> abbreviation.

% [coq.notation.abbreviation Abbreviation Args Body] Unfolds an abbreviation
external func coq.notation.abbreviation abbreviation, list term -> term.

% [coq.notation.abbreviation-body Abbreviation Nargs Body] Retrieves the
% body of an abbreviation
external func coq.notation.abbreviation-body abbreviation -> int, term.

% [coq.notation.add-abbreviation-for-tactic Name TacticName FixedArgs]
% Declares a parsing rule similar to
%   Notation Name X1..Xn := ltac:(elpi TacticName FixedArgs (X1)..(Xn))
% so that Name can be used in the middle of a term to invoke an
% elpi tactic. While FixedArgs can contain str, int, and trm all
% other arguments will necessarily be terms, and their number is
% not fixed (the user can pass as many as he likes).
% The tactic receives as the elpi.loc attribute the precise location
% at which the term is written (unlike if a regular abbreviation was
% declared by hand).
% A call to coq.notation.add-abbreviation-for-tactic TacName TacName []
% is equivalent to Elpi Export TacName.
external func coq.notation.add-abbreviation-for-tactic string, string, 
                                                      list argument.

% Generic attribute value
kind attribute-value type.
external symbol leaf-str : string -> attribute-value = "1". 
external symbol leaf-loc : loc -> attribute-value = "1". 
external symbol node : list attribute -> attribute-value = "1". 

% Generic attribute
kind attribute type.
external symbol attribute : string -> attribute-value -> attribute = "1". 

% -- Coq's pretyper ---------------------------------------------------

% [coq.sigma.print] Prints Coq's Evarmap and the mapping to/from Elpi's
% unification variables
external func coq.sigma.print.

% [coq.typecheck T Ty Diagnostic] typchecks a term T returning its type Ty.
% If Ty is provided, then
% the inferred type is unified (see unify-leq) with it.
% Universe constraints are put in the constraint store.
external func coq.typecheck term -> term, diagnostic.

% [coq.typecheck-ty Ty U Diagnostic] typchecks a type Ty returning its
% universe U. If U is provided, then
% the inferred universe is unified (see unify-leq) with it.
% Universe constraints are put in the constraint store.
external func coq.typecheck-ty term -> sort, diagnostic.

% [coq.unify-eq A B Diagnostic] unifies the two terms
external func coq.unify-eq term, term -> diagnostic.

% [coq.unify-leq A B Diagnostic] unifies the two terms (with cumulativity,
% if they are types)
external func coq.unify-leq term, term -> diagnostic.

% [coq.elaborate-skeleton T ETy E Diagnostic] elabotares T against the
% expected type ETy.
% T is allowed to contain holes (unification variables) but these are
% not assigned even if the elaborated term has a term in place of the
% hole. Similarly universe levels present in T are disregarded.
% Supported attributes:
% - @keepunivs! (default false, do not disregard universe levels)
% - @no-tc! (default false, do not infer typeclasses) 
external func coq.elaborate-skeleton term -> term, term, diagnostic.

% [coq.elaborate-ty-skeleton T U E Diagnostic] elabotares T expecting it to
% be a type of sort U.
% T is allowed to contain holes (unification variables) but these are
% not assigned even if the elaborated term has a term in place of the
% hole. Similarly universe levels present in T are disregarded.
% Supported attributes:
% - @keepunivs! (default false, do not disregard universe levels)
% - @no-tc! (default false, do not infer typeclasses)
external func coq.elaborate-ty-skeleton term -> sort, term, diagnostic.

% -- Coq's reduction flags    ------------------------------------

% Flags for lazy, cbv, ... reductions
kind coq.redflag type.
external symbol coq.redflags.beta : coq.redflag = "2". 
external symbol coq.redflags.delta : coq.redflag = "2".  % if set then coq.redflags.const disables unfolding
external symbol coq.redflags.match : coq.redflag = "1". 
external symbol coq.redflags.fix : coq.redflag = "1". 
external symbol coq.redflags.cofix : coq.redflag = "1". 
external symbol coq.redflags.zeta : coq.redflag = "2". 
external symbol coq.redflags.const : constant -> coq.redflag = "1".  % enable/disable unfolding

% Set of flags for lazy, cbv, ... reductions
kind coq.redflags type.

external symbol coq.redflags.nored : coq.redflags = "1".
external symbol coq.redflags.zeta : coq.redflags = "1".
external symbol coq.redflags.delta : coq.redflags = "1".
external symbol coq.redflags.betazeta : coq.redflags = "1".
external symbol coq.redflags.betaiotazeta : coq.redflags = "1".
external symbol coq.redflags.betaiota : coq.redflags = "1".
external symbol coq.redflags.betadeltazeta : coq.redflags = "1".
external symbol coq.redflags.beta : coq.redflags = "1".
external symbol coq.redflags.allnolet : coq.redflags = "1".
external symbol coq.redflags.all : coq.redflags = "1".

% [coq.redflags.add Flags Options NewFlags] Updates reduction Flags by
% adding Options
external func coq.redflags.add coq.redflags, 
                              list coq.redflag -> coq.redflags.

% [coq.redflags.sub Flags Options NewFlags] Updates reduction Flags by
% removing Options
external func coq.redflags.sub coq.redflags, 
                              list coq.redflag -> coq.redflags.

% -- Coq's reduction machines ------------------------------------

% [coq.reduction.lazy.whd T Tred] Puts T in weak head normal form.
% Supported attributes:
% - @redflags! (default coq.redflags.all)
external func coq.reduction.lazy.whd term -> term.

% [coq.reduction.lazy.norm T Tred] Puts T in normal form.
% Supported attributes:
% - @redflags! (default coq.redflags.all)
external func coq.reduction.lazy.norm term -> term.

% [coq.reduction.lazy.bi-norm T Tred] Puts T in normal form only reducing
% beta and iota redexes
external func coq.reduction.lazy.bi-norm term -> term.

% [coq.reduction.cbv.norm T Tred] Puts T in normal form using the call by
% value strategy.
% Supported attributes:
% - @redflags! (default coq.redflags.all)
external func coq.reduction.cbv.norm term -> term.

% [coq.reduction.vm.norm T Ty Tred] Puts T in normal form using
% [vm_compute]'s machinery. Its type Ty can be omitted (but is recomputed)
external func coq.reduction.vm.norm term, term -> term.

% [coq.reduction.native.norm T Ty Tred] Puts T in normal form using
% [native_compute]'s machinery. Its type Ty can be omitted (but is
% recomputed). Falls back to vm.norm if native compilation is not available.
external func coq.reduction.native.norm term, term -> term.

% [coq.reduction.native.available?] Is native compilation available on this
% system/configuration?
external func coq.reduction.native.available?.

% Deprecated, use coq.reduction.cbv.norm
pred coq.reduction.cbv.whd_all i:term, o:term.
coq.reduction.cbv.whd_all T R :-
  coq.warning "elpi.deprecated" "elpi.cbv-whd-all" "use coq.reduction.cbv.norm in place of coq.reduction.cbv.whd_all",
  coq.reduction.cbv.norm T R.


% Deprecated, use coq.reduction.vm.norm
pred coq.reduction.vm.whd_all i:term, i:term, o:term.
coq.reduction.vm.whd_all T TY R :-
  coq.warning "elpi.deprecated" "elpi.vm-whd-all" "use coq.reduction.vm.norm in place of coq.reduction.vm.whd_all",
  coq.reduction.vm.norm T TY R.



func coq.reduction.lazy.whd_all term -> term.
coq.reduction.lazy.whd_all X Y :-
  @redflags! coq.redflags.all => coq.reduction.lazy.whd X Y.


% [coq.reduction.eta-contract T Tred] Removes all eta expansions from T
external func coq.reduction.eta-contract term -> term.

% -- Coq's conversion strategy tweaks --------------------------

% Strategy for conversion test
% expand < ... < level -1 < level 0 < level 1 < ... < opaque
kind conversion_strategy type.
external symbol opaque : conversion_strategy = "1". 
external symbol expand : conversion_strategy = "1". 
external symbol level : int -> conversion_strategy = "1".  % default is 0, aka transparent

% [coq.strategy.set CL Level] Sets the unfolding priority for all the
% constants in the list CL. See the command Strategy.
external func coq.strategy.set list constant, conversion_strategy.

% [coq.strategy.get C Level] Gets the unfolding priority for C
external func coq.strategy.get constant -> conversion_strategy.

% -- Coq's tactics --------------------------------------------

% LTac1 tactic expression
kind ltac1-tactic type.


% [coq.ltac.fail Level ...] Interrupts the Elpi program and calls Ltac's
% fail Level Msg, where Msg is the printing of the remaining arguments.
% Level can be left unspecified and defaults to 0
external type coq.ltac.fail int -> variadic any fprop.

% [coq.ltac.collect-goals T Goals ShelvedGoals] 
% Turns the holes in T into Goals.
% Goals are closed with nablas.
% ShelvedGoals are goals which can be solved by side effect (they occur
% in the type of the other goals).
% The order of Goals is given by the traversal order of EConstr.fold
% (a
% fold_left over the terms, letin body comes before the type).
% 
external func coq.ltac.collect-goals term -> list sealed-goal, 
                                    list sealed-goal.

% [coq.ltac.call-ltac1 Tac G GL] Calls Ltac1 tactic Tac on goal G (passing
% the arguments of G, see coq.ltac.call for a handy wrapper).
% Tac can either be a string (the tactic name), or a value
% of type ltac1-tactic, see the tac argument constructor
% and the ltac_tactic:(...) syntax to pass arguments to
% an elpi tactic.
% Caveat:
%   if Tac is a tactic name, then the tactic must be defined using
%   "Ltac name := body", it cannot be a builtin one. For example
%   "Ltac myapply x := apply x." lets one call apply by running
%   coq.ltac.call-ltac1 "myapply" G GL.
% Supported attributes:
% - @no-tc! (default false, do not infer typeclasses)
external func coq.ltac.call-ltac1 any, goal -> list sealed-goal.

% [coq.ltac.id-free? ID G] 
%     Fails if ID is already used in G. Note that ids which are taken are
% renamed
%     on the fly (since in the HOAS of terms, names are just pretty printing
%     hints), but for the ergonomy of a tactic it may help to know if an
%     hypothesis name is already taken.
% 
external func coq.ltac.id-free? id, goal.

% [coq.ltac.fresh-id Default Ty FreshID] TODO
external func coq.ltac.fresh-id id, term -> id.

% -- Coq's options system --------------------------------------------

% Coq option value
kind coq.option type.
external symbol coq.option.int : option int -> coq.option = "1".  % none means unset
external symbol coq.option.string : option string -> coq.option = "1".  % none means unset
external symbol coq.option.bool : bool -> coq.option = "1". 

% [coq.option.get Option Value] reads Option. Reading a non existing option
% is a fatal error.
external func coq.option.get list string -> coq.option.

% [coq.option.set Option Value] writes Option. Writing a non existing option
% is a fatal error.
external func coq.option.set list string, coq.option.

% [coq.option.available? Option Deprecated] checks if Option exists and
% tells if is deprecated (tt) or not (ff)
external func coq.option.available? list string -> bool.

% [coq.option.add Option Value Deprecated] 
% adds a new option to Coq setting its current value (and type).
% Deprecated can be left unspecified and defaults to ff.
% This call cannot be undone in a Coq interactive session, use it once
% and for all in a .v file which your clients will load. Eg.
% 
%   Elpi Query lp:{{ coq.option.add ... }}.
%   
% 
external func coq.option.add list string, coq.option, bool.

% -- Datatypes conversions --------------------------------------------

% Name.Name.t: Name hints (in binders), can be input writing a name
% between backticks, e.g. `x` or `_` for anonymous. Important: these are
% just printing hints with no meaning, hence in elpi two name are always
% related: `x` = `y`
kind name type.


% [coq.name-suffix Name Suffix NameSuffix] suffixes a Name with a string or
% an int or another name
external func coq.name-suffix name, any -> name.

% [coq.string->name Hint Name] creates a name hint
external func coq.string->name string -> name.


func coq.id->name id -> name.
coq.id->name S N :- coq.string->name S N.
  

% [coq.name->id Name Id] tuns a pretty printing hint into a string. This API
% is for internal use, no guarantee on its behavior.
external func coq.name->id name -> id.

% [coq.gref->id GR Id] extracts the label (last component of a full kernel
% name)
external func coq.gref->id gref -> id.

% [coq.gref->string GR FullPath] extract the full kernel name
external func coq.gref->string gref -> string.

% [coq.gref->path GR FullPath] extract the full path (kernel name without
% final id), each component is a separate list item
external func coq.gref->path gref -> list string.

% [coq.modpath->path MP FullPath] extract the full kernel name, each
% component is a separate list item
external func coq.modpath->path modpath -> list string.

% [coq.modtypath->path MTP FullPath] extract the full kernel name, each
% component is a separate list item
external func coq.modtypath->path modtypath -> list string.

% [coq.modpath->library MP LibraryPath] extract the enclosing module which
% can be Required
external func coq.modpath->library modpath -> modpath.

% [coq.modtypath->library MTP LibraryPath] extract the enclosing module
% which can be Required
external func coq.modtypath->library modtypath -> modpath.

% [coq.term->string T S] prints a term T to a string S using Coq's pretty
% printer
% Supported attributes:
% - @ppwidth! N (default 80, max line length)
% - @ppall! (default: false, prints all details)
% - @ppmost! (default: false, prints most details)
% - @pplevel! (default: _, prints parentheses to reach that level, 200 =
% off)
% - @holes! (default: false, prints evars as _)
external func coq.term->string term -> string.

% [coq.term->pp T B] prints a term T to a pp.t B using Coq's pretty
% printer"
% Supported attributes:
% - @ppall! (default: false, prints all details)
% - @ppmost! (default: false, prints most details)
% - @pplevel! (default: _, prints parentheses to reach that level, 200 =
% off)
% - @holes! (default: false, prints evars as _)
external func coq.term->pp term -> coq.pp.

% [coq.goal->pp G B] prints a goal G to a pp.t B using Coq's pretty
% printer"
% Supported attributes:
% - @ppall! (default: false, prints all details)
% - @ppmost! (default: false, prints most details)
% - @pplevel! (default: _, prints parentheses to reach that level, 200 =
% off)
% - @holes! (default: false, prints evars as _)
external func coq.goal->pp goal -> coq.pp.

% -- Register -----------------------------------------------

% Coq scheme kind (currently undocumented in Rocq)
kind coq.register.scheme-kind type.
type coq.register.scheme.rect_dep coq.register.scheme-kind.
type coq.register.scheme.rec_dep coq.register.scheme-kind.
type coq.register.scheme.ind_dep coq.register.scheme-kind.
type coq.register.scheme.sind_dep coq.register.scheme-kind.
type coq.register.scheme.rect_nodep coq.register.scheme-kind.
type coq.register.scheme.rec_nodep coq.register.scheme-kind.
type coq.register.scheme.ind_nodep coq.register.scheme-kind.
type coq.register.scheme.sind_nodep coq.register.scheme-kind.
type coq.register.scheme.case_dep coq.register.scheme-kind.
type coq.register.scheme.case_nodep coq.register.scheme-kind.
type coq.register.scheme.casep_dep coq.register.scheme-kind.
type coq.register.scheme.casep_nodep coq.register.scheme-kind.
type coq.register.scheme.sym_internal coq.register.scheme-kind.
type coq.register.scheme.sym_involutive coq.register.scheme-kind.
type coq.register.scheme.rew_r_dep coq.register.scheme-kind.
type coq.register.scheme.rew_dep coq.register.scheme-kind.
type coq.register.scheme.rew_fwd_dep coq.register.scheme-kind.
type coq.register.scheme.rew_fwd_r_dep coq.register.scheme-kind.
type coq.register.scheme.rew_r coq.register.scheme-kind.
type coq.register.scheme.rew coq.register.scheme-kind.
type coq.register.scheme.congr coq.register.scheme-kind.
type coq.register.scheme.beq coq.register.scheme-kind.
type coq.register.scheme.dec_bl coq.register.scheme-kind.
type coq.register.scheme.dec_lb coq.register.scheme-kind.
type coq.register.scheme.eq_dec coq.register.scheme-kind.
type coq.register.scheme.other string -> coq.register.scheme-kind.

% Coq register value
kind coq.register type.
type coq.register.inline coq.register.
type coq.register.lib string -> coq.register.
type coq.register.scheme gref -> coq.register.scheme-kind -> coq.register.

% [coq.register GR R] Registers GR as R (See Register Inline, Register
% Scheme)
external pred coq.register i:gref, i:coq.register.

% -- Extra Dependencies -----------------------------------------------

% [coq.extra-dep Identifier FileName] Resolve the file name of an extra
% dependency. See also Coq's From xxx Extra Dependency yyy as zzz.
external func coq.extra-dep id -> option id.

% -- Access to Elpi's data --------------------------------------------

% clauses
% 
% A clause like
%  :name "foo" :before "bar" foo X Y :- bar X Z, baz Z Y
% is represented as
%  clause "foo" (before "bar") (pi x y z\ foo x y :- bar x z, baz z y)
% that is exactly what one would load in the context using =>.
% 
% The name and the grafting specification can be left unspecified.
kind clause type.
external symbol clause : id -> grafting -> prop -> clause = "1". 

% Specify if the clause has to be grafted before, grafted after or replace
% a named clause
kind grafting type.
external symbol before : id -> grafting = "1". 
external symbol after : id -> grafting = "1". 
external symbol remove : id -> grafting = "1". 
external symbol replace : id -> grafting = "1". 

% Specify to which module the clause should be attached to
kind scope type.
external symbol execution-site : scope = "1".  % The module inside which the Elpi program is run
external symbol current : scope = "1".  % The module being defined (see begin/end-module)
external symbol library : scope = "1".  % The outermost module (carrying the file name)


% see coq.elpi.accumulate-clauses
:index (1)
func coq.elpi.accumulate scope, id, clause.
coq.elpi.accumulate S N C :- coq.elpi.accumulate-clauses S N [C].


% [coq.elpi.accumulate-clauses Scope DbName Clauses] 
% Declare that, once the program is over, the given clauses has to be
% added to the given db (see Elpi Db).
% Clauses usually belong to Coq modules: the Scope argument lets one
% select which module:
% - execution site (default) is the module in which the pogram is
%   invoked
% - current is the module currently being constructed (see
%   begin/end-module)
% - library is the current file (the module that is named after the file)
% The clauses are visible as soon as the enclosing module is Imported.
% A clause that mentions a section variable is automatically discarded
% at the end of the section.
% Clauses cannot be accumulated inside functors.
% Supported attributes:
% - @local! (default: false, discard at the end of section or module)
% - @global! (default: false, always active, only if Scope is
% execution-site, discouraged)
external func coq.elpi.accumulate-clauses scope, id, list clause.

% Specify if a predicate argument is in input or output mode
kind argument_mode type.
external symbol in : argument_mode = "1". 
external symbol out : argument_mode = "1". 

% [coq.elpi.add-predicate Db Indexing PredName Spec] Declares a new
% predicate PredName in the data base Db.
% Indexing can be left unspecified. Spec gathers a mode and a
% type for each argument. CAVEAT: types and indexing are strings
% instead of proper data types; beware parsing errors are fatal.
% Supported attributes:
% - @local! (default: false, discard at the end of section or module)
% - @global! (default: false, always active
external func coq.elpi.add-predicate string, string, string, 
                                    list (pair argument_mode string).

% [coq.elpi.predicate PredName Args Pred] Pred is the application of
% PredName to Args
external func coq.elpi.predicate string, list any -> prop.

% -- Synterp ----------------------------------------------------------

% Action executed during the parsing phase (aka synterp)
kind synterp-action type.
external symbol begin-module : id -> synterp-action = "1". 
external symbol begin-module-type : id -> synterp-action = "1". 
external symbol begin-section : id -> synterp-action = "1". 
external symbol end-module : modpath -> synterp-action = "1". 
external symbol end-module-type : modtypath -> synterp-action = "1". 
external symbol end-section : synterp-action = "1". 
external symbol apply-module-functor : id -> synterp-action = "1". 
external symbol apply-module-type-functor : id -> synterp-action = "1". 
external symbol include-module : modpath -> synterp-action = "1". 
external symbol include-module-type : modtypath -> synterp-action = "1". 
external symbol import-module : modpath -> synterp-action = "1". 
external symbol export-module : modpath -> synterp-action = "1". 

% Synterp action group
kind group type.


% [coq.next-synterp-action A] Get the next action performed during parsing
% (aka synterp), that is also the next action to be performed during
% execution (aka interp). See also coq.replay-synterp-action
external func coq.next-synterp-action -> synterp-action.

% [coq.replay-synterp-action-group ID] Execute all actions of synterp action
% group ID. ID must be the name of the next group, it must not be opened
% already, and there must not be any actions before it.
external func coq.replay-synterp-action-group id.

% [coq.begin-synterp-group ID Group] Match a begin-synterp-group synterp
% operation. ID must be the name of the next synterp action group and there
% must not be any actions before it.
external func coq.begin-synterp-group id -> group.

% [coq.end-synterp-group Group] Match a end-synterp-group synterp operation.
% Group must be the currently opened synterp action group and the group must
% not have any more synterp actions or groups left to replay.
external func coq.end-synterp-group group.

% -- Utils ------------------------------------------------------------

kind coq.gref.set type.

% [coq.gref.set.empty A] The empty set
external func coq.gref.set.empty -> coq.gref.set.

% [coq.gref.set.mem Elem A] Checks if Elem is in a
external func coq.gref.set.mem gref, coq.gref.set.

% [coq.gref.set.add Elem A B] B is A union {Elem}
external func coq.gref.set.add gref, coq.gref.set -> coq.gref.set.

% [coq.gref.set.remove Elem A B] B is A \ {Elem}
external func coq.gref.set.remove gref, coq.gref.set -> coq.gref.set.

% [coq.gref.set.union A B X] X is A union B
external func coq.gref.set.union coq.gref.set, 
                                coq.gref.set -> coq.gref.set.

% [coq.gref.set.inter A B X] X is A intersection B
external func coq.gref.set.inter coq.gref.set, 
                                coq.gref.set -> coq.gref.set.

% [coq.gref.set.diff A B X] X is A \ B
external func coq.gref.set.diff coq.gref.set, 
                               coq.gref.set -> coq.gref.set.

% [coq.gref.set.equal A B] tests A and B for equality
external func coq.gref.set.equal coq.gref.set, coq.gref.set.

% [coq.gref.set.subset A B] tests if A is a subset of B
external func coq.gref.set.subset coq.gref.set, coq.gref.set.

% [coq.gref.set.elements M L] L is M transformed into list
external func coq.gref.set.elements coq.gref.set -> list gref.

% [coq.gref.set.choose M X] X is an element of M
external func coq.gref.set.choose coq.gref.set -> gref.

% [coq.gref.set.min M X] X is the smallest element of M
external func coq.gref.set.min coq.gref.set -> gref.

% [coq.gref.set.max M X] X is the bigger of M
external func coq.gref.set.max coq.gref.set -> gref.

% [coq.gref.set.cardinal M N] N is the number of elements of M
external func coq.gref.set.cardinal coq.gref.set -> int.

% [coq.gref.set.filter M F M1] Filter M w.r.t. the predicate F
external func coq.gref.set.filter coq.gref.set, 
                                 (gref -> prop) -> coq.gref.set.

% [coq.gref.set.map M F M1] Map M w.r.t. the predicate F
external func coq.gref.set.map coq.gref.set, 
                              (gref -> gref -> prop) -> coq.gref.set.

% [coq.gref.set.fold M Acc F Acc1] fold M w.r.t. the predicate F
external func coq.gref.set.fold coq.gref.set, A, 
                               (gref -> A -> A -> prop) -> A.

% [coq.gref.set.partition M F M1 M2] Partitions M w.r.t. the predicate F, M1
% is where F holds
external func coq.gref.set.partition coq.gref.set, 
                                    (gref -> prop) -> coq.gref.set, 
                                    coq.gref.set.

% CAVEAT: the type parameter of coq.gref.map must be a closed term

kind coq.gref.map type -> type.

% [coq.gref.map.empty M] The empty map
external func coq.gref.map.empty -> coq.gref.map A.

% [coq.gref.map.mem S M] Checks if S is bound in M
external func coq.gref.map.mem gref, coq.gref.map A.

% [coq.gref.map.add S V M M1] M1 is M where V is bound to S
external func coq.gref.map.add gref, A, coq.gref.map A -> coq.gref.map A.

% [coq.gref.map.remove S M M1] M1 is M where S is unbound
external func coq.gref.map.remove gref, coq.gref.map A -> coq.gref.map A.

% [coq.gref.map.find S M V] V is the binding of S in M
external func coq.gref.map.find gref, coq.gref.map A -> A.

% [coq.gref.map.bindings M L] L is M transformed into an associative list
external func coq.gref.map.bindings coq.gref.map A -> list (pair gref A).

% [coq.gref.map.filter M F M1] Filter M w.r.t. the predicate F
external func coq.gref.map.filter coq.gref.map A, 
                                 (gref -> A -> prop) -> coq.gref.map A.

% [coq.gref.map.map M F M1] Map M w.r.t. the predicate F
external func coq.gref.map.map coq.gref.map A, 
                              (gref -> A -> B -> prop) -> coq.gref.map B.

% [coq.gref.map.fold M Acc F Acc1] fold M w.r.t. the predicate F
external func coq.gref.map.fold coq.gref.map A, C, 
                               (gref -> A -> C -> C -> prop) -> C.

kind coq.univ.set type.

% [coq.univ.set.empty A] The empty set
external func coq.univ.set.empty -> coq.univ.set.

% [coq.univ.set.mem Elem A] Checks if Elem is in a
external func coq.univ.set.mem univ, coq.univ.set.

% [coq.univ.set.add Elem A B] B is A union {Elem}
external func coq.univ.set.add univ, coq.univ.set -> coq.univ.set.

% [coq.univ.set.remove Elem A B] B is A \ {Elem}
external func coq.univ.set.remove univ, coq.univ.set -> coq.univ.set.

% [coq.univ.set.union A B X] X is A union B
external func coq.univ.set.union coq.univ.set, 
                                coq.univ.set -> coq.univ.set.

% [coq.univ.set.inter A B X] X is A intersection B
external func coq.univ.set.inter coq.univ.set, 
                                coq.univ.set -> coq.univ.set.

% [coq.univ.set.diff A B X] X is A \ B
external func coq.univ.set.diff coq.univ.set, 
                               coq.univ.set -> coq.univ.set.

% [coq.univ.set.equal A B] tests A and B for equality
external func coq.univ.set.equal coq.univ.set, coq.univ.set.

% [coq.univ.set.subset A B] tests if A is a subset of B
external func coq.univ.set.subset coq.univ.set, coq.univ.set.

% [coq.univ.set.elements M L] L is M transformed into list
external func coq.univ.set.elements coq.univ.set -> list univ.

% [coq.univ.set.choose M X] X is an element of M
external func coq.univ.set.choose coq.univ.set -> univ.

% [coq.univ.set.min M X] X is the smallest element of M
external func coq.univ.set.min coq.univ.set -> univ.

% [coq.univ.set.max M X] X is the bigger of M
external func coq.univ.set.max coq.univ.set -> univ.

% [coq.univ.set.cardinal M N] N is the number of elements of M
external func coq.univ.set.cardinal coq.univ.set -> int.

% [coq.univ.set.filter M F M1] Filter M w.r.t. the predicate F
external func coq.univ.set.filter coq.univ.set, 
                                 (univ -> prop) -> coq.univ.set.

% [coq.univ.set.map M F M1] Map M w.r.t. the predicate F
external func coq.univ.set.map coq.univ.set, 
                              (univ -> univ -> prop) -> coq.univ.set.

% [coq.univ.set.fold M Acc F Acc1] fold M w.r.t. the predicate F
external func coq.univ.set.fold coq.univ.set, A, 
                               (univ -> A -> A -> prop) -> A.

% [coq.univ.set.partition M F M1 M2] Partitions M w.r.t. the predicate F, M1
% is where F holds
external func coq.univ.set.partition coq.univ.set, 
                                    (univ -> prop) -> coq.univ.set, 
                                    coq.univ.set.

% CAVEAT: the type parameter of coq.univ.map must be a closed term

kind coq.univ.map type -> type.

% [coq.univ.map.empty M] The empty map
external func coq.univ.map.empty -> coq.univ.map A.

% [coq.univ.map.mem S M] Checks if S is bound in M
external func coq.univ.map.mem univ, coq.univ.map A.

% [coq.univ.map.add S V M M1] M1 is M where V is bound to S
external func coq.univ.map.add univ, A, coq.univ.map A -> coq.univ.map A.

% [coq.univ.map.remove S M M1] M1 is M where S is unbound
external func coq.univ.map.remove univ, coq.univ.map A -> coq.univ.map A.

% [coq.univ.map.find S M V] V is the binding of S in M
external func coq.univ.map.find univ, coq.univ.map A -> A.

% [coq.univ.map.bindings M L] L is M transformed into an associative list
external func coq.univ.map.bindings coq.univ.map A -> list (pair univ A).

% [coq.univ.map.filter M F M1] Filter M w.r.t. the predicate F
external func coq.univ.map.filter coq.univ.map A, 
                                 (univ -> A -> prop) -> coq.univ.map A.

% [coq.univ.map.map M F M1] Map M w.r.t. the predicate F
external func coq.univ.map.map coq.univ.map A, 
                              (univ -> A -> B -> prop) -> coq.univ.map B.

% [coq.univ.map.fold M Acc F Acc1] fold M w.r.t. the predicate F
external func coq.univ.map.fold coq.univ.map A, C, 
                               (univ -> A -> C -> C -> prop) -> C.

kind coq.univ.variable.set type.

% [coq.univ.variable.set.empty A] The empty set
external func coq.univ.variable.set.empty -> coq.univ.variable.set.

% [coq.univ.variable.set.mem Elem A] Checks if Elem is in a
external func coq.univ.variable.set.mem univ.variable, 
                                       coq.univ.variable.set.

% [coq.univ.variable.set.add Elem A B] B is A union {Elem}
external func coq.univ.variable.set.add univ.variable, 
                                       coq.univ.variable.set -> coq.univ.variable.set.

% [coq.univ.variable.set.remove Elem A B] B is A \ {Elem}
external func coq.univ.variable.set.remove univ.variable, 
                                          coq.univ.variable.set -> coq.univ.variable.set.

% [coq.univ.variable.set.union A B X] X is A union B
external func coq.univ.variable.set.union coq.univ.variable.set, 
                                         coq.univ.variable.set -> coq.univ.variable.set.

% [coq.univ.variable.set.inter A B X] X is A intersection B
external func coq.univ.variable.set.inter coq.univ.variable.set, 
                                         coq.univ.variable.set -> coq.univ.variable.set.

% [coq.univ.variable.set.diff A B X] X is A \ B
external func coq.univ.variable.set.diff coq.univ.variable.set, 
                                        coq.univ.variable.set -> coq.univ.variable.set.

% [coq.univ.variable.set.equal A B] tests A and B for equality
external func coq.univ.variable.set.equal coq.univ.variable.set, 
                                         coq.univ.variable.set.

% [coq.univ.variable.set.subset A B] tests if A is a subset of B
external func coq.univ.variable.set.subset coq.univ.variable.set, 
                                          coq.univ.variable.set.

% [coq.univ.variable.set.elements M L] L is M transformed into list
external func coq.univ.variable.set.elements coq.univ.variable.set -> list univ.variable.

% [coq.univ.variable.set.choose M X] X is an element of M
external func coq.univ.variable.set.choose coq.univ.variable.set -> univ.variable.

% [coq.univ.variable.set.min M X] X is the smallest element of M
external func coq.univ.variable.set.min coq.univ.variable.set -> univ.variable.

% [coq.univ.variable.set.max M X] X is the bigger of M
external func coq.univ.variable.set.max coq.univ.variable.set -> univ.variable.

% [coq.univ.variable.set.cardinal M N] N is the number of elements of M
external func coq.univ.variable.set.cardinal coq.univ.variable.set -> int.

% [coq.univ.variable.set.filter M F M1] Filter M w.r.t. the predicate F
external func coq.univ.variable.set.filter coq.univ.variable.set, 
                                          (univ.variable -> prop) -> coq.univ.variable.set.

% [coq.univ.variable.set.map M F M1] Map M w.r.t. the predicate F
external func coq.univ.variable.set.map coq.univ.variable.set, 
                                       (univ.variable -> univ.variable -> prop) -> coq.univ.variable.set.

% [coq.univ.variable.set.fold M Acc F Acc1] fold M w.r.t. the predicate F
external func coq.univ.variable.set.fold coq.univ.variable.set, A, 
                                        (univ.variable -> A -> A -> prop) -> A.

% [coq.univ.variable.set.partition M F M1 M2] Partitions M w.r.t. the
% predicate F, M1 is where F holds
external func coq.univ.variable.set.partition coq.univ.variable.set, 
                                             (univ.variable -> prop) -> coq.univ.variable.set, 
                                             coq.univ.variable.set.

% CAVEAT: the type parameter of coq.univ.variable.map must be a closed
% term

kind coq.univ.variable.map type -> type.

% [coq.univ.variable.map.empty M] The empty map
external func coq.univ.variable.map.empty -> coq.univ.variable.map A.

% [coq.univ.variable.map.mem S M] Checks if S is bound in M
external func coq.univ.variable.map.mem univ.variable, 
                                       coq.univ.variable.map A.

% [coq.univ.variable.map.add S V M M1] M1 is M where V is bound to S
external func coq.univ.variable.map.add univ.variable, A, 
                                       coq.univ.variable.map A -> coq.univ.variable.map A.

% [coq.univ.variable.map.remove S M M1] M1 is M where S is unbound
external func coq.univ.variable.map.remove univ.variable, 
                                          coq.univ.variable.map A -> coq.univ.variable.map A.

% [coq.univ.variable.map.find S M V] V is the binding of S in M
external func coq.univ.variable.map.find univ.variable, 
                                        coq.univ.variable.map A -> A.

% [coq.univ.variable.map.bindings M L] L is M transformed into an
% associative list
external func coq.univ.variable.map.bindings coq.univ.variable.map A -> list (pair univ.variable A).

% [coq.univ.variable.map.filter M F M1] Filter M w.r.t. the predicate F
external func coq.univ.variable.map.filter coq.univ.variable.map A, 
                                          (univ.variable -> A -> prop) -> coq.univ.variable.map A.

% [coq.univ.variable.map.map M F M1] Map M w.r.t. the predicate F
external func coq.univ.variable.map.map coq.univ.variable.map A, 
                                       (univ.variable -> A -> B -> prop) -> coq.univ.variable.map B.

% [coq.univ.variable.map.fold M Acc F Acc1] fold M w.r.t. the predicate F
external func coq.univ.variable.map.fold coq.univ.variable.map A, C, 
                                        (univ.variable -> A -> C -> C -> prop) -> C.

% Coq box types for pretty printing:
% - Vertical block: each break leads to a new line
% - Horizontal block: no line breaking
% - Horizontal-vertical block: same as Vertical block, except if this block
%   is small enough to fit on a single line in which case it is the same
%   as a Horizontal block
% - Horizontal or Vertical block: breaks lead to new line only when
%   necessary to print the content of the block (the contents flow
%   inside the box)
kind coq.pp.box type.
external symbol coq.pp.v : int -> coq.pp.box = "1". 
external symbol coq.pp.h : coq.pp.box = "1". 
external symbol coq.pp.hv : int -> coq.pp.box = "1". 
external symbol coq.pp.hov : int -> coq.pp.box = "1". 

% Coq box model for pretty printing. Items:
% - empty
% - spc: a spacem, also a breaking hint
% - str: a non breakable string
% - brk L I: a breaking hint of a given length L contributing I spaces to
%   indentation when taken
% - glue: puts things together
% - box B: a box with automatic line breaking according to B
% - comment: embedded \\n are turned into nl (see below)
% - tag: ignored
% - nl: break the line (should not be used)
kind coq.pp type.
external symbol coq.pp.empty : coq.pp = "1". 
external symbol coq.pp.spc : coq.pp = "1". 
external symbol coq.pp.str : string -> coq.pp = "1". 
external symbol coq.pp.brk : int -> int -> coq.pp = "1". 
external symbol coq.pp.glue : list coq.pp -> coq.pp = "1". 
external symbol coq.pp.box : coq.pp.box -> list coq.pp -> coq.pp = "1". 
external symbol coq.pp.comment : list string -> coq.pp = "1". 
external symbol coq.pp.tag : string -> coq.pp -> coq.pp = "1". 
external symbol coq.pp.nl : coq.pp = "1". 

% [coq.pp->string B S] Prints a pp.t box expression B to a string S
% Supported attributes:
% - @ppwidth! N (default 80, max line length)
external func coq.pp->string coq.pp -> string.




