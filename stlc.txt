kind abbreviation type.
kind argument type.
kind argument_mode type.
kind arity type.
kind attribute type.
kind attribute-value type.
kind bool type.
kind class type.
kind clause type.
kind cmp type.
kind coercion type.
kind coercion-status type.
kind constant type.
kind constructor type.
kind context-decl type.
kind conversion_strategy type.
kind coq.gref.map type -> type.
kind coq.gref.set type.
kind coq.inline type.
kind coq.option type.
kind coq.pp type.
kind coq.pp.box type.
kind coq.redflag type.
kind coq.redflags type.
kind coq.register type.
kind coq.register.scheme-kind type.
kind coq.univ.map type -> type.
kind coq.univ.set type.
kind coq.univ.variable.map type -> type.
kind coq.univ.variable.set type.
kind cs-instance type.
kind cs-pattern type.
kind diagnostic type.
kind field-attribute type.
kind float type.
kind float64 type.
kind goal type.
kind grafting type.
kind gref type.
kind group type.
kind hint-mode type.
kind implicit_kind type.
kind in_stream type.
kind indc-decl type.
kind indt-decl type.
kind inductive type.
kind int type.
kind list type -> type.
kind loc type.
kind located type.
kind ltac1-tactic type.
kind modpath type.
kind modtypath type.
kind module-item type.
kind name type.
kind option type -> type.
kind out_stream type.
kind pair type -> type -> type.
kind primitive-value type.
kind projection type.
kind pstring type.
kind record-decl type.
kind safe type.
kind scope type.
kind sealed-goal type.
kind simplification_strategy type.
kind sort type.
kind std.int.map type -> type.
kind std.int.set type.
kind std.loc.map type -> type.
kind std.loc.set type.
kind std.map type -> type -> type.
kind std.map.private.map type -> type -> type.
kind std.set type -> type.
kind std.set.private.set type -> type.
kind std.string.map type -> type.
kind std.string.set type.
kind string type.
kind synterp-action type.
kind tc-instance type.
kind term type.
kind triple type -> type -> type -> type.
kind ty type.
kind uint63 type.
kind univ type.
kind univ-constraint type.
kind univ-instance type.
kind univ-variance type.
kind univ.variable type.
kind unix.process type.
kind upoly-decl type.
type ! (func).
type (*) float -> float -> float.
type (*) int -> int -> int.
type (+) float -> float -> float.
type (+) int -> int -> int.
type (,) variadic (func) (func).
type (-) A -> A -> A.
type (/) float -> float -> float.
type (:-) (func -> (func), (func)).
type (:-) (func -> (func), list (pred)).
type (::) X -> list X -> list X.
type (;) (pred o:(pred), o:(pred)).
type (<) (func A, A).
type (=) (func -> A, A).
type (=<) (func A, A).
type (==) (func A, A).
type (=>) (func -> (pred), (func)).
type (=>) (func -> list (pred), (func)).
type (>) (func A, A).
type (>=) (func A, A).
type [] list X.
type (^) string -> string -> string.
type abs float -> float.
type abs int -> int.
type after id -> grafting.
type app list term -> term.
type app term -> term -> term.
type apply-module-functor id -> synterp-action.
type apply-module-type-functor id -> synterp-action.
type arctan float -> float.
type arity term -> arity.
type arr ty -> ty -> ty.
type as A -> A -> A.
type attribute string -> attribute-value -> attribute.
type attributes (func -> list attribute).
type auto univ.variable -> univ-variance.
type bar term.
type before id -> grafting.
type begin-module id -> synterp-action.
type begin-module-type id -> synterp-action.
type begin-section id -> synterp-action.
type cache (func term -> term).
type calc (func A -> A).
type canonical bool -> field-attribute.
type ceil float -> int.
type chr int -> string.
type clause id -> grafting -> (pred) -> clause.
type close_in (func in_stream).
type close_out (func out_stream).
type closed_term (func -> any).
type cmp_term (func any, any -> cmp).
type coercion coercion-status -> field-attribute.
type coercion gref -> int -> gref -> class -> coercion.
type const constant -> gref.
type const-decl id -> option term -> arity -> argument.
type constant (func -> any, any).
type constructor id -> arity -> indc-decl.
type context-end context-decl.
type context-item id ->
                    implicit_kind ->
                      term ->
                        option term -> (term -> context-decl) -> context-decl.
type coq.CS.canonical-projection? (func constant).
type coq.CS.canonical-projections (pred i:inductive, o:list (option constant)).
type coq.CS.db (func -> list cs-instance).
type coq.CS.db-for (func gref, cs-pattern -> list cs-instance).
type coq.CS.declare-instance (func gref).
type coq.TC.class? (func gref).
type coq.TC.db (func -> list tc-instance).
type coq.TC.db-for (func gref -> list tc-instance).
type coq.TC.db-tc (func -> list gref).
type coq.TC.declare-class (func gref).
type coq.TC.declare-instance (func gref, int).
type coq.TC.get-inst-prio (func gref, gref -> int).
type coq.arguments.implicit (func gref -> list (list implicit_kind)).
type coq.arguments.name (func gref -> list (option id)).
type coq.arguments.scope (func gref -> list (list id)).
type coq.arguments.set-default-implicit (func gref).
type coq.arguments.set-implicit (func gref, list (list implicit_kind)).
type coq.arguments.set-name (func gref, list (option id)).
type coq.arguments.set-scope (func gref, list (list id)).
type coq.arguments.set-simplification (func gref, simplification_strategy).
type coq.arguments.simplification (func gref
                                         -> option simplification_strategy).
type coq.arity->term (func arity -> term).
type coq.begin-synterp-group (func id -> group).
type coq.coercion.db (func -> list coercion).
type coq.coercion.db-for (func class, class -> list (pair gref int)).
type coq.coercion.declare (func coercion).
type coq.debug variadic any (func).
type coq.elaborate-skeleton (func term -> term, term, diagnostic).
type coq.elaborate-ty-skeleton (func term -> sort, term, diagnostic).
type coq.elpi.accumulate (func scope, id, clause).
type coq.elpi.accumulate-clauses (func scope, id, list clause).
type coq.elpi.add-predicate (func
                                   string,
                                            string,
                                                     string,
                                                              list
                                                                (pair
                                                                   argument_mode 
                                                                   string)).
type coq.elpi.predicate (func string, list any -> (pred)).
type coq.elpi.toposort (func list (pair A (list A)) -> list A).
type coq.end-synterp-group (func group).
type coq.env.add-axiom (func id, term -> constant).
type coq.env.add-const (func id, term, term, opaque? -> constant).
type coq.env.add-context (pred i:context-decl).
type coq.env.add-indt (func indt-decl -> inductive).
type coq.env.add-section-variable (func id, implicit_kind, term -> constant).
type coq.env.apply-module-functor (func
                                         id,
                                              option modtypath,
                                                                 modpath,
                                                                 
                                                                   list
                                                                    modpath,
                                                                   
                                                                    coq.inline
                                                                    ->
                                                                     modpath).
type coq.env.apply-module-type-functor (func
                                              id,
                                                   modtypath,
                                                               list modpath,
                                                                coq.inline
                                                                 -> modtypath).
type coq.env.begin-module (func id, option modtypath).
type coq.env.begin-module-functor (func
                                         id,
                                              option modtypath,
                                                                 list
                                                                   (pair id 
                                                                    modtypath)).
type coq.env.begin-module-type (func id).
type coq.env.begin-module-type-functor (func id, list (pair id modtypath)).
type coq.env.begin-section (func id).
type coq.env.const (func constant -> option term, term).
type coq.env.const-body (func constant -> option term).
type coq.env.const-opaque? (pred i:constant).
type coq.env.const-primitive? (pred i:constant).
type coq.env.current-path (func -> list string).
type coq.env.current-section-path (func -> list string).
type coq.env.dependencies (func gref, modpath -> coq.gref.set).
type coq.env.end-module (func -> modpath).
type coq.env.end-module-type (func -> modtypath).
type coq.env.end-section (func).
type coq.env.export-module (func modpath).
type coq.env.fresh-global-id (func id -> id).
type coq.env.global (func -> gref, term).
type coq.env.import-module (func modpath).
type coq.env.include-module (func modpath, coq.inline).
type coq.env.include-module-type (func modtypath, coq.inline).
type coq.env.indc (func constructor -> int, int, int, term).
type coq.env.indc->indt (func constructor -> inductive, int).
type coq.env.indt (func inductive
                         -> bool, int, int, term, list constructor, list term).
type coq.env.indt-decl (func inductive -> indt-decl).
type coq.env.informative? (func inductive).
type coq.env.module (func modpath -> list module-item).
type coq.env.module-type (func modtypath -> list id).
type coq.env.opaque? (func constant).
type coq.env.primitive-projection? (func -> projection, constant, int).
type coq.env.primitive-projections (func inductive
                                          ->
                                              list
                                                (option (pair projection int))).
type coq.env.primitive? (func constant).
type coq.env.projection? (func constant -> int).
type coq.env.projections (func inductive -> list (option constant)).
type coq.env.record? (func inductive -> bool).
type coq.env.recursive? (func inductive).
type coq.env.section (func -> list constant).
type coq.env.term-dependencies (func term -> coq.gref.set).
type coq.env.transitive-dependencies (func gref, modpath -> coq.gref.set).
type coq.env.typeof (func gref -> term).
type coq.env.univpoly? (func gref -> int).
type coq.error variadic any (func).
type coq.extra-dep (func id -> option id).
type coq.float->float64 (func float -> float64).
type coq.float64->float (func float64 -> float).
type coq.goal->pp (func goal -> coq.pp).
type coq.gref->id (func gref -> id).
type coq.gref->path (func gref -> list string).
type coq.gref->string (func gref -> string).
type coq.gref.map.add (func gref, A, coq.gref.map A -> coq.gref.map A).
type coq.gref.map.bindings (func coq.gref.map A -> list (pair gref A)).
type coq.gref.map.empty (func -> coq.gref.map A).
type coq.gref.map.filter (func
                                coq.gref.map A, ((pred o:gref, o:A))
                                                 -> coq.gref.map A).
type coq.gref.map.find (func gref, coq.gref.map A -> A).
type coq.gref.map.fold (func
                              coq.gref.map A,
                                               C,
                                                   ((pred o:gref, o:A, 
                                                      o:C, o:C)) -> C).
type coq.gref.map.map (func
                             coq.gref.map A, ((pred o:gref, o:A, o:B))
                                              -> coq.gref.map B).
type coq.gref.map.mem (func gref, coq.gref.map A).
type coq.gref.map.remove (func gref, coq.gref.map A -> coq.gref.map A).
type coq.gref.set.add (func gref, coq.gref.set -> coq.gref.set).
type coq.gref.set.cardinal (func coq.gref.set -> int).
type coq.gref.set.choose (func coq.gref.set -> gref).
type coq.gref.set.diff (func coq.gref.set, coq.gref.set -> coq.gref.set).
type coq.gref.set.elements (func coq.gref.set -> list gref).
type coq.gref.set.empty (func -> coq.gref.set).
type coq.gref.set.equal (func coq.gref.set, coq.gref.set).
type coq.gref.set.filter (func coq.gref.set, ((func -> gref)) -> coq.gref.set).
type coq.gref.set.fold (func coq.gref.set, A, ((pred o:gref, o:A, o:A)) -> A).
type coq.gref.set.inter (func coq.gref.set, coq.gref.set -> coq.gref.set).
type coq.gref.set.map (func
                             coq.gref.set, ((pred o:gref, o:gref))
                                            -> coq.gref.set).
type coq.gref.set.max (func coq.gref.set -> gref).
type coq.gref.set.mem (func gref, coq.gref.set).
type coq.gref.set.min (func coq.gref.set -> gref).
type coq.gref.set.partition (func
                                   coq.gref.set, ((func -> gref))
                                                  ->
                                                      coq.gref.set,
                                                                    coq.gref.set).
type coq.gref.set.remove (func gref, coq.gref.set -> coq.gref.set).
type coq.gref.set.subset (func coq.gref.set, coq.gref.set).
type coq.gref.set.union (func coq.gref.set, coq.gref.set -> coq.gref.set).
type coq.hints.add-mode (func gref, string, list hint-mode).
type coq.hints.add-resolve (func gref, string, int, term).
type coq.hints.modes (func gref, string -> list (list hint-mode)).
type coq.hints.opaque (func constant, string -> bool).
type coq.hints.set-opaque (func constant, string, bool).
type coq.id->name (func id -> name).
type coq.info variadic any (func).
type coq.inline.at int -> coq.inline.
type coq.inline.default coq.inline.
type coq.inline.no coq.inline.
type coq.int->uint63 (func int -> uint63).
type coq.locate (func id -> gref).
type coq.locate-abbreviation (func id -> abbreviation).
type coq.locate-all (func id -> list located).
type coq.locate-module (func id -> modpath).
type coq.locate-module-type (func id -> modtypath).
type coq.ltac.call-ltac1 (func any, goal -> list sealed-goal).
type coq.ltac.collect-goals (func term -> list sealed-goal, list sealed-goal).
type coq.ltac.fail (pred o:int, variadic i:any).
type coq.ltac.fresh-id (func id, term -> id).
type coq.ltac.id-free? (func id, goal).
type coq.modpath->library (func modpath -> modpath).
type coq.modpath->path (func modpath -> list string).
type coq.modtypath->library (func modtypath -> modpath).
type coq.modtypath->path (func modtypath -> list string).
type coq.name->id (func name -> id).
type coq.name-suffix (func name, any -> name).
type coq.next-synterp-action (func -> synterp-action).
type coq.notation.abbreviation (func abbreviation, list term -> term).
type coq.notation.abbreviation-body (func abbreviation -> int, term).
type coq.notation.add-abbreviation (func id, int, term, bool -> abbreviation).
type coq.notation.add-abbreviation-for-tactic (func
                                                     string,
                                                              string,
                                                               list argument).
type coq.notice variadic any (func).
type coq.option.add (func list string, coq.option, bool).
type coq.option.available? (func list string -> bool).
type coq.option.bool bool -> coq.option.
type coq.option.get (func list string -> coq.option).
type coq.option.int option int -> coq.option.
type coq.option.set (func list string, coq.option).
type coq.option.string option string -> coq.option.
type coq.pp->string (func coq.pp -> string).
type coq.pp.box coq.pp.box -> list coq.pp -> coq.pp.
type coq.pp.brk int -> int -> coq.pp.
type coq.pp.comment list string -> coq.pp.
type coq.pp.empty coq.pp.
type coq.pp.glue list coq.pp -> coq.pp.
type coq.pp.h coq.pp.box.
type coq.pp.hov int -> coq.pp.box.
type coq.pp.hv int -> coq.pp.box.
type coq.pp.nl coq.pp.
type coq.pp.spc coq.pp.
type coq.pp.str string -> coq.pp.
type coq.pp.tag string -> coq.pp -> coq.pp.
type coq.pp.v int -> coq.pp.box.
type coq.primitive.projection-unfolded (func -> projection, projection).
type coq.pstring->string (func pstring -> string).
type coq.redflags.add (func coq.redflags, list coq.redflag -> coq.redflags).
type coq.redflags.all coq.redflags.
type coq.redflags.allnolet coq.redflags.
type coq.redflags.beta coq.redflag.
type coq.redflags.beta coq.redflags.
type coq.redflags.betadeltazeta coq.redflags.
type coq.redflags.betaiota coq.redflags.
type coq.redflags.betaiotazeta coq.redflags.
type coq.redflags.betazeta coq.redflags.
type coq.redflags.cofix coq.redflag.
type coq.redflags.const constant -> coq.redflag.
type coq.redflags.delta coq.redflag.
type coq.redflags.delta coq.redflags.
type coq.redflags.fix coq.redflag.
type coq.redflags.match coq.redflag.
type coq.redflags.nored coq.redflags.
type coq.redflags.proj projection -> coq.redflag.
type coq.redflags.sub (func coq.redflags, list coq.redflag -> coq.redflags).
type coq.redflags.zeta coq.redflag.
type coq.redflags.zeta coq.redflags.
type coq.reduction.cbv.norm (func term -> term).
type coq.reduction.cbv.whd_all (pred i:term, o:term).
type coq.reduction.eta-contract (func term -> term).
type coq.reduction.lazy.bi-norm (func term -> term).
type coq.reduction.lazy.norm (func term -> term).
type coq.reduction.lazy.whd (func term -> term).
type coq.reduction.lazy.whd_all (func term -> term).
type coq.reduction.native.available? (func).
type coq.reduction.native.norm (func term, term -> term).
type coq.reduction.vm.norm (func term, term -> term).
type coq.reduction.vm.whd_all (pred i:term, i:term, o:term).
type coq.register (func gref, coq.register).
type coq.register.inline coq.register.
type coq.register.lib string -> coq.register.
type coq.register.scheme gref -> coq.register.scheme-kind -> coq.register.
type coq.register.scheme.beq coq.register.scheme-kind.
type coq.register.scheme.case_dep coq.register.scheme-kind.
type coq.register.scheme.case_nodep coq.register.scheme-kind.
type coq.register.scheme.casep_dep coq.register.scheme-kind.
type coq.register.scheme.casep_nodep coq.register.scheme-kind.
type coq.register.scheme.congr coq.register.scheme-kind.
type coq.register.scheme.dec_bl coq.register.scheme-kind.
type coq.register.scheme.dec_lb coq.register.scheme-kind.
type coq.register.scheme.eq_dec coq.register.scheme-kind.
type coq.register.scheme.ind_dep coq.register.scheme-kind.
type coq.register.scheme.ind_nodep coq.register.scheme-kind.
type coq.register.scheme.other string -> coq.register.scheme-kind.
type coq.register.scheme.rec_dep coq.register.scheme-kind.
type coq.register.scheme.rec_nodep coq.register.scheme-kind.
type coq.register.scheme.rect_dep coq.register.scheme-kind.
type coq.register.scheme.rect_nodep coq.register.scheme-kind.
type coq.register.scheme.rew coq.register.scheme-kind.
type coq.register.scheme.rew_dep coq.register.scheme-kind.
type coq.register.scheme.rew_fwd_dep coq.register.scheme-kind.
type coq.register.scheme.rew_fwd_r_dep coq.register.scheme-kind.
type coq.register.scheme.rew_r coq.register.scheme-kind.
type coq.register.scheme.rew_r_dep coq.register.scheme-kind.
type coq.register.scheme.sind_dep coq.register.scheme-kind.
type coq.register.scheme.sind_nodep coq.register.scheme-kind.
type coq.register.scheme.sym_internal coq.register.scheme-kind.
type coq.register.scheme.sym_involutive coq.register.scheme-kind.
type coq.replay-synterp-action-group (func id).
type coq.say variadic any (func).
type coq.sigma.print (func).
type coq.sort.eq (func -> sort, sort).
type coq.sort.leq (func -> sort, sort).
type coq.sort.pts-triple (func -> sort, sort, sort).
type coq.sort.sup (func -> sort, sort).
type coq.strategy.get (func constant -> conversion_strategy).
type coq.strategy.set (func list constant, conversion_strategy).
type coq.string->name (func string -> name).
type coq.string->pstring (func string -> pstring).
type coq.term->pp (func term -> coq.pp).
type coq.term->string (func term -> string).
type coq.typecheck (func term -> term, diagnostic).
type coq.typecheck-ty (func term -> sort, diagnostic).
type coq.uint63->int (func uint63 -> int).
type coq.unify-eq (func term, term -> diagnostic).
type coq.unify-leq (func term, term -> diagnostic).
type coq.univ (func -> id, univ).
type coq.univ-instance (func -> univ-instance, list univ.variable).
type coq.univ-instance.unify-eq (func
                                       gref,
                                              univ-instance, univ-instance
                                                              -> diagnostic).
type coq.univ-instance.unify-leq (func
                                        gref,
                                               univ-instance, univ-instance
                                                               -> diagnostic).
type coq.univ.alg-max (func univ, univ -> univ).
type coq.univ.alg-super (func univ -> univ).
type coq.univ.constraints (func -> list univ-constraint).
type coq.univ.global? (func univ).
type coq.univ.map.add (func univ, A, coq.univ.map A -> coq.univ.map A).
type coq.univ.map.bindings (func coq.univ.map A -> list (pair univ A)).
type coq.univ.map.empty (func -> coq.univ.map A).
type coq.univ.map.filter (func
                                coq.univ.map A, ((pred o:univ, o:A))
                                                 -> coq.univ.map A).
type coq.univ.map.find (func univ, coq.univ.map A -> A).
type coq.univ.map.fold (func
                              coq.univ.map A,
                                               C,
                                                   ((pred o:univ, o:A, 
                                                      o:C, o:C)) -> C).
type coq.univ.map.map (func
                             coq.univ.map A, ((pred o:univ, o:A, o:B))
                                              -> coq.univ.map B).
type coq.univ.map.mem (func univ, coq.univ.map A).
type coq.univ.map.remove (func univ, coq.univ.map A -> coq.univ.map A).
type coq.univ.new (func -> univ).
type coq.univ.print (func).
type coq.univ.set.add (func univ, coq.univ.set -> coq.univ.set).
type coq.univ.set.cardinal (func coq.univ.set -> int).
type coq.univ.set.choose (func coq.univ.set -> univ).
type coq.univ.set.diff (func coq.univ.set, coq.univ.set -> coq.univ.set).
type coq.univ.set.elements (func coq.univ.set -> list univ).
type coq.univ.set.empty (func -> coq.univ.set).
type coq.univ.set.equal (func coq.univ.set, coq.univ.set).
type coq.univ.set.filter (func coq.univ.set, ((func -> univ)) -> coq.univ.set).
type coq.univ.set.fold (func coq.univ.set, A, ((pred o:univ, o:A, o:A)) -> A).
type coq.univ.set.inter (func coq.univ.set, coq.univ.set -> coq.univ.set).
type coq.univ.set.map (func
                             coq.univ.set, ((pred o:univ, o:univ))
                                            -> coq.univ.set).
type coq.univ.set.max (func coq.univ.set -> univ).
type coq.univ.set.mem (func univ, coq.univ.set).
type coq.univ.set.min (func coq.univ.set -> univ).
type coq.univ.set.partition (func
                                   coq.univ.set, ((func -> univ))
                                                  ->
                                                      coq.univ.set,
                                                                    coq.univ.set).
type coq.univ.set.remove (func univ, coq.univ.set -> coq.univ.set).
type coq.univ.set.subset (func coq.univ.set, coq.univ.set).
type coq.univ.set.union (func coq.univ.set, coq.univ.set -> coq.univ.set).
type coq.univ.variable (func -> univ, univ.variable).
type coq.univ.variable.constraints (func univ.variable
                                          -> list univ-constraint).
type coq.univ.variable.map.add (func
                                      univ.variable,
                                                      A,
                                                          coq.univ.variable.map
                                                            A
                                                          ->
                                                              coq.univ.variable.map
                                                                A).
type coq.univ.variable.map.bindings (func coq.univ.variable.map A
                                           -> list (pair univ.variable A)).
type coq.univ.variable.map.empty (func -> coq.univ.variable.map A).
type coq.univ.variable.map.filter (func
                                         coq.univ.variable.map A,
                                                                   ((pred 
                                                                    o:univ.variable, 
                                                                    o:A))
                                                                   ->
                                                                   
                                                                    coq.univ.variable.map
                                                                    A).
type coq.univ.variable.map.find (func
                                       univ.variable, coq.univ.variable.map A
                                                       -> A).
type coq.univ.variable.map.fold (func
                                       coq.univ.variable.map A,
                                                                 C,
                                                                    ((pred 
                                                                    o:univ.variable, 
                                                                    o:A, 
                                                                    o:C, 
                                                                    o:C))
                                                                    ->
                                                                     C).
type coq.univ.variable.map.map (func
                                      coq.univ.variable.map A,
                                                                ((pred 
                                                                   o:univ.variable, 
                                                                   o:A, 
                                                                   o:B))
                                                                ->
                                                                    coq.univ.variable.map
                                                                    B).
type coq.univ.variable.map.mem (func univ.variable, coq.univ.variable.map A).
type coq.univ.variable.map.remove (func
                                         univ.variable,
                                                         coq.univ.variable.map
                                                           A
                                                         ->
                                                             coq.univ.variable.map
                                                               A).
type coq.univ.variable.of-term (func term -> coq.univ.variable.set).
type coq.univ.variable.set.add (func
                                      univ.variable, coq.univ.variable.set
                                                      ->
                                                          coq.univ.variable.set).
type coq.univ.variable.set.cardinal (func coq.univ.variable.set -> int).
type coq.univ.variable.set.choose (func coq.univ.variable.set
                                         -> univ.variable).
type coq.univ.variable.set.diff (func
                                       coq.univ.variable.set,
                                                               coq.univ.variable.set
                                                               ->
                                                                   coq.univ.variable.set).
type coq.univ.variable.set.elements (func coq.univ.variable.set
                                           -> list univ.variable).
type coq.univ.variable.set.empty (func -> coq.univ.variable.set).
type coq.univ.variable.set.equal (func
                                        coq.univ.variable.set,
                                                                coq.univ.variable.set).
type coq.univ.variable.set.filter (func
                                         coq.univ.variable.set,
                                                                 ((func
                                                                    ->
                                                                    
                                                                    univ.variable))
                                                                 ->
                                                                    coq.univ.variable.set).
type coq.univ.variable.set.fold (func
                                       coq.univ.variable.set,
                                                               A,
                                                                   ((pred 
                                                                    o:univ.variable, 
                                                                    o:A, 
                                                                    o:A))
                                                                   ->
                                                                    A).
type coq.univ.variable.set.inter (func
                                        coq.univ.variable.set,
                                                                coq.univ.variable.set
                                                                ->
                                                                    coq.univ.variable.set).
type coq.univ.variable.set.map (func
                                      coq.univ.variable.set,
                                                              ((pred 
                                                                 o:univ.variable, 
                                                                 o:univ.variable))
                                                              ->
                                                                  coq.univ.variable.set).
type coq.univ.variable.set.max (func coq.univ.variable.set -> univ.variable).
type coq.univ.variable.set.mem (func univ.variable, coq.univ.variable.set).
type coq.univ.variable.set.min (func coq.univ.variable.set -> univ.variable).
type coq.univ.variable.set.partition (func
                                            coq.univ.variable.set,
                                                                    (
                                                                    (func
                                                                    ->
                                                                    univ.variable))
                                                                    ->
                                                                    
                                                                    coq.univ.variable.set,
                                                                    
                                                                    coq.univ.variable.set).
type coq.univ.variable.set.remove (func
                                         univ.variable, coq.univ.variable.set
                                                         ->
                                                             coq.univ.variable.set).
type coq.univ.variable.set.subset (func
                                         coq.univ.variable.set,
                                                                 coq.univ.variable.set).
type coq.univ.variable.set.union (func
                                        coq.univ.variable.set,
                                                                coq.univ.variable.set
                                                                ->
                                                                    coq.univ.variable.set).
type coq.version (func -> string, int, int, int).
type coq.warn variadic any (func).
type coq.warning (pred o:string, o:string, variadic i:any).
type cos float -> float.
type counter (func string -> int).
type covariant univ.variable -> univ-variance.
type cs-default cs-pattern.
type cs-gref gref -> cs-pattern.
type cs-instance gref -> cs-pattern -> gref -> cs-instance.
type cs-prod cs-pattern.
type cs-sort sort -> cs-pattern.
type ctx-decl context-decl -> argument.
type current scope.
type decl (func term -> name, term).
type declare-evar (func list (pred), term, term, term).
type declare_constraint (func (func) -> any).
type def (func term -> name, term, term).
type distinct_names (func list any).
type (div) int -> int -> int.
type dprint variadic any (func).
type end-module modpath -> synterp-action.
type end-module-type modtypath -> synterp-action.
type end-record record-decl.
type end-section synterp-action.
type eof (func in_stream).
type eq cmp.
type eq univ.variable -> univ.variable -> univ-constraint.
type error string -> diagnostic.
type evar (func term, term -> term).
type execution-site scope.
type expand conversion_strategy.
type explicit implicit_kind.
type export-module modpath -> synterp-action.
type fail (func).
type false (func).
type ff bool.
type field field-attributes ->
             id -> term -> (term -> record-decl) -> record-decl.
type findall_solutions (func (pred) -> list (pred)).
type fix name -> int -> term -> (term -> term) -> term.
type float64 float64 -> primitive-value.
type floor float -> int.
type flush (func out_stream).
type foo term.
type fst (func pair A B -> A).
type fun name -> term -> (term -> term) -> term.
type fun (term -> term) -> term.
type funclass class.
type gc.compact (func).
type gc.full (func).
type gc.get (func -> int, int, int, int, int, int, int, int).
type gc.major (func).
type gc.minor (func).
type gc.quick-stat (func
                     ->
                         float,
                                 float,
                                         float,
                                                 int,
                                                       int,
                                                             int,
                                                                   int,
                                                                   
                                                                    int,
                                                                     int,
                                                                     int).
type gc.set (func int, int, int, int, int, int, int, int).
type gc.stat (func
               ->
                   float,
                           float,
                                   float,
                                           int,
                                                 int,
                                                       int,
                                                             int,
                                                                   int,
                                                                   
                                                                    int,
                                                                    
                                                                    int,
                                                                    
                                                                    int,
                                                                    
                                                                    int,
                                                                    
                                                                    int,
                                                                    
                                                                    int,
                                                                     int,
                                                                     int).
type ge_ (func A, A).
type get-option (pred o:string, o:A).
type getenv (func string -> option string).
type gettimeofday (func -> float).
type global gref -> term.
type goal goal-ctx -> term -> term -> term -> list argument -> goal.
type gref gref -> module-item.
type grefclass gref -> class.
type ground_term (func any).
type gt cmp.
type gt_ (func A, A).
type halt variadic any (func).
type (i+) int -> int -> int.
type (i-) int -> int -> int.
type (i<) (func int, int).
type (i=<) (func int, int).
type (i>) (func int, int).
type (i>=) (func int, int).
type iabs int -> int.
type if (func (pred), (func), (func)).
type if2 (func (pred), (func), (pred), (func), (func)).
type implicit implicit_kind.
type import-module modpath -> synterp-action.
type in argument_mode.
type include-module modpath -> synterp-action.
type include-module-type modtypath -> synterp-action.
type indc constructor -> gref.
type indt inductive -> gref.
type indt-decl indt-decl -> argument.
type inductive id -> bool -> arity -> (term -> list indc-decl) -> indt-decl.
type input (func in_stream, int -> string).
type input_line (func in_stream -> string).
type int int -> argument.
type int_to_real int -> float.
type int_to_string int -> string.
type invariant univ.variable -> univ-variance.
type irrelevant univ.variable -> univ-variance.
type (is) (pred o:A, i:A).
type (is_cdata) (func any -> string).
type (i~) int -> int.
type le univ.variable -> univ.variable -> univ-constraint.
type le_ (func A, A).
type leaf-loc loc -> attribute-value.
type leaf-str string -> attribute-value.
type let name -> term -> term -> (term -> term) -> term.
type level int -> conversion_strategy.
type library scope.
type ln float -> float.
type loc-abbreviation abbreviation -> located.
type loc-gref gref -> located.
type loc-modpath modpath -> located.
type loc-modtypath modtypath -> located.
type loc.fields (func loc -> string, int, int, int, int).
type lookahead (func in_stream -> string).
type lt cmp.
type lt univ.variable -> univ.variable -> univ-constraint.
type lt_ (func A, A).
type main (pred i:list argument).
type main-interp (pred i:list argument, i:any).
type main-interp-proof (pred i:list argument, i:any, o:term, o:any).
type main-interp-qed (pred i:list argument, i:any, i:term, i:any).
type main-synterp (pred i:list argument, o:any).
type match term -> term -> list term -> term.
type max float -> float -> float.
type max int -> int -> int.
type maximal implicit_kind.
type min float -> float -> float.
type min int -> int -> int.
type (mod) int -> int -> int.
type (mode-ground) hint-mode.
type (mode-input) hint-mode.
type (mode-output) hint-mode.
type (module-functor) modpath -> list modtypath -> module-item.
type (module-type) modtypath -> module-item.
type (module-type-functor) modtypath -> list modtypath -> module-item.
type msolve (pred i:list sealed-goal, o:list sealed-goal).
type nabla (term -> sealed-goal) -> sealed-goal.
type name (func -> any, any).
type names (func -> list any).
type never simplification_strategy.
type new_int (func -> int).
type new_safe (func -> safe).
type node list attribute -> attribute-value.
type none option A.
type not (func (pred)).
type occurs (func any, any).
type of (pred i:term, o:ty).
type off coercion-status.
type ok diagnostic.
type opaque conversion_strategy.
type open-trm int -> term -> argument.
type open_append (func string -> out_stream).
type open_in (func string -> in_stream).
type open_out (func string -> out_stream).
type open_safe (func safe -> list A).
type open_string (func string -> in_stream).
type out argument_mode.
type output (func out_stream, string).
type parameter id -> implicit_kind -> term -> (term -> arity) -> arity.
type parameter id ->
                 implicit_kind -> term -> (term -> indt-decl) -> indt-decl.
type pattern_match (func A -> A).
type pglobal gref -> univ-instance -> term.
type pi (func ((func A))).
type pr A -> B -> pair A B.
type primitive primitive-value -> term.
type primitive? (func any, string).
type print variadic any (func).
type print_constraints (func).
type printterm (pred i:out_stream, i:A).
type prod name -> term -> (term -> term) -> term.
type proj projection -> int -> primitive-value.
type prop sort.
type prune (pred o:any, i:list any).
type pstring pstring -> primitive-value.
type (r+) float -> float -> float.
type (r-) float -> float -> float.
type (r<) (func float, float).
type (r=<) (func float, float).
type (r>) (func float, float).
type (r>=) (func float, float).
type rabs float -> float.
type random.init (func int).
type random.int (func int -> int).
type random.self_init (func).
type real_to_string float -> string.
type record id -> term -> id -> record-decl -> indt-decl.
type regular coercion-status.
type remove id -> grafting.
type replace id -> grafting.
type reversible coercion-status.
type rex.match (func string, string).
type rex.replace (func string, string, string -> string).
type rex.split (func string, string -> list string).
type rex_match (func string, string).
type rex_replace (func string, string, string -> string).
type rex_split (func string, string -> list string).
type rhc string -> int.
type rm-evar (func term, term).
type (r~) float -> float.
type (s<) (func string, string).
type (s=<) (func string, string).
type (s>) (func string, string).
type (s>=) (func string, string).
type same_term (func A, A).
type same_var (func A, A).
type seal goal -> sealed-goal.
type sigma (func ((func A))).
type sin float -> float.
type size string -> int.
type snd (func pair A B -> B).
type solve (pred i:goal, o:list sealed-goal).
type some A -> option A.
type sort sort -> term.
type sortclass class.
type sprop sort.
type sqrt float -> float.
type stash_in_safe (func safe, A).
type std.any->string (func A -> string).
type std.append (func list A, list A -> list A).
type std.appendR (pred o:list A, o:list A, o:list A).
type std.assert! (func (pred), string).
type std.assert-ok! (func ((pred o:diagnostic)), string).
type std.debug-print (func string, any).
type std.do! (func list (pred)).
type std.do-ok! (pred o:diagnostic, i:list ((pred o:diagnostic))).
type std.drop (func int, list A -> list A).
type std.drop-last (func int, list A -> list A).
type std.exists (pred i:list A, i:((pred i:A))).
type std.exists! (func list A, ((pred i:A))).
type std.exists2 (pred i:list A, i:list B, i:((pred i:A, i:B))).
type std.fatal-error (func string).
type std.fatal-error-w-data (func string, any).
type std.filter (func list A, ((func A)) -> list A).
type std.findall (func (pred) -> list (pred)).
type std.flatten (func list (list A) -> list A).
type std.flip (func ((func A, B)), B, A).
type std.fold (func list B, A, ((func B, A -> A)) -> A).
type std.fold-map (func list A, B, ((func A, B -> C, B)) -> list C, B).
type std.fold-right (func list B, A, ((func B, A -> A)) -> A).
type std.fold2 (func list C, list B, A, ((func C, B, A -> A)) -> A).
type std.forall (func list A, ((func A))).
type std.forall-ok (func list A, ((func A -> diagnostic)) -> diagnostic).
type std.forall2 (func list A, list B, ((func A, B))).
type std.ignore-failure! (func (pred)).
type std.int.map.add (func int, A, std.int.map A -> std.int.map A).
type std.int.map.bindings (func std.int.map A -> list (pair int A)).
type std.int.map.empty (func -> std.int.map A).
type std.int.map.filter (func
                               std.int.map A, ((pred o:int, o:A))
                                               -> std.int.map A).
type std.int.map.find (func int, std.int.map A -> A).
type std.int.map.fold (func
                             std.int.map A,
                                             C, ((pred o:int, o:A, o:C, o:C))
                                                 -> C).
type std.int.map.map (func
                            std.int.map A, ((pred o:int, o:A, o:B))
                                            -> std.int.map B).
type std.int.map.mem (func int, std.int.map A).
type std.int.map.remove (func int, std.int.map A -> std.int.map A).
type std.int.set.add (func int, std.int.set -> std.int.set).
type std.int.set.cardinal (func std.int.set -> int).
type std.int.set.choose (func std.int.set -> int).
type std.int.set.diff (func std.int.set, std.int.set -> std.int.set).
type std.int.set.elements (func std.int.set -> list int).
type std.int.set.empty (func -> std.int.set).
type std.int.set.equal (func std.int.set, std.int.set).
type std.int.set.filter (func std.int.set, ((func -> int)) -> std.int.set).
type std.int.set.fold (func std.int.set, A, ((pred o:int, o:A, o:A)) -> A).
type std.int.set.inter (func std.int.set, std.int.set -> std.int.set).
type std.int.set.map (func std.int.set, ((pred o:int, o:int)) -> std.int.set).
type std.int.set.max (func std.int.set -> int).
type std.int.set.mem (func int, std.int.set).
type std.int.set.min (func std.int.set -> int).
type std.int.set.partition (func
                                  std.int.set, ((func -> int))
                                                -> std.int.set, std.int.set).
type std.int.set.remove (func int, std.int.set -> std.int.set).
type std.int.set.subset (func std.int.set, std.int.set).
type std.int.set.union (func std.int.set, std.int.set -> std.int.set).
type std.intersperse (func A, list A -> list A).
type std.iota (func int -> list int).
type std.last (func list A -> A).
type std.length (func list A -> int).
type std.lift-ok (pred i:(pred), i:string, o:diagnostic).
type std.list.init (func int, ((func int -> A)) -> list A).
type std.list.init.aux (func int, int, ((func int -> A)) -> list A).
type std.list.make (func int, A -> list A).
type std.loc.map.add (func loc, A, std.loc.map A -> std.loc.map A).
type std.loc.map.bindings (func std.loc.map A -> list (pair loc A)).
type std.loc.map.empty (func -> std.loc.map A).
type std.loc.map.filter (func
                               std.loc.map A, ((pred o:loc, o:A))
                                               -> std.loc.map A).
type std.loc.map.find (func loc, std.loc.map A -> A).
type std.loc.map.fold (func
                             std.loc.map A,
                                             C, ((pred o:loc, o:A, o:C, o:C))
                                                 -> C).
type std.loc.map.map (func
                            std.loc.map A, ((pred o:loc, o:A, o:B))
                                            -> std.loc.map B).
type std.loc.map.mem (func loc, std.loc.map A).
type std.loc.map.remove (func loc, std.loc.map A -> std.loc.map A).
type std.loc.set.add (func loc, std.loc.set -> std.loc.set).
type std.loc.set.cardinal (func std.loc.set -> int).
type std.loc.set.choose (func std.loc.set -> loc).
type std.loc.set.diff (func std.loc.set, std.loc.set -> std.loc.set).
type std.loc.set.elements (func std.loc.set -> list loc).
type std.loc.set.empty (func -> std.loc.set).
type std.loc.set.equal (func std.loc.set, std.loc.set).
type std.loc.set.filter (func std.loc.set, ((func -> loc)) -> std.loc.set).
type std.loc.set.fold (func std.loc.set, A, ((pred o:loc, o:A, o:A)) -> A).
type std.loc.set.inter (func std.loc.set, std.loc.set -> std.loc.set).
type std.loc.set.map (func std.loc.set, ((pred o:loc, o:loc)) -> std.loc.set).
type std.loc.set.max (func std.loc.set -> loc).
type std.loc.set.mem (func loc, std.loc.set).
type std.loc.set.min (func std.loc.set -> loc).
type std.loc.set.partition (func
                                  std.loc.set, ((func -> loc))
                                                -> std.loc.set, std.loc.set).
type std.loc.set.remove (func loc, std.loc.set -> std.loc.set).
type std.loc.set.subset (func std.loc.set, std.loc.set).
type std.loc.set.union (func std.loc.set, std.loc.set -> std.loc.set).
type std.lookup (pred i:list (pair A B), i:A, o:B).
type std.lookup! (func list (pair A B), A -> B).
type std.map std.map.private.map K V -> ((func K, K -> cmp)) -> std.map K V.
type std.map (func list A, ((func A -> B)) -> list B).
type std.map-filter (func list A, ((func A -> B)) -> list B).
type std.map-i (func list A, ((func int, A -> B)) -> list B).
type std.map-i.aux (func list A, int, ((func int, A -> B)) -> list B).
type std.map-ok (func
                       list A, ((func A -> B, diagnostic))
                                -> list B, diagnostic).
type std.map.add (func K, V, std.map K V -> std.map K V).
type std.map.bindings (func std.map K V -> list (pair K V)).
type std.map.find (func K, std.map K V -> V).
type std.map.make (func ((func K, K -> cmp)) -> std.map K V).
type std.map.private.add (func
                                std.map.private.map K V,
                                                          ((func K, K -> cmp)),
                                                          
                                                            K, V
                                                                ->
                                                                    std.map.private.map
                                                                    K V).
type std.map.private.add.aux (func
                                    cmp,
                                          std.map.private.map K V,
                                                                    (
                                                                    (func
                                                                    
                                                                    K, K
                                                                    -> cmp)),
                                                                    
                                                                    K, V
                                                                    ->
                                                                    std.map.private.map
                                                                    K V).
type std.map.private.bal (func
                                std.map.private.map K V,
                                                          K,
                                                              V,
                                                                  std.map.private.map
                                                                    K V
                                                                  ->
                                                                    std.map.private.map
                                                                    K V).
type std.map.private.bal.aux (func
                                    int,
                                          int,
                                                int,
                                                      int,
                                                            std.map.private.map
                                                              K V,
                                                                    K,
                                                                    
                                                                    V,
                                                                    std.map.private.map
                                                                    K V
                                                                    ->
                                                                    std.map.private.map
                                                                    K V).
type std.map.private.bindings (func
                                     std.map.private.map K V, list (pair K V)
                                                               ->
                                                                   list
                                                                    (pair K V)).
type std.map.private.create (func
                                   std.map.private.map K V,
                                                             K,
                                                                 V,
                                                                    std.map.private.map
                                                                    K V
                                                                    ->
                                                                    
                                                                    std.map.private.map
                                                                    K V).
type std.map.private.empty std.map.private.map K V.
type std.map.private.find (func
                                 std.map.private.map K V,
                                                           ((func K, K -> cmp)),
                                                            K -> V).
type std.map.private.find.aux (func
                                     cmp,
                                           ((func K, K -> cmp)),
                                                                  std.map.private.map
                                                                    K V,
                                                                  
                                                                    std.map.private.map
                                                                    K V,
                                                                    
                                                                    V, K -> V).
type std.map.private.height (func std.map.private.map K V -> int).
type std.map.private.merge (func
                                  std.map.private.map K V,
                                                            std.map.private.map
                                                              K V
                                                            ->
                                                                std.map.private.map
                                                                  K V).
type std.map.private.min-binding (func std.map.private.map K V -> K, V).
type std.map.private.node std.map.private.map K V ->
                            K ->
                              V ->
                                std.map.private.map K V ->
                                  int -> std.map.private.map K V.
type std.map.private.remove (func
                                   std.map.private.map K V,
                                                             ((func
                                                                    K,
                                                                     K -> cmp)),
                                                              K
                                                               ->
                                                                   std.map.private.map
                                                                    K V).
type std.map.private.remove-min-binding (func std.map.private.map K V
                                               -> std.map.private.map K V).
type std.map.private.remove.aux (func
                                       cmp,
                                             ((func K, K -> cmp)),
                                                                    std.map.private.map
                                                                    K V,
                                                                    
                                                                    std.map.private.map
                                                                    K V,
                                                                    
                                                                    K,
                                                                    V, K
                                                                    ->
                                                                    std.map.private.map
                                                                    K V).
type std.map.remove (func K, std.map K V -> std.map K V).
type std.map2 (func list A, list B, ((func A, B -> C)) -> list C).
type std.map2-filter (func list A, list B, ((func A, B -> C)) -> list C).
type std.max (func A, A -> A).
type std.mem (pred i:list A, o:A).
type std.mem! (func list A, A).
type std.nth (func int, list A -> A).
type std.null (func list A).
type std.omap (func option A, ((func A -> B)) -> option B).
type std.once (func (pred)).
type std.partition (func list A, ((pred i:A)) -> list A, list A).
type std.rev (func list A -> list A).
type std.rev.aux (func list A, list A -> list A).
type std.set std.set.private.set E -> ((func E, E -> cmp)) -> std.set E.
type std.set.add (func E, std.set E -> std.set E).
type std.set.cardinal (func std.set E -> int).
type std.set.elements (func std.set E -> list E).
type std.set.make (func ((func E, E -> cmp)) -> std.set E).
type std.set.mem (func E, std.set E).
type std.set.private.add (func
                                std.set.private.set E,
                                                        ((func E, E -> cmp)),
                                                         E
                                                          ->
                                                              std.set.private.set
                                                                E).
type std.set.private.add.aux (func
                                    cmp,
                                          ((func E, E -> cmp)),
                                                                 std.set.private.set
                                                                   E,
                                                                 
                                                                   std.set.private.set
                                                                    E,
                                                                   
                                                                    E,
                                                                    
                                                                    E, int
                                                                    ->
                                                                    std.set.private.set
                                                                    E).
type std.set.private.bal (func
                                std.set.private.set E,
                                                        E,
                                                            std.set.private.set
                                                              E
                                                            ->
                                                                std.set.private.set
                                                                  E).
type std.set.private.bal.aux (func
                                    int,
                                          int,
                                                int,
                                                      int,
                                                            std.set.private.set
                                                              E,
                                                                  E,
                                                                    std.set.private.set
                                                                    E
                                                                    ->
                                                                    std.set.private.set
                                                                    E).
type std.set.private.cardinal (func std.set.private.set E -> int).
type std.set.private.create (func
                                   std.set.private.set E,
                                                           E,
                                                               std.set.private.set
                                                                 E
                                                               ->
                                                                   std.set.private.set
                                                                    E).
type std.set.private.elements (func std.set.private.set E, list E -> list E).
type std.set.private.empty std.set.private.set E.
type std.set.private.height (func std.set.private.set E -> int).
type std.set.private.mem (func std.set.private.set E, ((func E, E -> cmp)), E).
type std.set.private.mem.aux (func
                                    cmp,
                                          ((func E, E -> cmp)),
                                                                 std.set.private.set
                                                                   E,
                                                                 
                                                                   std.set.private.set
                                                                    E,
                                                                    E).
type std.set.private.merge (func
                                  std.set.private.set E,
                                                          std.set.private.set
                                                            E
                                                          ->
                                                              std.set.private.set
                                                                E).
type std.set.private.min-binding (func std.set.private.set E -> E).
type std.set.private.node std.set.private.set E ->
                            E ->
                              std.set.private.set E ->
                                int -> std.set.private.set E.
type std.set.private.remove (func
                                   std.set.private.set E,
                                                           ((func E, E -> cmp)),
                                                            E
                                                             ->
                                                                 std.set.private.set
                                                                   E).
type std.set.private.remove-min-binding (func std.set.private.set E
                                               -> std.set.private.set E).
type std.set.private.remove.aux (func
                                       cmp,
                                             ((func E, E -> cmp)),
                                                                    std.set.private.set
                                                                    E,
                                                                    
                                                                    std.set.private.set
                                                                    E,
                                                                    E, E
                                                                    ->
                                                                    std.set.private.set
                                                                    E).
type std.set.remove (func E, std.set E -> std.set E).
type std.split-at (func int, list A -> list A, list A).
type std.spy (pred i:(pred)).
type std.spy! (func (pred)).
type std.spy-do! (func list (pred)).
type std.string.concat (func string, list string -> string).
type std.string.map.add (func string, A, std.string.map A -> std.string.map A).
type std.string.map.bindings (func std.string.map A -> list (pair string A)).
type std.string.map.empty (func -> std.string.map A).
type std.string.map.filter (func
                                  std.string.map A, ((pred o:string, o:A))
                                                     -> std.string.map A).
type std.string.map.find (func string, std.string.map A -> A).
type std.string.map.fold (func
                                std.string.map A,
                                                   C,
                                                       ((pred o:string, 
                                                          o:A, o:C, o:C))
                                                       -> C).
type std.string.map.map (func
                               std.string.map A, ((pred o:string, o:A, o:B))
                                                  -> std.string.map B).
type std.string.map.mem (func string, std.string.map A).
type std.string.map.remove (func string, std.string.map A -> std.string.map A).
type std.string.set.add (func string, std.string.set -> std.string.set).
type std.string.set.cardinal (func std.string.set -> int).
type std.string.set.choose (func std.string.set -> string).
type std.string.set.diff (func
                                std.string.set, std.string.set
                                                 -> std.string.set).
type std.string.set.elements (func std.string.set -> list string).
type std.string.set.empty (func -> std.string.set).
type std.string.set.equal (func std.string.set, std.string.set).
type std.string.set.filter (func
                                  std.string.set, ((func -> string))
                                                   -> std.string.set).
type std.string.set.fold (func
                                std.string.set,
                                                 A,
                                                     ((pred o:string, 
                                                        o:A, o:A)) ->
                                                      A).
type std.string.set.inter (func
                                 std.string.set, std.string.set
                                                  -> std.string.set).
type std.string.set.map (func
                               std.string.set, ((pred o:string, o:string))
                                                -> std.string.set).
type std.string.set.max (func std.string.set -> string).
type std.string.set.mem (func string, std.string.set).
type std.string.set.min (func std.string.set -> string).
type std.string.set.partition (func
                                     std.string.set, ((func -> string))
                                                      ->
                                                          std.string.set,
                                                           std.string.set).
type std.string.set.remove (func string, std.string.set -> std.string.set).
type std.string.set.subset (func std.string.set, std.string.set).
type std.string.set.union (func
                                 std.string.set, std.string.set
                                                  -> std.string.set).
type std.take (func int, list A -> list A).
type std.take-last (func int, list A -> list A).
type std.time (func (func) -> float).
type std.unsafe-cast (func A -> B).
type std.unzip (func list (pair A B) -> list A, list B).
type std.while-ok-do! (func
                             diagnostic, list ((pred o:diagnostic))
                                          -> diagnostic).
type std.zip (func list A, list B -> list (pair A B)).
type std_err out_stream.
type std_in in_stream.
type std_out out_stream.
type stop (func).
type str string -> argument.
type string_to_int string -> int.
type submodule modpath -> list module-item -> module-item.
type substring string -> int -> int -> string.
type system (func string -> int).
type tac ltac1-tactic -> argument.
type tc-instance gref -> int -> tc-instance.
type term_to_string (func -> any, string).
type trace.counter (func string -> int).
type triple A -> B -> C -> triple A B C.
type triple_1 (func triple A B C -> A).
type triple_2 (func triple A B C -> B).
type triple_3 (func triple A B C -> C).
type trm term -> argument.
type true (func).
type truncate float -> int.
type tt bool.
type typ univ -> sort.
type uint63 uint63 -> primitive-value.
type unix.process out_stream -> in_stream -> in_stream -> unix.process.
type unix.process.close (func unix.process -> diagnostic).
type unix.process.open (func
                              string,
                                       list string, list string
                                                     ->
                                                         unix.process,
                                                          diagnostic).
type upoly-const-decl id -> option term -> arity -> upoly-decl -> argument.
type upoly-decl list univ.variable ->
                  bool -> list univ-constraint -> bool -> upoly-decl.
type upoly-decl-cumul list univ-variance ->
                        bool -> list univ-constraint -> bool -> upoly-decl.
type upoly-indt-decl indt-decl -> upoly-decl -> argument.
type usage (pred).
type uvar A.
type var (func -> any, any).
type whd (pred i:term, o:term).
type when list int -> option int -> simplification_strategy.
type when-nomatch list int -> option int -> simplification_strategy.
type (~) float -> float.
type (~) int -> int.
typeabbrv field-attributes (list field-attribute).
typeabbrv goal-ctx (list (pred)).
typeabbrv id (string).
typeabbrv opaque? (bool).
% File "elpi-builtin.elpi", line 11, column 0, characters 147-151: [1] 
true :- .
% File "elpi-builtin.elpi", line 36, column 0, characters 460-472: [2] 
A0 ; _ :- A0.
% File "elpi-builtin.elpi", line 38, column 0, characters 475-487: [3] 
_ ; A0 :- A0.
% File "elpi-builtin.elpi", line 64, column 0, characters 1063-1082: [4] 
not A0 :- A0, !, fail.
% File "elpi-builtin.elpi", line 66, column 0, characters 1085-1090: [5] 
not _ :- .
% File "elpi-builtin.elpi", line 80, column 0, characters 1436-1448: [6] 
stop :- halt.
% File "elpi-builtin.elpi", line 86, column 0, characters 1505-1523: [7] 
A1 is A0 :- calc A0 A1.
% File "elpi-builtin.elpi", line 191, column 0, characters 4097-4113: [8] 
A0 > A1 :- gt_ A0 A1.
% File "elpi-builtin.elpi", line 194, column 0, characters 4131-4147: [9] 
A0 < A1 :- lt_ A0 A1.
% File "elpi-builtin.elpi", line 197, column 0, characters 4166-4183: [10] 
A0 =< A1 :- le_ A0 A1.
% File "elpi-builtin.elpi", line 200, column 0, characters 4202-4219: [11] 
A0 >= A1 :- ge_ A0 A1.
% File "elpi-builtin.elpi", line 203, column 0, characters 4242-4259: [12] 
A0 i> A1 :- gt_ A0 A1.
% File "elpi-builtin.elpi", line 206, column 0, characters 4282-4299: [13] 
A0 i< A1 :- lt_ A0 A1.
% File "elpi-builtin.elpi", line 209, column 0, characters 4323-4341: [14] 
A0 i=< A1 :- le_ A0 A1.
% File "elpi-builtin.elpi", line 212, column 0, characters 4365-4383: [15] 
A0 i>= A1 :- ge_ A0 A1.
% File "elpi-builtin.elpi", line 215, column 0, characters 4410-4427: [16] 
A0 r> A1 :- gt_ A0 A1.
% File "elpi-builtin.elpi", line 218, column 0, characters 4454-4471: [17] 
A0 r< A1 :- lt_ A0 A1.
% File "elpi-builtin.elpi", line 221, column 0, characters 4499-4517: [18] 
A0 r=< A1 :- le_ A0 A1.
% File "elpi-builtin.elpi", line 224, column 0, characters 4545-4563: [19] 
A0 r>= A1 :- ge_ A0 A1.
% File "elpi-builtin.elpi", line 227, column 0, characters 4592-4609: [20] 
A0 s> A1 :- gt_ A0 A1.
% File "elpi-builtin.elpi", line 230, column 0, characters 4638-4655: [21] 
A0 s< A1 :- lt_ A0 A1.
% File "elpi-builtin.elpi", line 233, column 0, characters 4685-4703: [22] 
A0 s=< A1 :- le_ A0 A1.
% File "elpi-builtin.elpi", line 236, column 0, characters 4733-4751: [23] 
A0 s>= A1 :- ge_ A0 A1.
% File "elpi-builtin.elpi", line 257, column 0, characters 5245-5259: [24] 
fst (pr A0 _) A0 :- .
% File "elpi-builtin.elpi", line 261, column 0, characters 5288-5302: [25] 
snd (pr _ A0) A0 :- .
% File "elpi-builtin.elpi", line 268, column 0, characters 5423-5448: [26] 
triple_1 (triple A0 _ _) A0 :- .
% File "elpi-builtin.elpi", line 271, column 0, characters 5484-5509: [27] 
triple_2 (triple _ A0 _) A0 :- .
% File "elpi-builtin.elpi", line 274, column 0, characters 5545-5570: [28] 
triple_3 (triple _ _ A0) A0 :- .
% File "elpi-builtin.elpi", line 304, column 0, characters 6339-6371: [29] 
counter A0 A1 :- trace.counter A0 A1.
% File "elpi-builtin.elpi", line 330, column 0, characters 7221-7253: [30] 
rex_match A0 A1 :- rex.match A0 A1.
% File "elpi-builtin.elpi", line 334, column 0, characters 7337-7381: [31] 
rex_replace A0 A1 A2 A3 :- rex.replace A0 A1 A2 A3.
% File "elpi-builtin.elpi", line 338, column 0, characters 7458-7494: [32] 
rex_split A0 A1 A2 :- rex.split A0 A1 A2.
% File "elpi-builtin.elpi", line 369, column 0, characters 8609-8632: [33] 
A0 == A1 :- same_term A0 A1.
% File "elpi-builtin.elpi", line 402, column 0, characters 9757-9787: [34] 
primitive? A0 A1 :- A0 is_cdata A1.
% File "elpi-builtin.elpi", line 432, column 0, characters 10756-10775: [35] 
if A0 A1 _ :- A0, !, A1.
% File "elpi-builtin.elpi", line 433, column 0, characters 10777-10790: [36] 
if _ _ A0 :- A0.
% File "elpi-builtin.elpi", line 437, column 0, characters 10920-10950: [37] 
if2 A0 A1 _ _ _ :- A0, !, A1.
% File "elpi-builtin.elpi", line 438, column 0, characters 10952-10982: [38] 
if2 _ _ A0 A1 _ :- A0, !, A1.
% File "elpi-builtin.elpi", line 439, column 0, characters 10984-11009: [39] 
if2 _ _ _ _ A0 :- !, A0.
% File "builtin_stdlib.elpi", line 17, column 0, characters 657-712: [40] default-fatal-error
std.fatal-error A0 :- halt A0.
% File "builtin_stdlib.elpi", line 21, column 0, characters 752-835: [41] default-fatal-error-w-data
std.fatal-error-w-data A0 A1 :- halt A0 : A1.
% File "builtin_stdlib.elpi", line 25, column 0, characters 868-934: [42] default-debug-print
std.debug-print A0 A1 :- print A0 A1.
% File "builtin_stdlib.elpi", line 31, column 0, characters 1002-1027: [43] 
std.ignore-failure! A0 :- A0, !.
% File "builtin_stdlib.elpi", line 32, column 0, characters 1029-1046: [44] 
std.ignore-failure! _ :- .
% File "builtin_stdlib.elpi", line 35, column 0, characters 1068-1082: [45] 
std.once A0 :- A0, !.
% File "builtin_stdlib.elpi", line 39, column 0, characters 1182-1241: [46] 
std.assert! A0 A1 :- A0 ; std.fatal-error-w-data A1 A0, !.
% File "builtin_stdlib.elpi", line 44, column 0, characters 1428-1540: [47] 
std.assert-ok! A1 A3 :- A1 A0, !, 
 A0 = ok ; A0 = error A2 , std.fatal-error-w-data A3 A2, !.
% File "builtin_stdlib.elpi", line 45, column 0, characters 1542-1609: [48] 
std.assert-ok! _ A0 :- std.fatal-error-w-data A0 no diagnostic returned.
% File "builtin_stdlib.elpi", line 49, column 0, characters 1704-1883: [49] 
std.spy A1 :- trace.counter run A0, 
 if (not (A0 = 0)) (std.debug-print run= A0) true, 
 std.debug-print ----<<---- enter:  A1, A1, 
 std.debug-print ---->>---- exit:  A1.
% File "builtin_stdlib.elpi", line 53, column 0, characters 1885-1933: [50] 
std.spy A0 :- std.debug-print ---->>---- fail:  A0, fail.
% File "builtin_stdlib.elpi", line 57, column 0, characters 2021-2204: [51] 
std.spy! A1 :- trace.counter run A0, 
 if (not (A0 = 0)) (std.debug-print run= A0) true, 
 std.debug-print ----<<---- enter:  A1, A1, 
 std.debug-print ---->>---- exit:  A1, !.
% File "builtin_stdlib.elpi", line 61, column 0, characters 2206-2255: [52] 
std.spy! A0 :- std.debug-print ---->>---- fail:  A0, fail.
% File "builtin_stdlib.elpi", line 65, column 0, characters 2313-2337: [53] 
std.unsafe-cast A0 A0 :- .
% File "builtin_stdlib.elpi", line 70, column 0, characters 2392-2434: [54] 
std.length [_ | A0] A2 :- std.length A0 A1, A2 is A1 + 1.
% File "builtin_stdlib.elpi", line 71, column 0, characters 2436-2450: [55] 
std.length [] 0 :- .
% File "builtin_stdlib.elpi", line 74, column 0, characters 2480-2509: [56] 
std.rev A0 A1 :- std.rev.aux A0 [] A1.
% File "builtin_stdlib.elpi", line 77, column 0, characters 2551-2595: [57] 
std.rev.aux [A1 | A0] A2 A3 :- std.rev.aux A0 [A1 | A2] A3.
% File "builtin_stdlib.elpi", line 78, column 0, characters 2597-2611: [58] 
std.rev.aux [] A0 A0 :- .
% File "builtin_stdlib.elpi", line 81, column 0, characters 2637-2682: [59] 
std.last [] _ :- std.fatal-error last on empty list.
% File "builtin_stdlib.elpi", line 82, column 0, characters 2684-2699: [60] 
std.last [A0] A0 :- !.
% File "builtin_stdlib.elpi", line 83, column 0, characters 2701-2727: [61] 
std.last [_ | A0] A1 :- std.last A0 A1.
% File "builtin_stdlib.elpi", line 86, column 0, characters 2768-2808: [62] 
std.append [A3 | A0] A1 [A3 | A2] :- std.append A0 A1 A2.
% File "builtin_stdlib.elpi", line 87, column 0, characters 2811-2824: [63] 
std.append [] A0 A0 :- .
% File "builtin_stdlib.elpi", line 90, column 0, characters 2868-2882: [64] 
std.appendR [] A0 A0 :- .
% File "builtin_stdlib.elpi", line 91, column 0, characters 2884-2926: [65] 
std.appendR [A3 | A0] A1 [A3 | A2] :- std.appendR A0 A1 A2.
% File "builtin_stdlib.elpi", line 94, column 0, characters 2962-2978: [66] 
std.take 0 _ [] :- !.
% File "builtin_stdlib.elpi", line 95, column 0, characters 2980-3031: [67] 
std.take A1 [A4 | A2] [A4 | A3] :- !, A0 is A1 - 1, std.take A0 A2 A3.
% File "builtin_stdlib.elpi", line 96, column 0, characters 3033-3087: [68] 
std.take _ _ _ :- std.fatal-error take run out of list items.
% File "builtin_stdlib.elpi", line 99, column 0, characters 3128-3187: [69] 
std.take-last A3 A0 A4 :- std.length A0 A1, A2 is A1 - A3, std.drop A2 A0 A4.
% File "builtin_stdlib.elpi", line 105, column 0, characters 3223-3238: [70] 
std.drop 0 A0 A0 :- !.
% File "builtin_stdlib.elpi", line 106, column 0, characters 3240-3287: [71] 
std.drop A1 [_ | A2] A3 :- !, A0 is A1 - 1, std.drop A0 A2 A3.
% File "builtin_stdlib.elpi", line 107, column 0, characters 3289-3343: [72] 
std.drop _ _ _ :- std.fatal-error drop run out of list items.
% File "builtin_stdlib.elpi", line 110, column 0, characters 3384-3439: [73] 
std.drop-last A3 A0 A4 :- std.length A0 A1, A2 is A1 - A3, std.take A2 A0 A4.
% File "builtin_stdlib.elpi", line 114, column 0, characters 3487-3509: [74] 
std.split-at 0 A0 [] A0 :- !.
% File "builtin_stdlib.elpi", line 115, column 0, characters 3511-3578: [75] 
std.split-at A1 [A5 | A2] [A5 | A3] A4 :- !, A0 is A1 - 1, 
 std.split-at A0 A2 A3 A4.
% File "builtin_stdlib.elpi", line 116, column 0, characters 3580-3644: [76] 
std.split-at _ _ _ _ :- std.fatal-error split-at run out of list items.
% File "builtin_stdlib.elpi", line 119, column 0, characters 3691-3704: [77] 
std.fold [] A0 _ A0 :- .
% File "builtin_stdlib.elpi", line 120, column 0, characters 3706-3751: [78] 
std.fold [A0 | A4] A1 A3 A5 :- A3 A0 A1 A2, std.fold A4 A2 A3 A5.
% File "builtin_stdlib.elpi", line 123, column 0, characters 3804-3823: [79] 
std.fold-right [] A0 _ A0 :- .
% File "builtin_stdlib.elpi", line 124, column 0, characters 3825-3882: [80] 
std.fold-right [A4 | A0] A1 A2 A5 :- std.fold-right A0 A1 A2 A3, A2 A4 A3 A5.
% File "builtin_stdlib.elpi", line 128, column 0, characters 3954-4026: [81] 
std.fold2 [] [_ | _] _ _ _ :- std.fatal-error
                               fold2 on lists of different length.
% File "builtin_stdlib.elpi", line 129, column 0, characters 4028-4100: [82] 
std.fold2 [_ | _] [] _ _ _ :- std.fatal-error
                               fold2 on lists of different length.
% File "builtin_stdlib.elpi", line 130, column 0, characters 4102-4119: [83] 
std.fold2 [] [] A0 _ A0 :- .
% File "builtin_stdlib.elpi", line 131, column 0, characters 4121-4180: [84] 
std.fold2 [A0 | A5] [A1 | A6] A2 A4 A7 :- A4 A0 A1 A2 A3, 
 std.fold2 A5 A6 A3 A4 A7.
% File "builtin_stdlib.elpi", line 134, column 0, characters 4225-4236: [85] 
std.map [] _ [] :- .
% File "builtin_stdlib.elpi", line 135, column 0, characters 4238-4279: [86] 
std.map [A0 | A3] A2 [A1 | A4] :- A2 A0 A1, std.map A3 A2 A4.
% File "builtin_stdlib.elpi", line 138, column 0, characters 4331-4363: [87] 
std.map-i A0 A1 A2 :- std.map-i.aux A0 0 A1 A2.
% File "builtin_stdlib.elpi", line 141, column 0, characters 4424-4443: [88] 
std.map-i.aux [] _ _ [] :- .
% File "builtin_stdlib.elpi", line 142, column 0, characters 4445-4516: [89] 
std.map-i.aux [A1 | A5] A0 A3 [A2 | A6] :- A3 A0 A1 A2, A4 is A0 + 1, 
 std.map-i.aux A5 A4 A3 A6.
% File "builtin_stdlib.elpi", line 145, column 0, characters 4568-4586: [90] 
std.map-filter [] _ [] :- .
% File "builtin_stdlib.elpi", line 146, column 0, characters 4588-4646: [91] 
std.map-filter [A0 | A3] A2 [A1 | A4] :- A2 A0 A1, !, 
 std.map-filter A3 A2 A4.
% File "builtin_stdlib.elpi", line 147, column 0, characters 4648-4692: [92] 
std.map-filter [_ | A0] A1 A2 :- std.map-filter A0 A1 A2.
% File "builtin_stdlib.elpi", line 151, column 0, characters 4761-4829: [93] 
std.map2 [] [_ | _] _ _ :- std.fatal-error map2 on lists of different length.
% File "builtin_stdlib.elpi", line 152, column 0, characters 4831-4899: [94] 
std.map2 [_ | _] [] _ _ :- std.fatal-error map2 on lists of different length.
% File "builtin_stdlib.elpi", line 153, column 0, characters 4901-4916: [95] 
std.map2 [] [] _ [] :- .
% File "builtin_stdlib.elpi", line 154, column 0, characters 4918-4973: [96] 
std.map2 [A0 | A4] [A1 | A5] A3 [A2 | A6] :- A3 A0 A1 A2, 
 std.map2 A4 A5 A3 A6.
% File "builtin_stdlib.elpi", line 157, column 0, characters 5037-5119: [97] 
std.map2-filter [] [_ | _] _ _ :- std.fatal-error
                                   map2-filter on lists of different length.
% File "builtin_stdlib.elpi", line 158, column 0, characters 5121-5203: [98] 
std.map2-filter [_ | _] [] _ _ :- std.fatal-error
                                   map2-filter on lists of different length.
% File "builtin_stdlib.elpi", line 159, column 0, characters 5205-5227: [99] 
std.map2-filter [] [] _ [] :- .
% File "builtin_stdlib.elpi", line 160, column 0, characters 5229-5301: [100] 
std.map2-filter [A0 | A4] [A1 | A5] A3 [A2 | A6] :- A3 A0 A1 A2, !, 
 std.map2-filter A4 A5 A3 A6.
% File "builtin_stdlib.elpi", line 161, column 0, characters 5303-5359: [101] 
std.map2-filter [_ | A0] [_ | A1] A2 A3 :- std.map2-filter A0 A1 A2 A3.
% File "builtin_stdlib.elpi", line 164, column 0, characters 5431-5507: [102] 
std.map-ok [A0 | A4] A3 [A1 | A5] A6 :- A3 A0 A1 A2, 
 if (A2 = ok) (std.map-ok A4 A3 A5 A6) (A6 = A2).
% File "builtin_stdlib.elpi", line 165, column 0, characters 5509-5526: [103] 
std.map-ok [] _ [] ok :- .
% File "builtin_stdlib.elpi", line 168, column 0, characters 5588-5608: [104] 
std.fold-map [] A0 _ [] A0 :- .
% File "builtin_stdlib.elpi", line 169, column 0, characters 5610-5677: [105] 
std.fold-map [A0 | A5] A1 A4 [A2 | A6] A7 :- A4 A0 A1 A2 A3, 
 std.fold-map A5 A3 A4 A6 A7.
% File "builtin_stdlib.elpi", line 172, column 0, characters 5727-5743: [106] 
std.omap none _ none :- .
% File "builtin_stdlib.elpi", line 173, column 0, characters 5745-5778: [107] 
std.omap (some A0) A2 (some A1) :- A2 A0 A1.
% File "builtin_stdlib.elpi", line 177, column 0, characters 5881-5907: [108] 
std.nth 0 [A0 | _] A1 :- !, A0 = A1.
% File "builtin_stdlib.elpi", line 178, column 0, characters 5909-5961: [109] 
std.nth A0 [_ | A2] A3 :- A0 > 0, !, A1 is A0 - 1, std.nth A1 A2 A3.
% File "builtin_stdlib.elpi", line 179, column 0, characters 5963-6024: [110] 
std.nth A0 _ _ :- A0 < 0, !, std.fatal-error nth got a negative index.
% File "builtin_stdlib.elpi", line 180, column 0, characters 6026-6078: [111] 
std.nth _ _ _ :- std.fatal-error nth run out of list items.
% File "builtin_stdlib.elpi", line 184, column 0, characters 6163-6184: [112] 
std.lookup [pr A0 A1 | _] A0 A1 :- .
% File "builtin_stdlib.elpi", line 185, column 0, characters 6186-6224: [113] 
std.lookup [_ | A0] A1 A2 :- std.lookup A0 A1 A2.
% File "builtin_stdlib.elpi", line 189, column 0, characters 6339-6366: [114] 
std.lookup! [pr A0 A1 | _] A0 A1 :- !.
% File "builtin_stdlib.elpi", line 190, column 0, characters 6368-6408: [115] 
std.lookup! [_ | A0] A1 A2 :- std.lookup! A0 A1 A2.
% File "builtin_stdlib.elpi", line 194, column 0, characters 6484-6501: [116] 
std.mem! [A0 | _] A0 :- !.
% File "builtin_stdlib.elpi", line 195, column 0, characters 6503-6527: [117] 
std.mem! [_ | A0] A1 :- std.mem! A0 A1.
% File "builtin_stdlib.elpi", line 199, column 0, characters 6606-6617: [118] 
std.mem [A0 | _] A0 :- .
% File "builtin_stdlib.elpi", line 200, column 0, characters 6619-6641: [119] 
std.mem [_ | A0] A1 :- std.mem A0 A1.
% File "builtin_stdlib.elpi", line 203, column 0, characters 6675-6701: [120] 
std.exists! [A0 | _] A1 :- A1 A0, !.
% File "builtin_stdlib.elpi", line 204, column 0, characters 6703-6735: [121] 
std.exists! [_ | A0] A1 :- std.exists! A0 A1.
% File "builtin_stdlib.elpi", line 207, column 0, characters 6769-6790: [122] 
std.exists [A0 | _] A1 :- A1 A0.
% File "builtin_stdlib.elpi", line 208, column 0, characters 6792-6820: [123] 
std.exists [_ | A0] A1 :- std.exists A0 A1.
% File "builtin_stdlib.elpi", line 211, column 0, characters 6865-6937: [124] 
std.exists2 [] [_ | _] _ :- std.fatal-error
                             exists2 on lists of different length.
% File "builtin_stdlib.elpi", line 212, column 0, characters 6939-7011: [125] 
std.exists2 [_ | _] [] _ :- std.fatal-error
                             exists2 on lists of different length.
% File "builtin_stdlib.elpi", line 213, column 0, characters 7013-7043: [126] 
std.exists2 [A0 | _] [A1 | _] A2 :- A2 A0 A1.
% File "builtin_stdlib.elpi", line 214, column 0, characters 7045-7083: [127] 
std.exists2 [_ | A0] [_ | A1] A2 :- std.exists2 A0 A1 A2.
% File "builtin_stdlib.elpi", line 217, column 0, characters 7116-7127: [128] 
std.forall [] _ :- .
% File "builtin_stdlib.elpi", line 218, column 0, characters 7129-7162: [129] 
std.forall [A0 | A2] A1 :- A1 A0, std.forall A2 A1.
% File "builtin_stdlib.elpi", line 221, column 0, characters 7226-7296: [130] 
std.forall-ok [A0 | A3] A2 A4 :- A2 A0 A1, 
 if (A1 = ok) (std.forall-ok A3 A2 A4) (A4 = A1).
% File "builtin_stdlib.elpi", line 222, column 0, characters 7298-7315: [131] 
std.forall-ok [] _ ok :- .
% File "builtin_stdlib.elpi", line 225, column 0, characters 7360-7432: [132] 
std.forall2 [] [_ | _] _ :- std.fatal-error
                             forall2 on lists of different length.
% File "builtin_stdlib.elpi", line 226, column 0, characters 7434-7506: [133] 
std.forall2 [_ | _] [] _ :- std.fatal-error
                             forall2 on lists of different length.
% File "builtin_stdlib.elpi", line 227, column 0, characters 7508-7557: [134] 
std.forall2 [A0 | A3] [A1 | A4] A2 :- A2 A0 A1, std.forall2 A3 A4 A2.
% File "builtin_stdlib.elpi", line 228, column 0, characters 7559-7574: [135] 
std.forall2 [] [] _ :- .
% File "builtin_stdlib.elpi", line 231, column 0, characters 7617-7634: [136] 
std.filter [] _ [] :- .
% File "builtin_stdlib.elpi", line 232, column 0, characters 7636-7702: [137] 
std.filter [A0 | A4] A1 A2 :- if (A1 A0) (A2 = [A0 | A3]) (A2 = A3), 
 std.filter A4 A1 A3.
% File "builtin_stdlib.elpi", line 236, column 0, characters 7767-7787: [138] 
std.partition [] _ [] [] :- .
% File "builtin_stdlib.elpi", line 237, column 0, characters 7789-7845: [139] 
std.partition [A0 | A2] A1 [A0 | A3] A4 :- A1 A0, !, 
 std.partition A2 A1 A3 A4.
% File "builtin_stdlib.elpi", line 238, column 0, characters 7847-7895: [140] 
std.partition [A4 | A0] A1 A2 [A4 | A3] :- std.partition A0 A1 A2 A3.
% File "builtin_stdlib.elpi", line 242, column 0, characters 7943-8007: [141] 
std.zip [_ | _] [] _ :- std.fatal-error zip on lists of different length.
% File "builtin_stdlib.elpi", line 243, column 0, characters 8009-8073: [142] 
std.zip [] [_ | _] _ :- std.fatal-error zip on lists of different length.
% File "builtin_stdlib.elpi", line 244, column 0, characters 8075-8120: [143] 
std.zip [A3 | A0] [A4 | A1] [pr A3 A4 | A2] :- std.zip A0 A1 A2.
% File "builtin_stdlib.elpi", line 245, column 0, characters 8122-8134: [144] 
std.zip [] [] [] :- .
% File "builtin_stdlib.elpi", line 248, column 0, characters 8183-8197: [145] 
std.unzip [] [] [] :- .
% File "builtin_stdlib.elpi", line 249, column 0, characters 8199-8246: [146] 
std.unzip [pr A3 A4 | A0] [A3 | A1] [A4 | A2] :- std.unzip A0 A1 A2.
% File "builtin_stdlib.elpi", line 252, column 0, characters 8287-8337: [147] 
std.flatten [A2 | A0] A3 :- std.flatten A0 A1, std.append A2 A1 A3.
% File "builtin_stdlib.elpi", line 253, column 0, characters 8339-8356: [148] 
std.flatten [] [] :- .
% File "builtin_stdlib.elpi", line 256, column 0, characters 8377-8384: [149] 
std.null [] :- .
% File "builtin_stdlib.elpi", line 260, column 0, characters 8471-8492: [150] 
std.list.make 0 _ [] :- !.
% File "builtin_stdlib.elpi", line 261, column 0, characters 8494-8546: [151] 
std.list.make A1 A2 [A2 | A3] :- A0 is A1 - 1, std.list.make A0 A2 A3.
% File "builtin_stdlib.elpi", line 265, column 0, characters 8636-8725: [152] 
std.list.init A0 A1 A2 :- std.assert! (A0 >= 0) list.init: negative length, 
 std.list.init.aux 0 A0 A1 A2.
% File "builtin_stdlib.elpi", line 268, column 0, characters 8784-8811: [153] 
std.list.init.aux A0 A0 _ [] :- !.
% File "builtin_stdlib.elpi", line 269, column 0, characters 8813-8884: [154] 
std.list.init.aux A0 A4 A2 [A1 | A5] :- A2 A0 A1, A3 is A0 + 1, 
 std.list.init.aux A3 A4 A2 A5.
% File "builtin_stdlib.elpi", line 272, column 0, characters 8914-8952: [155] 
std.iota A0 A1 :- std.list.init A0 (c0 \ c1 \ c0 = c1) A1.
% File "builtin_stdlib.elpi", line 277, column 0, characters 9052-9071: [156] 
std.intersperse _ [] [] :- .
% File "builtin_stdlib.elpi", line 278, column 0, characters 9073-9099: [157] 
std.intersperse _ [A0] [A0] :- !.
% File "builtin_stdlib.elpi", line 279, column 0, characters 9101-9159: [158] 
std.intersperse A0 [A3 | A1] [A3, A0 | A2] :- std.intersperse A0 A1 A2.
% File "builtin_stdlib.elpi", line 284, column 0, characters 9206-9225: [159] 
std.flip A2 A1 A0 :- A2 A0 A1.
% File "builtin_stdlib.elpi", line 287, column 0, characters 9255-9330: [160] 
std.time A1 A3 :- gettimeofday A0, A1, gettimeofday A2, A3 is A2 - A0.
% File "builtin_stdlib.elpi", line 290, column 0, characters 9353-9359: [161] 
std.do! [] :- .
% File "builtin_stdlib.elpi", line 291, column 0, characters 9361-9387: [162] 
std.do! [A0 | A1] :- A0, !, std.do! A1.
% File "builtin_stdlib.elpi", line 296, column 0, characters 9468-9480: [163] 
std.do-ok! ok [] :- .
% File "builtin_stdlib.elpi", line 297, column 0, characters 9482-9545: [164] 
std.do-ok! A2 [A1 | A3] :- A1 A0, !, 
 if (A0 = ok) (std.do-ok! A2 A3) (A2 = A0).
% File "builtin_stdlib.elpi", line 300, column 0, characters 9591-9636: [165] 
std.lift-ok A0 A2 A1 :- A0 , A1 = ok ; A1 = error A2.
% File "builtin_stdlib.elpi", line 303, column 0, characters 9663-9708: [166] 
std.spy-do! A0 :- std.map A0 (c0 \ c1 \ c1 = std.spy c0) A1, std.do! A1.
% File "builtin_stdlib.elpi", line 306, column 0, characters 9782-9813: [167] 
std.while-ok-do! (as (error _) A0) _ A0 :- .
% File "builtin_stdlib.elpi", line 307, column 0, characters 9815-9836: [168] 
std.while-ok-do! ok [] ok :- .
% File "builtin_stdlib.elpi", line 308, column 0, characters 9838-9893: [169] 
std.while-ok-do! ok [A1 | A2] A3 :- A1 A0, !, std.while-ok-do! A0 A2 A3.
% File "builtin_stdlib.elpi", line 311, column 0, characters 9926-9963: [170] 
std.any->string A0 A1 :- term_to_string A0 A1.
% File "builtin_stdlib.elpi", line 314, column 0, characters 9986-10008: [171] 
std.max A0 A1 A0 :- A0 >= A1, !.
% File "builtin_stdlib.elpi", line 315, column 0, characters 10010-10019: [172] 
std.max _ A0 A0 :- .
% File "builtin_stdlib.elpi", line 319, column 0, characters 10131-10167: [173] 
std.findall A0 A1 :- findall_solutions A0 A1.
% File "builtin_map.elpi", line 8, column 0, characters 11613-11649: [174] 
std.map.make A0 (std.map std.map.private.empty A0) :- .
% File "builtin_map.elpi", line 12, column 0, characters 11741-11791: [175] 
std.map.find A2 (std.map A0 A1) A3 :- std.map.private.find A0 A1 A2 A3.
% File "builtin_map.elpi", line 16, column 0, characters 11884-11952: [176] 
std.map.add A2 A3 (std.map A0 A1) (std.map A4 A1) :- std.map.private.add A0 
                                                      A1 A2 A3 A4.
% File "builtin_map.elpi", line 20, column 0, characters 12043-12113: [177] 
std.map.remove A2 (std.map A0 A1) (std.map A3 A1) :- std.map.private.remove
                                                      A0 A1 A2 A3.
% File "builtin_map.elpi", line 24, column 0, characters 12224-12275: [178] 
std.map.bindings (std.map A0 _) A1 :- std.map.private.bindings A0 [] A1.
% File "builtin_map.elpi", line 34, column 0, characters 12465-12479: [179] 
std.map.private.height std.map.private.empty 0 :- .
% File "builtin_map.elpi", line 35, column 0, characters 12481-12506: [180] 
std.map.private.height (std.map.private.node _ _ _ _ A0) A0 :- .
% File "builtin_map.elpi", line 38, column 0, characters 12556-12631: [181] 
std.map.private.create A0 A6 A7 A2 (std.map.private.node A0 A6 A7 A2 A5) :- 
 std.map.private.height A0 A1, std.map.private.height A2 A3, 
 std.max A1 A3 A4, A5 is A4 + 1.
% File "builtin_map.elpi", line 41, column 0, characters 12678-12792: [182] 
std.map.private.bal A0 A6 A7 A2 A8 :- std.map.private.height A0 A1, 
 std.map.private.height A2 A3, A4 is A1 + 2, A5 is A3 + 2, 
 std.map.private.bal.aux A1 A3 A4 A5 A0 A6 A7 A2 A8.
% File "builtin_map.elpi", line 49, column 0, characters 12863-12994: [183] 
std.map.private.bal.aux A0 _ _ A1 (std.map.private.node A2 A10 A11 A4 _) A6 
 A7 A8 A12 :- A0 > A1, std.map.private.height A2 A3, 
 std.map.private.height A4 A5, A3 >= A5, !, 
 std.map.private.create A4 A6 A7 A8 A9, 
 std.map.private.create A2 A10 A11 A9 A12.
% File "builtin_map.elpi", line 52, column 0, characters 12996-13143: [184] 
std.map.private.bal.aux A0 _ _ A1 
 (std.map.private.node A2 A3 A4 (std.map.private.node A5 A12 A13 A7 _) _) A8 
 A9 A10 A14 :- A0 > A1, !, std.map.private.create A2 A3 A4 A5 A6, 
 std.map.private.create A7 A8 A9 A10 A11, 
 std.map.private.create A6 A12 A13 A11 A14.
% File "builtin_map.elpi", line 55, column 0, characters 13145-13276: [185] 
std.map.private.bal.aux _ A0 A1 _ A6 A7 A8 
 (std.map.private.node A4 A10 A11 A2 _) A12 :- A0 > A1, 
 std.map.private.height A2 A3, std.map.private.height A4 A5, A3 >= A5, !, 
 std.map.private.create A6 A7 A8 A4 A9, 
 std.map.private.create A9 A10 A11 A2 A12.
% File "builtin_map.elpi", line 58, column 0, characters 13278-13425: [186] 
std.map.private.bal.aux _ A0 A1 _ A2 A3 A4 
 (std.map.private.node (std.map.private.node A5 A12 A13 A7 _) A8 A9 A10 _) 
 A14 :- A0 > A1, !, std.map.private.create A2 A3 A4 A5 A6, 
 std.map.private.create A7 A8 A9 A10 A11, 
 std.map.private.create A6 A12 A13 A11 A14.
% File "builtin_map.elpi", line 61, column 0, characters 13427-13472: [187] 
std.map.private.bal.aux _ _ _ _ A0 A1 A2 A3 A4 :- std.map.private.create A0 
                                                   A1 A2 A3 A4.
% File "builtin_map.elpi", line 64, column 0, characters 13530-13575: [188] 
std.map.private.add std.map.private.empty _ A0 A1 A2 :- std.map.private.create
                                                         std.map.private.empty 
                                                         A0 A1 
                                                         std.map.private.empty 
                                                         A2.
% File "builtin_map.elpi", line 65, column 0, characters 13577-13655: [189] 
std.map.private.add (as (std.map.private.node _ A1 _ _ _) A4) A3 A0 A5 A6 :- 
 A3 A0 A1 A2, std.map.private.add.aux A2 A4 A3 A0 A5 A6.
% File "builtin_map.elpi", line 68, column 0, characters 13722-13783: [190] 
std.map.private.add.aux eq (std.map.private.node A1 _ _ A4 A5) _ A2 A3 A0 :- 
 A0 = std.map.private.node A1 A2 A3 A4 A5.
% File "builtin_map.elpi", line 69, column 0, characters 13786-13856: [191] 
std.map.private.add.aux lt (std.map.private.node A0 A5 A6 A7 _) A1 A2 A3 A8 :- 
 std.map.private.add A0 A1 A2 A3 A4, std.map.private.bal A4 A5 A6 A7 A8.
% File "builtin_map.elpi", line 70, column 0, characters 13858-13928: [192] 
std.map.private.add.aux gt (std.map.private.node A5 A6 A7 A0 _) A1 A2 A3 A8 :- 
 std.map.private.add A0 A1 A2 A3 A4, std.map.private.bal A5 A6 A7 A4 A8.
% File "builtin_map.elpi", line 73, column 0, characters 13978-14050: [193] 
std.map.private.find (std.map.private.node A4 A1 A6 A5 _) A3 A0 A7 :- 
 A3 A0 A1 A2, std.map.private.find.aux A2 A3 A4 A5 A6 A0 A7.
% File "builtin_map.elpi", line 76, column 0, characters 14121-14146: [194] 
std.map.private.find.aux eq _ _ _ A0 _ A0 :- .
% File "builtin_map.elpi", line 77, column 0, characters 14148-14191: [195] 
std.map.private.find.aux lt A1 A0 _ _ A2 A3 :- std.map.private.find A0 A1 A2 
                                                A3.
% File "builtin_map.elpi", line 78, column 0, characters 14193-14236: [196] 
std.map.private.find.aux gt A1 _ A0 _ A2 A3 :- std.map.private.find A0 A1 A2 
                                                A3.
% File "builtin_map.elpi", line 81, column 0, characters 14283-14329: [197] 
std.map.private.remove-min-binding
 (std.map.private.node std.map.private.empty _ _ A0 _) A0 :- !.
% File "builtin_map.elpi", line 82, column 0, characters 14331-14406: [198] 
std.map.private.remove-min-binding (std.map.private.node A0 A2 A3 A4 _) A5 :- 
 std.map.private.remove-min-binding A0 A1, 
 std.map.private.bal A1 A2 A3 A4 A5.
% File "builtin_map.elpi", line 85, column 0, characters 14443-14484: [199] 
std.map.private.min-binding
 (std.map.private.node std.map.private.empty A0 A1 _ _) A0 A1 :- !.
% File "builtin_map.elpi", line 86, column 0, characters 14486-14539: [200] 
std.map.private.min-binding (std.map.private.node A0 _ _ _ _) A1 A2 :- 
 std.map.private.min-binding A0 A1 A2.
% File "builtin_map.elpi", line 89, column 0, characters 14582-14602: [201] 
std.map.private.merge std.map.private.empty A0 A0 :- !.
% File "builtin_map.elpi", line 90, column 0, characters 14604-14624: [202] 
std.map.private.merge A0 std.map.private.empty A0 :- !.
% File "builtin_map.elpi", line 91, column 0, characters 14626-14703: [203] 
std.map.private.merge A4 A0 A5 :- std.map.private.min-binding A0 A1 A2, 
 std.map.private.remove-min-binding A0 A3, 
 std.map.private.bal A4 A1 A2 A3 A5.
% File "builtin_map.elpi", line 96, column 0, characters 14761-14788: [204] 
std.map.private.remove std.map.private.empty _ _ std.map.private.empty :- !.
% File "builtin_map.elpi", line 97, column 0, characters 14790-14864: [205] 
std.map.private.remove (std.map.private.node A4 A1 A6 A5 _) A3 A0 A7 :- 
 A3 A0 A1 A2, std.map.private.remove.aux A2 A3 A4 A5 A1 A6 A0 A7.
% File "builtin_map.elpi", line 100, column 0, characters 14946-14990: [206] 
std.map.private.remove.aux eq _ A0 A1 _ _ _ A2 :- std.map.private.merge A0 
                                                   A1 A2.
% File "builtin_map.elpi", line 101, column 0, characters 14992-15053: [207] 
std.map.private.remove.aux lt A1 A0 A6 A4 A5 A2 A7 :- std.map.private.remove
                                                       A0 A1 A2 A3, 
 std.map.private.bal A3 A4 A5 A6 A7.
% File "builtin_map.elpi", line 102, column 0, characters 15055-15116: [208] 
std.map.private.remove.aux gt A1 A4 A0 A5 A6 A2 A7 :- std.map.private.remove
                                                       A0 A1 A2 A3, 
 std.map.private.bal A4 A5 A6 A3 A7.
% File "builtin_map.elpi", line 105, column 0, characters 15178-15196: [209] 
std.map.private.bindings std.map.private.empty A0 A0 :- .
% File "builtin_map.elpi", line 106, column 0, characters 15198-15271: [210] 
std.map.private.bindings (std.map.private.node A3 A4 A5 A0 _) A1 A6 :- 
 std.map.private.bindings A0 A1 A2, 
 std.map.private.bindings A3 [pr A4 A5 | A2] A6.
% File "builtin_set.elpi", line 8, column 0, characters 22213-22249: [211] 
std.set.make A0 (std.set std.set.private.empty A0) :- .
% File "builtin_set.elpi", line 12, column 0, characters 22306-22349: [212] 
std.set.mem A2 (std.set A0 A1) :- std.set.private.mem A0 A1 A2.
% File "builtin_set.elpi", line 16, column 0, characters 22417-22481: [213] 
std.set.add A2 (std.set A0 A1) (std.set A3 A1) :- std.set.private.add A0 A1 
                                                   A2 A3.
% File "builtin_set.elpi", line 20, column 0, characters 22555-22625: [214] 
std.set.remove A2 (std.set A0 A1) (std.set A3 A1) :- std.set.private.remove
                                                      A0 A1 A2 A3.
% File "builtin_set.elpi", line 24, column 0, characters 22710-22758: [215] 
std.set.cardinal (std.set A0 _) A1 :- std.set.private.cardinal A0 A1.
% File "builtin_set.elpi", line 27, column 0, characters 22796-22847: [216] 
std.set.elements (std.set A0 _) A1 :- std.set.private.elements A0 [] A1.
% File "builtin_set.elpi", line 37, column 0, characters 23014-23028: [217] 
std.set.private.height std.set.private.empty 0 :- .
% File "builtin_set.elpi", line 38, column 0, characters 23030-23053: [218] 
std.set.private.height (std.set.private.node _ _ _ A0) A0 :- .
% File "builtin_set.elpi", line 41, column 0, characters 23094-23165: [219] 
std.set.private.create A0 A6 A2 (std.set.private.node A0 A6 A2 A5) :- 
 std.set.private.height A0 A1, std.set.private.height A2 A3, 
 std.max A1 A3 A4, A5 is A4 + 1.
% File "builtin_set.elpi", line 44, column 0, characters 23203-23313: [220] 
std.set.private.bal A0 A6 A2 A7 :- std.set.private.height A0 A1, 
 std.set.private.height A2 A3, A4 is A1 + 2, A5 is A3 + 2, 
 std.set.private.bal.aux A1 A3 A4 A5 A0 A6 A2 A7.
% File "builtin_set.elpi", line 52, column 0, characters 23375-23496: [221] 
std.set.private.bal.aux A0 _ _ A1 (std.set.private.node A2 A9 A4 _) A6 A7 A10 :- 
 A0 > A1, std.set.private.height A2 A3, std.set.private.height A4 A5, 
 A3 >= A5, !, std.set.private.create A4 A6 A7 A8, 
 std.set.private.create A2 A9 A8 A10.
% File "builtin_set.elpi", line 55, column 0, characters 23498-23627: [222] 
std.set.private.bal.aux A0 _ _ A1 
 (std.set.private.node A2 A3 (std.set.private.node A4 A10 A6 _) _) A7 A8 A11 :- 
 A0 > A1, !, std.set.private.create A2 A3 A4 A5, 
 std.set.private.create A6 A7 A8 A9, std.set.private.create A5 A10 A9 A11.
% File "builtin_set.elpi", line 58, column 0, characters 23629-23750: [223] 
std.set.private.bal.aux _ A0 A1 _ A6 A7 (std.set.private.node A4 A9 A2 _) A10 :- 
 A0 > A1, std.set.private.height A2 A3, std.set.private.height A4 A5, 
 A3 >= A5, !, std.set.private.create A6 A7 A4 A8, 
 std.set.private.create A8 A9 A2 A10.
% File "builtin_set.elpi", line 61, column 0, characters 23752-23881: [224] 
std.set.private.bal.aux _ A0 A1 _ A2 A3 
 (std.set.private.node (std.set.private.node A4 A10 A6 _) A7 A8 _) A11 :- 
 A0 > A1, !, std.set.private.create A2 A3 A4 A5, 
 std.set.private.create A6 A7 A8 A9, std.set.private.create A5 A10 A9 A11.
% File "builtin_set.elpi", line 64, column 0, characters 23883-23924: [225] 
std.set.private.bal.aux _ _ _ _ A0 A1 A2 A3 :- std.set.private.create A0 A1 
                                                A2 A3.
% File "builtin_set.elpi", line 67, column 0, characters 23975-24016: [226] 
std.set.private.add std.set.private.empty _ A0 A1 :- std.set.private.create
                                                      std.set.private.empty 
                                                      A0 
                                                      std.set.private.empty 
                                                      A1.
% File "builtin_set.elpi", line 68, column 0, characters 24018-24087: [227] 
std.set.private.add (std.set.private.node A4 A1 A5 A6) A3 A0 A7 :- A3 A0 A1 
                                                                    A2, 
 std.set.private.add.aux A2 A3 A4 A5 A1 A0 A6 A7.
% File "builtin_set.elpi", line 71, column 0, characters 24162-24201: [228] 
std.set.private.add.aux eq _ A0 A1 A2 _ A3 (std.set.private.node A0 A2 A1 A3) :- .
% File "builtin_set.elpi", line 72, column 0, characters 24203-24256: [229] 
std.set.private.add.aux lt A1 A0 A5 A4 A2 _ A6 :- std.set.private.add A0 A1 
                                                   A2 A3, 
 std.set.private.bal A3 A4 A5 A6.
% File "builtin_set.elpi", line 73, column 0, characters 24258-24311: [230] 
std.set.private.add.aux gt A1 A4 A0 A5 A2 _ A6 :- std.set.private.add A0 A1 
                                                   A2 A3, 
 std.set.private.bal A4 A5 A3 A6.
% File "builtin_set.elpi", line 76, column 0, characters 24353-24411: [231] 
std.set.private.mem (std.set.private.node A4 A1 A5 _) A3 A0 :- A3 A0 A1 A2, 
 std.set.private.mem.aux A2 A3 A4 A5 A0.
% File "builtin_set.elpi", line 79, column 0, characters 24469-24487: [232] 
std.set.private.mem.aux eq _ _ _ _ :- .
% File "builtin_set.elpi", line 80, column 0, characters 24489-24524: [233] 
std.set.private.mem.aux lt A1 A0 _ A2 :- std.set.private.mem A0 A1 A2.
% File "builtin_set.elpi", line 81, column 0, characters 24526-24561: [234] 
std.set.private.mem.aux gt A1 _ A0 A2 :- std.set.private.mem A0 A1 A2.
% File "builtin_set.elpi", line 84, column 0, characters 24604-24648: [235] 
std.set.private.remove-min-binding
 (std.set.private.node std.set.private.empty _ A0 _) A0 :- !.
% File "builtin_set.elpi", line 85, column 0, characters 24650-24721: [236] 
std.set.private.remove-min-binding (std.set.private.node A0 A2 A3 _) A4 :- 
 std.set.private.remove-min-binding A0 A1, std.set.private.bal A1 A2 A3 A4.
% File "builtin_set.elpi", line 88, column 0, characters 24753-24790: [237] 
std.set.private.min-binding
 (std.set.private.node std.set.private.empty A0 _ _) A0 :- !.
% File "builtin_set.elpi", line 89, column 0, characters 24792-24839: [238] 
std.set.private.min-binding (std.set.private.node A0 _ _ _) A1 :- std.set.private.min-binding
                                                                   A0 A1.
% File "builtin_set.elpi", line 92, column 0, characters 24876-24896: [239] 
std.set.private.merge std.set.private.empty A0 A0 :- !.
% File "builtin_set.elpi", line 93, column 0, characters 24898-24918: [240] 
std.set.private.merge A0 std.set.private.empty A0 :- !.
% File "builtin_set.elpi", line 94, column 0, characters 24920-24993: [241] 
std.set.private.merge A3 A0 A4 :- std.set.private.min-binding A0 A1, 
 std.set.private.remove-min-binding A0 A2, std.set.private.bal A3 A1 A2 A4.
% File "builtin_set.elpi", line 99, column 0, characters 25047-25069: [242] 
std.set.private.remove std.set.private.empty _ _ std.set.private.empty :- .
% File "builtin_set.elpi", line 100, column 0, characters 25071-25141: [243] 
std.set.private.remove (std.set.private.node A4 A1 A5 _) A3 A0 A6 :- 
 A3 A0 A1 A2, std.set.private.remove.aux A2 A3 A4 A5 A1 A0 A6.
% File "builtin_set.elpi", line 103, column 0, characters 25214-25256: [244] 
std.set.private.remove.aux eq _ A0 A1 _ _ A2 :- std.set.private.merge A0 A1 
                                                 A2.
% File "builtin_set.elpi", line 104, column 0, characters 25258-25315: [245] 
std.set.private.remove.aux lt A1 A0 A5 A4 A2 A6 :- std.set.private.remove A0 
                                                    A1 A2 A3, 
 std.set.private.bal A3 A4 A5 A6.
% File "builtin_set.elpi", line 105, column 0, characters 25317-25374: [246] 
std.set.private.remove.aux gt A1 A4 A0 A5 A2 A6 :- std.set.private.remove A0 
                                                    A1 A2 A3, 
 std.set.private.bal A4 A5 A3 A6.
% File "builtin_set.elpi", line 108, column 0, characters 25405-25421: [247] 
std.set.private.cardinal std.set.private.empty 0 :- .
% File "builtin_set.elpi", line 109, column 0, characters 25423-25488: [248] 
std.set.private.cardinal (std.set.private.node A0 _ A2 _) A4 :- std.set.private.cardinal
                                                                 A0 A1, 
 std.set.private.cardinal A2 A3, A4 is A1 + 1 + A3.
% File "builtin_set.elpi", line 112, column 0, characters 25530-25548: [249] 
std.set.private.elements std.set.private.empty A0 A0 :- .
% File "builtin_set.elpi", line 113, column 0, characters 25550-25618: [250] 
std.set.private.elements (std.set.private.node A3 A4 A0 _) A1 A5 :- std.set.private.elements
                                                                    A0 A1 A2, 
 std.set.private.elements A3 [A4 | A2] A5.
% File "builtin_set.elpi", line 258, column 0, characters 30386-30435: [251] 
printterm A2 A0 :- term_to_string A0 A1, output A2 A1.
% File "coq-builtin.elpi", line 282, column 0, characters 11937-12057: [252] default-declare-evar
declare-evar A0 A1 A2 A3 :- declare_constraint (declare-evar A0 A1 A2 A3) 
                             [A1].
% File "coq-builtin.elpi", line 291, column 0, characters 12302-12377: [253] 
rm-evar (as uvar A0) (as uvar A1) :- !, 
 declare_constraint (rm-evar A0 A1) [A0, A1].
% File "coq-builtin.elpi", line 292, column 0, characters 12379-12390: [254] 
rm-evar _ _ :- .
% File "coq-builtin.elpi", line 313, column 0, characters 13166-13269: [255] 
evar (as uvar A3) A2 A0 :- var A0 _ A1, !, prune A2 A1, prune A3 A1, 
 declare_constraint (evar A3 A2 A0) [A3, A0].
% File "coq-builtin.elpi", line 316, column 0, characters 13272-13310: [256] default-assign-evar
evar _ _ _ :- .
% File "coq-builtin.elpi", line 326, column 0, characters 13661-13798: [257] 
coq.arity->term (parameter A0 _ A4 A2) (prod A1 A4 A3) :- coq.id->name A0 A1, 
 pi c0 \ decl c0 A1 A4 => coq.arity->term (A2 c0) (A3 c0).
% File "coq-builtin.elpi", line 329, column 0, characters 13800-13827: [258] 
coq.arity->term (arity A0) A0 :- .
% File "coq-builtin.elpi", line 778, column 2, characters 32469-32628: [259] 
coq.env.const-opaque? A0 :- coq.warning elpi.deprecated elpi.const-opaque 
                             use coq.env.opaque? in place of coq.env.const-opaque?, 
 coq.env.opaque? A0.
% File "coq-builtin.elpi", line 785, column 2, characters 32717-32891: [260] 
coq.env.const-primitive? A0 :- coq.warning elpi.deprecated 
                                elpi.const-primitive 
                                use coq.env.primitive? in place of coq.env.const-primitive?, 
 coq.env.primitive? A0.
% File "coq-builtin.elpi", line 841, column 0, characters 34928-34959: [261] 
coq.env.add-context context-end :- .
% File "coq-builtin.elpi", line 842, column 0, characters 34961-35118: [262] 
coq.env.add-context (context-item A0 A1 A2 none A5) :- coq.env.add-section-variable
                                                        A0 A1 A2 A3, 
 coq.env.global (const A3) A4, coq.env.add-context (A5 A4).
% File "coq-builtin.elpi", line 845, column 0, characters 35120-35276: [263] 
coq.env.add-context (context-item A0 _ A2 (some A1) A5) :- coq.env.add-const
                                                            A0 A1 A2 ff A3, 
 coq.env.global (const A3) A4, coq.env.add-context (A5 A4).
% File "coq-builtin.elpi", line 878, column 0, characters 36518-36589: [264] 
coq.env.begin-module A0 A1 :- coq.env.begin-module-functor A0 A1 [].
% File "coq-builtin.elpi", line 891, column 0, characters 36999-37076: [265] 
coq.env.begin-module-type A0 :- coq.env.begin-module-type-functor A0 [].
% File "coq-builtin.elpi", line 1273, column 0, characters 52471-52661: [266] 
coq.CS.canonical-projections A0 A1 :- coq.warning elpi.deprecated 
                                       elpi.canonical-projections 
                                       use coq.env.projections in place of coq.CS.canonical-projections, 
 coq.env.projections A0 A1.
% File "coq-builtin.elpi", line 1570, column 0, characters 65488-65668: [267] 
coq.reduction.cbv.whd_all A0 A1 :- coq.warning elpi.deprecated 
                                    elpi.cbv-whd-all 
                                    use coq.reduction.cbv.norm in place of coq.reduction.cbv.whd_all, 
 coq.reduction.cbv.norm A0 A1.
% File "coq-builtin.elpi", line 1577, column 0, characters 65766-65947: [268] 
coq.reduction.vm.whd_all A0 A1 A2 :- coq.warning elpi.deprecated 
                                      elpi.vm-whd-all 
                                      use coq.reduction.vm.norm in place of coq.reduction.vm.whd_all, 
 coq.reduction.vm.norm A0 A1 A2.
% File "coq-builtin.elpi", line 1584, column 0, characters 65998-66091: [269] 
coq.reduction.lazy.whd_all A0 A1 :- get-option coq:redflags coq.redflags.all
                                     => coq.reduction.lazy.whd A0 A1.
% File "coq-builtin.elpi", line 1706, column 0, characters 70790-70830: [270] 
coq.id->name A0 A1 :- coq.string->name A0 A1.
% File "coq-builtin.elpi", line 1852, column 0, characters 77426-77490: [271] 
coq.elpi.accumulate A0 A1 A2 :- coq.elpi.accumulate-clauses A0 A1 [A2].
% File "./examples/tutorial_elpi_lang.v", line 688, column 2, characters 17708-17776: [272] 
whd (app A0 A2) A3 :- whd A0 (fun A1), !, whd (A1 A2) A3.
% File "./examples/tutorial_elpi_lang.v", line 692, column 2, characters 17831-17857: [273] 
whd A1 A0 :- A0 = A1.
% File "./examples/tutorial_elpi_lang.v", line 788, column 2, characters 20262-20312: [274] 
of (app A0 A3) A2 :- of A0 (arr A1 A2), of A3 A1.
% File "./examples/tutorial_elpi_lang.v", line 793, column 2, characters 20428-20483: [275] 
of (fun A0) (arr A2 A1) :- pi c0 \ of c0 A2 => of (A0 c0) A1.
