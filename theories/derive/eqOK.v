(* Generates correctness proofs for comparison functions generated by derive.eq.

   license: GNU Lesser General Public License Version 2.1 or later           
   ------------------------------------------------------------------------- *)

From elpi Require Import elpi
  derive.eq derive.projK derive.isK 
  derive.param1 derive.param1P derive.map
  derive.induction derive.isK derive.projK
  derive.cast.

From Coq Require Import ssreflect ssrbool.

Definition axiom T eqb x :=
  forall (y : T), reflect (x = y) (eqb x y).

Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1 bool.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.param1P boolR.
Elpi derive.map prodR.
Elpi derive.map listR.

Elpi derive.param1 prodR.
Elpi derive.param1 listR.
(*Elpi derive.param1P prodRR.
Elpi derive.param1P listRR.*)

Inductive nat1 := 
 | O1 
 | S1 (_ : nat1 * (bool * list nat1)).


Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.
Elpi derive.induction nat1.

(* Elpi derive.induction prodR. *)

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.
Elpi derive.eq nat1.

Print nat1_eq.

Lemma bool_eqOK
            x : boolR x -> axiom bool bool_eq x.
Proof.
by elim; case; constructor.
Qed.


Lemma reflect_pair b1 b2 A (x1 x2 : A) B (y1 y2 : B) :
  reflect (x1 = x2) b1 ->
  reflect (y1 = y2) b2 ->
     reflect ((x1,y1) = (x2,y2)) (b1 && b2).
Proof.
refine (fun r1 r2 =>
  match r1 in reflect _ r return reflect ((x1,y1) = (x2,y2)) (r && b2) with
  | ReflectT _ e1 =>
       match r2 in reflect _ r return reflect ((x1,y1) = (x2,y2)) (true && r) with
       | ReflectT _ e2 =>
           match e1 in eq _ r return reflect ((x1, y1) = (r, y2)) true with
           | refl_equal _ => 
                match e2 in eq _ r return reflect ((x1, y1) = (x1, r)) true with
                | refl_equal _ => ReflectT _ (refl_equal (x1,y1))
                end
           end
       | ReflectF _ ne => ReflectF _ _
       end
  | ReflectF _ ne => ReflectF _ _
  end).
now intros [= H1 H2].
now intros [= H1 H2].
Qed.

Definition eq_axiom_pair A fa B fb :
  forall a, axiom A fa a ->
  forall b, axiom B fb b ->
    axiom (A * B) (prod_eq A fa B fb) (a,b) :=
 (fun (a : A) (Pa : axiom A fa a)
            (b : B) (Pb : axiom B fb b) (w : A * B) =>
   match w return reflect ((a,b) = w) (prod_eq A fa B fb (a,b) w) with
   | pair x y => reflect_pair (fa a x) (fb b y) A a x B b y (Pa x) (Pb y)
   end).


Definition prod_eqOK
            A fa B fb x :
            prodR A (axiom A fa) B (axiom B fb) x ->
            axiom (A * B) (prod_eq A fa B fb) x
:=
fun e : prodR A (axiom A fa) B (axiom B fb) x =>
  match e in prodR _ _ _ _ r return axiom (A * B) (prod_eq A fa B fb) r with
  | pairR _ _ _ _ a Pa b Pb => eq_axiom_pair A fa B fb a Pa b Pb
end.

Lemma reflect_cons b1 b2 A (x1 x2 : A) (y1 y2 : list A) :
  reflect (x1 = x2) b1 ->
  reflect (y1 = y2) b2 ->
     reflect (cons x1 y1 = cons x2 y2) (b1 && b2).
Proof.
by case=> [->|e1]; case=>[->|e2];
 [ by constructor 1
 | by constructor => [[*]] .. ].
Qed.


Lemma eq_axiom_nil A fa : axiom (list A) (list_eq A fa) (@nil A).
Proof.
case; [ constructor 1; reflexivity
      | constructor 2; intro ABS; discriminate ABS ].
Qed.

Lemma eq_axiom_cons A fa :
  forall x, axiom A fa x ->
  forall xs, axiom (list A) (list_eq A fa) xs ->
    axiom (list A) (list_eq A fa) (cons x xs).
Proof.
move=> x Px xs Pxs [|y ys]; [ constructor 2; intro ABS; discriminate ABS | ].
apply: reflect_cons (Px y) (Pxs ys).
Qed.

Lemma list_eqOK
            A fa l :
            listR A (axiom A fa) l ->
            axiom (list A) (list_eq A fa) l.
Proof. 
elim.
  by apply: eq_axiom_nil.
move=> a Pa b _ Pb.
by apply: eq_axiom_cons a Pa b Pb.
Qed.

Lemma reflect_S1 b x y : 
  reflect (x = y) b ->
     reflect (S1 x = S1 y) b.
Proof.
case=> e; first by case: _ / e; constructor.
by constructor => [[?]]; apply: e.
Qed.

Lemma eq_axiom_S1 x :
  axiom _ (prod_eq nat1 nat1_eq (bool * list nat1)
     (prod_eq bool bool_eq (list nat1)
        (list_eq nat1 nat1_eq))) x ->
     axiom nat1 nat1_eq (S1 x).
Proof.
move=> Hx [|y]; first by constructor 2=> ABS; discriminate ABS.
by apply: reflect_S1; move: Hx y.
Qed.

Lemma nat1_eqOK x : axiom nat1 nat1_eq x.
Proof.
move: x; apply: nat1_induction.

  by case; [ constructor 1; reflexivity
           | constructor 2=> ABS; discriminate ABS ].

move=>x Px; apply: eq_axiom_S1 (x) _; move: x Px.

move=> x Px.
apply: prod_eqOK.
apply: prodR_map Px. 

  by move=> n Pn; exact Pn.

move=> q Pq.
apply: prod_eqOK.
apply: prodR_map Pq.

  by move=> b Pb; apply: bool_eqOK b Pb.

move => l Pl.
apply: list_eqOK.
apply: listR_map Pl.

by move=> n Pn; exact Pn.
Qed.



(*
From Coq Require Import Bool List ssreflect.
From Coq Require Vector.

Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.map prodR.
Elpi derive.map listR.

Inductive nat1 := 
 | O1 
 | S1 (_ : nat1 * (bool * list nat1)).

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.
Elpi derive.induction nat1.

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.
Elpi derive.eq nat1.

Elpi derive.isK bool.
Elpi derive.isK nat.
Elpi derive.isK list.
Elpi derive.isK prod.
Elpi derive.isK nat1.

Module Vector.
Elpi derive.eq Vector.t eq.
Elpi derive.induction Vector.t induction.
Elpi derive.isK Vector.t.
Elpi derive.projK Vector.t.
Elpi derive.param1 Vector.t R.
End Vector.

Print Vector.eq.

*)


(* Elpi derive.eq sigT. 

Definition sigT_eq A fA P fP (s1 s2 : { a : A & P a }) : bool :=
  match s1, s2 with
  | existT _ a pa, existT _ b pb =>
      fA a b && fP a pa b pb
  end.
About sigT_eq.
  Print Vector.eq.

Fixpoint veq A fA n m (v1 : Vector.t A n) (v2 : Vector.t A m) {struct v1} :=
  match v1 with
  | Vector.nil _ =>
      match v2 with
      | Vector.nil _ => true
      | _ => false
      end
  | Vector.cons _ x m xs =>
      match v2 with
      | Vector.nil _ => false
      | Vector.cons _ y n ys => fA x y && nat_eq m n && veq A fA m n xs ys
      end
  end.

Search eq projT1.


Fixpoint v2l A n (v : Vector.t A n) : list A :=
  match v with
  | Vector.nil _ => nil
  | Vector.cons _ x m xs => cons x (v2l A m xs)
  end.

Fixpoint l2v A (l : list A) : { n : nat & Vector.t A n } :=
  match l with
  | nil => existT _ 0 (Vector.nil _)
  | cons x xs =>
      let: existT _ j v := l2v _ xs in
      existT _ (S j) (Vector.cons _ x j v)
  end.

Lemma vl A n v : l2v A (v2l A n v) = existT _ n v.
Proof. by elim: v => //= x j xs ->. Qed.

Lemma lv A l : let v := l2v A l in v2l A _ (projT2 v) = l.
Proof.
elim: l => //= x xs.
by case: (l2v A xs) => j v IH /=; congr (_ :: _).
Qed.

Lemma list_eqOK A f :
  forall x (HA : listR A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Admitted.

Definition bij A B f := { g : B -> A & forall x, g (f x) = x }.

Lemma bij_l2v A : bij _ _ (l2v A).
Proof.
move.
exists (fun v => v2l A (projT1 v) (projT2 v)).
exact: lv.
Qed.

Definition inj A B (f : A -> B) := forall x y : A, f x = f y -> x = y.

Lemma inj_v2l A n : inj _ _ (v2l A n).
Proof.
elim => [y|].
  by refine match y with Vector.nil _ => _ end.
move=> x j xs IH y.
move: xs IH; rewrite -[j]/(pred (S j)). 
  refine match y with Vector.cons _ y k ys => _ end.
by move=> /= xs IH [-> /IH->].
Qed.

Lemma axiomK A B cmp f (inj_f : inj B A f) b1 :
  axiom A cmp (f b1) -> axiom B (fun x y => cmp (f x) (f y)) b1.
Proof.
move=> H b2.
have [/inj_f -> |nE ] := H (f b2).
  by constructor 1.
by constructor 2 => Hb; apply: nE; rewrite Hb.
Qed.

Definition veq A f n v1 v2 := list_eq A f (v2l A n v1) (v2l A n v2).

Lemma vR2lR A PA n pn v : Vector.tR A PA n pn v -> listR A PA (v2l A n v).
Proof.
elim => /= [| hd Phd j Pj tl Ptl IH].
  by constructor 1.
by constructor 2.
Qed.

Lemma veq_OK A f :
  forall x px v (HA : Vector.tR A (axiom A f) x px v),
  axiom (Vector.t A x) (veq A f x) v.
Proof.
move=> x px v H.
apply: axiomK.
  by apply: inj_v2l.
apply: list_eqOK.
by apply: vR2lR H.
Qed.
 

(* fgffff *)

have xH := axiomK _ _ _ _ (bij_l2v A). (list_eqOK A f _ _).
 apply: list_eqOK.

Definition veqSig A fA (v1 : { n : nat & Vector.t A n}) (v2 : { m : nat & Vector.t A m }) : bool :=
  match v1, v2 with
  | existT _ a pa, existT _ b pb =>
      nat_eq a b && veq A fA a b pa pb
  end.

Axiom nat_eqOK : forall x, axiom nat nat_eq x.

Lemma veqSigOK A fA x v :
  axiom (Vector.t A x) (veq A fA x x) v -> axiom ({ n : nat & Vector.t A n}) (veqSig A fA) (existT _ x v).
Proof.
move=> Hxx [y w]; rewrite /veqSig.
case: (nat_eqOK x y) w => [<- w|??]; last by constructor 2 => /projT1_eq.
case: Hxx => [->| Evw]; first by constructor 1.
constructor 2 => Esig; have H := Eqdep_dec.inj_pair2_eq_dec _ _ _ _ _ _ Esig.
by apply/Evw/H=> i j; case: (nat_eqOK i j); [ left | right ].
Qed.

Lemma veqSigOK1 A fA x v :
  axiom ({ n : nat & Vector.t A n}) (veqSig A fA) (existT _ x v) ->
  axiom (Vector.t A x) (veq A fA x x) v.
Proof.
move: x v.
apply: Vector.induction.
  move=> XX v2; have [] := XX (existT _ 0 v2).
  admit. admit.
move=> b j bs IH XX v2; have [] := XX (existT _ _ v2).

move=> Hsig v2.
case: (Hsig (existT _ x v2)).

move=> Hxx [y w]; rewrite /veqSig.
case: (nat_eqOK x y) w => [<- w|??]; last by constructor 2 => /projT1_eq.
case: Hxx => [->| Evw]; first by constructor 1.
constructor 2 => Esig; have H := Eqdep_dec.inj_pair2_eq_dec _ _ _ _ _ _ Esig.
by apply/Evw/H=> i j; case: (nat_eqOK i j); [ left | right ].
Qed.

Lemma veqOK A f : 
  forall x px v (HA : Vector.tR A (axiom A f) x px v),
  axiom (Vector.t A x) (veq A f x x) v.
Proof.
move=> x px v1 Hf v2; move: x v1 v2 px Hf.
apply: Vector.induction.
  move=> [|b j bs] _ _.
  by constructor 1.
  by constructor 2; apply: equal_idx.
move=> x m xs IH n [_ _|y j ys R Hf /=].
  by constructor 2; apply: equal_idx.
inversion Hf.
case: (X y); last first.
  move=> E; constructor 2. admit.
have nat_eqOK : forall x, axiom nat nat nat_eq x.
  admit.
case: (nat_eqOK m j); last first.
  move=> E; constructor 2. admit.
move=> ? ?.
Admitted.

End Test.

Check veqOK.


Search eq existT .
have := reflect_eqf_base (IH j ys Pn X0).


  case: {-3}_ _ {-}_ / Hf (eq_refl (Vector.cons A x m xs)) (eq_refl (S m)) => //.

    by constructor 2; apply: equal_idx.

refine match v2 with Vector.nil _ => _ | Vector.cons _ y n ys => _ end.
  by [].



 case. => [ [|//]| ]. x m xs IH mR pf ].



Lemma list_eqOK A f :
  forall x (HA : listR A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Proof.
move=> l; elim => [|x Px xs Pxs IH] [|y ys].
- constructor 1; reflexivity.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eqf_step2 (Px y) _.
  case: (Px y) => [p|np].
    case: _ / p; apply: reflect_eqf_base; first by apply: IH.
    by move=> ?? [->].
  by move=> ???? [->].
Qed.


(*
Lemma reflect_eqf_step3 A B C D
 (f : forall a : A, forall b : B a, C a b -> D) b1 b2 
x y z (w : B y) r (s : C y w) : 
   forall e : reflect (x = y) b1,
     (match e with
      | ReflectT _ e =>
            reflect (f x z r = 
                     f x (cast2 A B _ _ e w) (cast3 A B C _ _ e _ s)) b2
      | ReflectF _ abs =>
             forall x y z w r s, f x z r = f y w s -> x = y
     end) ->
      reflect (f x z r = f y w s) (b1 && b2).
Proof.
case=> e; first by case: _ / e w s.
by move=> inj; constructor=> /inj.
Qed.
*)
*)
Axiom daemon : False.


Elpi Command derive.eqOK.
Elpi Accumulate Db derive.isK.db.
Elpi Accumulate File "ltac/discriminate.elpi".
Elpi Accumulate Db derive.param1.db.
Elpi Accumulate Db derive.param1P.db.
Elpi Accumulate Db derive.induction.db.
Elpi Accumulate Db derive.cast.db.
Elpi Accumulate File "derive/eqOK.elpi".
Elpi Accumulate "
  main [str I, str F] :- !,
    coq.locate I (indt GR),
    coq.locate F (const Cmp),
    derive.eqOK.main GR Cmp.
  main _ :- usage.

  usage :- coq.error ""Usage: derive.eqOK <inductive type name> <comparison function>"".
".
Elpi Typecheck.
 
(*
Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.map prodR.
Elpi derive.map listR.

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.

Elpi derive.isK bool.
Elpi derive.isK nat.
Elpi derive.isK list.
Elpi derive.isK prod.

Elpi derive.eqOK bool bool_eq.
Check bool_eqOK : forall x, axiom bool bool_eq x.

Elpi derive.eqOK nat nat_eq.
Check nat_eqOK : forall x, axiom nat nat_eq x.


Elpi derive.eqOK list list_eq.
Print list_eqOK.




Lemma nat_eqOK x : axiom nat nat_eq x.
Proof.
move: x; apply: nat_induction => [|x]. case.
  by constructor.
  by move=> x; constructor.
move=> IH; case.
  by constructor.
move=> y.
apply: reflect_eqf_base.
  by move=> a b H; injection H.
apply: IH.
Qed.


Inductive foo :=
  K (b : bool) (q : bool) (n : nat).
Elpi derive.eq foo.
Elpi derive.induction foo.

Lemma foo_eqOK x : axiom foo foo_eq x.
move: x; apply: foo_induction=> b q n; case=> b1 q1 n1.
unshelve apply: reflect_eqf_step3.
  by apply: bool_eqOK.
case: bool_eqOK=> [e|].
  case: _ / e.
  unshelve apply: reflect_eqf_step2.
  by apply: bool_eqOK.
case: bool_eqOK=> [e|].
  case: _ / e.
  unshelve apply: reflect_eqf_base.
    admit.
  apply: nat_eqOK.
admit.
admit.



Lemma bool_eqOK x : axiom bool bool_eq x.
Proof.
elim: x => -[|]; by constructor.
Qed.

Lemma list_eqOK A f :
  forall x (HA : list_param1 A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Proof.
move=> l; elim => [|x Px xs Pxs IH] [|y ys].
- constructor 1; reflexivity.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eq_f2=> [????[]|????[]||] //.
Qed.

Lemma prod_eqOK A f B g :
  forall x (H : prod_param1 A (axiom A f) B (axiom B g) x),
  axiom (A * B) (prod_eq A f B g) x.
Proof.
move=> x [a Ha b Hb] [w z].
apply: reflect_eq_f2 => [????[]|????[]||] //. 
Qed.

Lemma nat1_eqOK x : axiom nat1 nat1_eq x.
Proof.
apply: (nat1_induction (axiom nat1 nat1_eq)) => [ | a IH] [ | b ].
- constructor 1 => //.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eq_f1.
  + by move=> ?? [E].
  + rewrite /=.
    apply: prod_eqOK.
    apply: prodR_map IH => // l Hl.
    apply: list_eqOK.  
    apply: listR_map Hl => //.
Qed.

*)
