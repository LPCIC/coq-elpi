<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Enrico Tassi" />
<title>Tutorial on the Elpi programming language</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.20.0+0.20.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-the-elpi-programming-language">
<h1 class="title">Tutorial on the Elpi programming language</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<script>
var style = document.createElement('style');
style.textContent = `
  table.docinfo {
     border-top: none;
     border-bottom: none;
     margin: auto;
  }
  #alectryon-toggle-0 {
     display: none;
  }
  label[for="alectryon-toggle-0"] {
     display: none;
  }
  .alectryon-io {
     border-left-style: dotted;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  pre.alectryon-block {
     padding-left: 1em;
  }
  label.alectryon-input.alectryon-failed {
     text-decoration: red wavy underline;
  }
  .alectryon-io label.alectryon-input::after , .alectryon-banner .alectryon-bubble::before {
    content: '';
    background: url("data:image/svg+xml,%3Csvg width='14' height='14' viewBox='0 0 3.704 3.704' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill-rule='evenodd' stroke='%23000' stroke-width='.264'%3E%3Cpath d='M.794.934h2.115M.794 1.463h1.455M.794 1.992h1.852'/%3E%3C/g%3E%3Cpath d='M.132.14v2.646h.794v.661l.926-.661h1.72V.14z' fill='none' stroke='%23000' stroke-width='.265'/%3E%3C/svg%3E") top right no-repeat;
    height: 14px;
    width: 14px;
    border-style: none;
    border-radius: 0px;
  }
  code.coq , code.elpi {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.note, div.tip {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
  .ghref {
    cursor: help;
    text-decoration: underline dotted;
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
  }

  .elpi {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
   }

  .highlight .-ElpiFunction , .highlight .n-ElpiFunction { color: #795E26 }
  .highlight .-ElpiVariable , .highlight .n-ElpiVariable { color: #0000ff }
  .highlight .k-ElpiKeyword { color: #AF00DB }
  .highlight .k-ElpiMode { color: #811f3f }
  .highlight .m-ElpiInteger { color: #098658 }
  .highlight .si { color: rgb(94, 93, 93) }

  .elpi .n-ElpiFunction { color: #795E26 }
  .elpi .n-ElpiVariable { color: #0000ff }
  .elpi .k-ElpiKeyword { color: #AF00DB }
  .elpi .k-ElpiMode { color: #811f3f }
  .elpi .m-ElpiInteger { color: #098658 }
  .elpi .s2 { color: #a31515 }
  .elpi .c { color: #008000 }
  .elpi .kt { color: #2b91af }
  .elpi .si { color: rgb(94, 93, 93) }

  .admonition-title:after { content: ":" }
  .admonition-title { display: inline; margin-right: 0.5em }
  .admonition-title + p { display: inline }

  .important .admonition-title { color: rgb(197, 70, 91) }
  .important { background-color: rgb(272, 237, 243) }

  .note .admonition-title { color: rgb(42, 134, 57) }
  .note { background-color: rgb(222, 247, 222); }


`;
document.getElementsByTagName('head')[0].appendChild(style);

</script><!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with modes and constraints in order
to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq specific data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This little tutorial does not talk about Coq, but rather focuses on
Elpi as a programming language. It assumes no previous knowledge of
Prolog, ŒªProlog or Elpi. Coq is used as an environment for stepping trough
the tutorial one paragraph at a time. The text between <code class="highlight coq"><span class="si">lp:{{</span></code> and <code class="highlight coq"><span class="o">}}</span></code> is
Elpi code, while the rest are Coq directives to drive the Elpi interpreter.</p>
<div class="contents topic" id="contents">
<p class="topic-title"><a class="reference internal" href="#top">Contents</a></p>
<ul class="simple">
<li><a class="reference internal" href="#logic-programming" id="toc-entry-1">Logic programming</a><ul>
<li><a class="reference internal" href="#unification" id="toc-entry-2">Unification</a></li>
<li><a class="reference internal" href="#backtracking" id="toc-entry-3">Backtracking</a></li>
<li><a class="reference internal" href="#facts-and-conditional-rules" id="toc-entry-4">Facts and conditional rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#terms-with-binders" id="toc-entry-5">Terms with binders</a><ul>
<li><a class="reference internal" href="#abstraction" id="toc-entry-6">Œª-abstraction</a></li>
<li><a class="reference internal" href="#pi-x-and" id="toc-entry-7"><code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> and <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#logical-foundations" id="toc-entry-8">Logical foundations</a></li>
<li><a class="reference internal" href="#modes-and-constraints" id="toc-entry-9">Modes and constraints</a><ul>
<li><a class="reference internal" href="#constraint-handling-rules" id="toc-entry-10">Constraint Handling Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functional-style-1" id="toc-entry-11">Functional style</a><ul>
<li><a class="reference internal" href="#spilling-relation-composition" id="toc-entry-12">Spilling (relation composition)</a></li>
<li><a class="reference internal" href="#apis-for-built-in-data" id="toc-entry-13">APIs for built-in data</a></li>
<li><a class="reference internal" href="#allocation-of-variables" id="toc-entry-14">Allocation of variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging" id="toc-entry-15">Debugging</a><ul>
<li><a class="reference internal" href="#trace-browser" id="toc-entry-16">Trace browser</a></li>
<li><a class="reference internal" href="#good-old-print" id="toc-entry-17">Good old print</a></li>
<li><a class="reference internal" href="#printing-entire-programs" id="toc-entry-18">Printing entire programs</a></li>
<li><a class="reference internal" href="#common-pitfalls" id="toc-entry-19">Common pitfalls</a><ul>
<li><a class="reference internal" href="#precedence-of-e-and" id="toc-entry-20">Precedence of <code class="e elpi"><span class="k-ElpiKeyword">,</span></code>, :e: <code class="highlight coq"><span class="o">==&gt;</span></code> and <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code></a></li>
<li><a class="reference internal" href="#backtracking-1" id="toc-entry-21">Backtracking</a></li>
<li><a class="reference internal" href="#unification-variables-v-s-imperative-variables" id="toc-entry-22">Unification variables v.s. Imperative variables</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#further-reading" id="toc-entry-23">Further reading</a></li>
</ul>
</div>
<div class="section" id="logic-programming">
<h1><a class="toc-backref" href="#toc-entry-1">Logic programming</a></h1>
<p>Elpi is a dialect of ŒªProlog enriched with constraints. We start by introducing
the first order fragment of ŒªProlog, i.e. the terms will not contain binders.
Later we cover terms with binders and constraints.</p>
<p>Our first program is called <code class="highlight coq"><span class="n">tutorial</span></code>.
We begin by declaring the signature of our terms.
Here we declare that <code class="e elpi">person</code> is a type, and that
<code class="e elpi">mallory</code>, <code class="e elpi">bob</code> and <code class="e elpi">alice</code> are terms of that type.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> tutorial <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">kind</span> <span class=" -ElpiFunction">person</span>  <span class="kt">type</span>.
  <span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">mallory, bob, alice</span>  <span class="kt">person</span>.

<span class="si">}}</span>.</span></span></pre><p>An Elpi program is made of rules that declare
when predicates hold and that are accumulated one after the
other. Rules are also called clauses in Prolog's slang, so we may use both
terms interchangeably.</p>
<p>The next code snippet accumulates on top
of the current <code class="highlight coq"><span class="n">tutorial</span></code> program a predicate declaration for <code class="e elpi">age</code>
and three rules representing our knowledge about our terms.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">age</span> <span class="k k-ElpiMode">o:</span><span class="kt">person</span>, <span class="k k-ElpiMode">o:</span><span class="kt">int</span>.

  age mallory <span class="m m-ElpiInteger">23</span>.
  age bob <span class="m m-ElpiInteger">23</span>.
  age alice <span class="m m-ElpiInteger">20</span>.

<span class="si">}}</span>.</span></span></pre><p>The predicate <code class="e elpi">age</code> has two arguments, the former is a person while
the latter is an integer. The label <code class="e elpi">o<span class="err">:</span></code> (standing for output)
is a mode declaration, which we will explain later (ignore it for now).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference external stdtype ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L23">int</a> is the built-in data type of integers</p>
<p class="last">Integers come with usual arithmetic operators, see the <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L85">calc</a> built-in.</p>
</div>
<p>In order to run our program we have to write a query,
i.e. a predicate expression containing variables such as:</p>
<pre class="code elpi literal-block">
age alice <span class="n-ElpiVariable">A</span>
</pre>
<p>The execution of the program is expected to assign a value to <code class="e elpi"><span class="n-ElpiVariable">A</span></code>, which
represents the age of <code class="e elpi">alice</code>.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>Syntactic conventions:</p>
<ul class="last simple">
<li>variables are identifiers starting with a capital letter, eg
<code class="e elpi"><span class="n-ElpiVariable">A</span></code>, <code class="e elpi"><span class="n-ElpiVariable">B</span></code>, <code class="e elpi"><span class="n-ElpiVariable">FooBar</span></code>, <code class="e elpi"><span class="n-ElpiVariable">Foo_bar</span></code>, <code class="e elpi"><span class="n-ElpiVariable">X1</span></code></li>
<li>constants (for individuals or predicates) are identifiers
starting with a lowercase letter, eg
<code class="e elpi">foo</code>, <code class="e elpi">bar</code>, <code class="e elpi">this_that</code>, <code class="e elpi">camelCase</code>,
<code class="e elpi">dash-allowed</code>, <code class="e elpi">qmark_too?</code>, <code class="e elpi">arrows-&gt;and.dots.as&lt;-well</code></li>
</ul>
</div>
<p>A query can be composed of many predicate expressions separated by <code class="e elpi"><span class="k-ElpiKeyword">,</span></code>
that stands for conjunction: we want to get an answer to all the
predicate expressions.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk0"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  age alice <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;The age of alice is&quot;</span> <span class=" -ElpiVariable">A</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The age of alice <span class="kr">is</span> <span class="mi">20</span></blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = <span class="mi">20</span></blockquote></div></div></small></span></pre><p><a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/coq-builtin.elpi#L531">coq.say</a> is a built-in predicate provided by Coq-Elpi which
prints its arguments.
You can look at the output buffer of Coq to see the value for <code class="e elpi"><span class="n-ElpiVariable">A</span></code> or hover
or toggle the little bubble after <code class="highlight coq"><span class="o">}}.</span></code> if you are reading the tutorial with a
web browser.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference external stdtype ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L26">string</a> is a built-in data type</p>
<p class="last">Strings are delimited by double quotes and <tt class="docutils literal">\</tt> is the escape symbol.</p>
</div>
<p>The predicate <code class="e elpi">age</code> represents a <em>relation</em> (in contrast to a function)
and it computes both ways: we can ask Elpi which person <code class="e elpi"><span class="n-ElpiVariable">P</span></code> is 23 years old.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  age <span class=" -ElpiVariable">P</span> <span class="m m-ElpiInteger">23</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">P</span> <span class="s2">&quot;is 23 years old&quot;</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">mallory <span class="kr">is</span> <span class="mi">23</span> years old</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">P = mallory</blockquote></div></div></small></span></pre><div class="section" id="unification">
<h2><a class="toc-backref" href="#toc-entry-2">Unification</a></h2>
<p>Operationally the query <code class="e elpi">age <span class="n-ElpiVariable">P</span> <span class="m-ElpiInteger">23</span></code> is <em>unified</em> with each
and every rule present in the program starting from the first one.</p>
<p>Unification compares two
terms structurally and eventually assigns variables.
For example for the first rule of the program we obtain
the following unification problem:</p>
<pre class="code elpi literal-block">
age <span class="n-ElpiVariable">P</span> <span class="m-ElpiInteger">23</span> <span class="k-ElpiKeyword">=</span> age mallory <span class="m-ElpiInteger">23</span>
</pre>
<p>This problem can be simplified into smaller unification problems following
the structure of the terms:</p>
<pre class="code elpi literal-block">
age <span class="k-ElpiKeyword">=</span> age
<span class="n-ElpiVariable">P</span> <span class="k-ElpiKeyword">=</span> mallory
<span class="m-ElpiInteger">23</span> <span class="k-ElpiKeyword">=</span> <span class="m-ElpiInteger">23</span>
</pre>
<p>The first and last are trivial, while the second one can be satisfied by
assigning <code class="e elpi">mallory</code> to <code class="e elpi"><span class="n-ElpiVariable">P</span></code>. All equations are solved,
hence unification succeeds.</p>
<p>See also the <a class="reference external" href="https://en.wikipedia.org/wiki/Unification_(computer_science)#Syntactic_unification_of_first-order_terms">Wikipedia page on Unification</a>.</p>
<p>Since the first part of the query is successful the rest of
the query is run: the value of <code class="e elpi"><span class="n-ElpiVariable">P</span></code> is printed as well as
the <code class="e elpi"><span class="s2">&quot;is 23 years old&quot;</span></code> string.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="e elpi"><span class="k-ElpiKeyword">=</span></code> is a regular predicate</p>
<p>The query <code class="e elpi">age <span class="n-ElpiVariable">P</span> <span class="m-ElpiInteger">23</span></code> can be also written as follows:</p>
<pre class="code elpi last literal-block">
<span class="n-ElpiVariable">A</span> <span class="k-ElpiKeyword">=</span> <span class="m-ElpiInteger">23</span><span class="k-ElpiKeyword">,</span> age <span class="n-ElpiVariable">P</span> <span class="n-ElpiVariable">A</span><span class="k-ElpiKeyword">,</span> <span class="n-ElpiVariable">Msg</span> <span class="k-ElpiKeyword">=</span> <span class="s2">&quot;is 23 years old&quot;</span><span class="k-ElpiKeyword">,</span> coq.say <span class="n-ElpiVariable">P</span> <span class="n-ElpiVariable">Msg</span>
</pre>
</div>
<p>Let's try a query harder to solve!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk2"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  age <span class=" -ElpiVariable">P</span> <span class="m m-ElpiInteger">20</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">P</span> <span class="s2">&quot;is 20 years old&quot;</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">alice <span class="kr">is</span> <span class="mi">20</span> years old</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">P = alice</blockquote></div></div></small></span></pre><p>This time the unification problem for the first rule
in the program is:</p>
<pre class="code elpi literal-block">
age <span class="n-ElpiVariable">P</span> <span class="m-ElpiInteger">20</span> <span class="k-ElpiKeyword">=</span> age mallory <span class="m-ElpiInteger">23</span>
</pre>
<p>that is simplified to:</p>
<pre class="code elpi literal-block">
age <span class="k-ElpiKeyword">=</span> age
<span class="n-ElpiVariable">P</span> <span class="k-ElpiKeyword">=</span> mallory
<span class="m-ElpiInteger">20</span> <span class="k-ElpiKeyword">=</span> <span class="m-ElpiInteger">23</span>
</pre>
<p>The second equation can be solved by assigning <code class="e elpi">mallory</code> to <code class="e elpi"><span class="n-ElpiVariable">P</span></code>,
but the third one has no solution, so unification fails.</p>
</div>
<div class="section" id="backtracking">
<h2><a class="toc-backref" href="#toc-entry-3">Backtracking</a></h2>
<p>When failure occurs all assignments are undone (i.e. <code class="e elpi"><span class="n-ElpiVariable">P</span></code> is unset again)
and the next rule in the program is tried. This operation is called
<em>backtracking</em>.</p>
<p>The unification problem for the next rule is:</p>
<pre class="code elpi literal-block">
age <span class="n-ElpiVariable">P</span> <span class="m-ElpiInteger">20</span> <span class="k-ElpiKeyword">=</span> age bob <span class="m-ElpiInteger">23</span>
</pre>
<p>This one also fails. The unification problem for the last rule is:</p>
<pre class="code elpi literal-block">
age <span class="n-ElpiVariable">P</span> <span class="m-ElpiInteger">20</span> <span class="k-ElpiKeyword">=</span> age alice <span class="m-ElpiInteger">20</span>
</pre>
<p>This one works, and the assignment <code class="e elpi"><span class="n-ElpiVariable">P</span> <span class="k-ElpiKeyword">=</span> alice</code> is kept as the result
of the first part of the query. Then <code class="e elpi"><span class="n-ElpiVariable">P</span></code> is printed and the program
ends.</p>
<p>An even harder query is the following one where we ask for two distinct
individuals to have the same age.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk3"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  age <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span> age <span class=" -ElpiVariable">Q</span> <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span> not(<span class=" -ElpiVariable">P</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">Q</span>)<span class="k k-ElpiKeyword">,</span>
  coq.say <span class=" -ElpiVariable">P</span> <span class="s2">&quot;and&quot;</span> <span class=" -ElpiVariable">Q</span> <span class="s2">&quot;are&quot;</span> <span class=" -ElpiVariable">A</span> <span class="s2">&quot;years old&quot;</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">mallory <span class="kn">and</span> bob are <span class="mi">23</span> years old</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = <span class="mi">23</span></blockquote><blockquote class="alectryon-message">P = mallory</blockquote><blockquote class="alectryon-message">Q = bob</blockquote></div></div></small></span></pre><p>This example shows that backtracking is global.  The first solution for
<code class="e elpi">age <span class="n-ElpiVariable">P</span> <span class="n-ElpiVariable">A</span></code> and <code class="e elpi">age <span class="n-ElpiVariable">Q</span> <span class="n-ElpiVariable">A</span></code> picks <code class="e elpi"><span class="n-ElpiVariable">P</span></code> and <code class="e elpi"><span class="n-ElpiVariable">Q</span></code> to
be the same individual <code class="e elpi">mallory</code>,
but then <code class="e elpi">not(<span class="n-ElpiVariable">P</span> <span class="k-ElpiKeyword">=</span> <span class="n-ElpiVariable">Q</span><span class="o">)</span></code> fails and forces the last choice that was made to be
reconsidered, so <code class="e elpi"><span class="n-ElpiVariable">Q</span></code> becomes <code class="e elpi">bob</code>.</p>
<p>Look at the output of the following code to better understand
how backtracking works.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk4"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

   age <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;I picked P =&quot;</span> <span class=" -ElpiVariable">P</span><span class="k k-ElpiKeyword">,</span>
   age <span class=" -ElpiVariable">Q</span> <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;I picked Q =&quot;</span> <span class=" -ElpiVariable">Q</span><span class="k k-ElpiKeyword">,</span>
   not(<span class=" -ElpiVariable">P</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">Q</span>)<span class="k k-ElpiKeyword">,</span>
   coq.say <span class="s2">&quot;the last choice worked!&quot;</span><span class="k k-ElpiKeyword">,</span>
   coq.say <span class=" -ElpiVariable">P</span> <span class="s2">&quot;and&quot;</span> <span class=" -ElpiVariable">Q</span> <span class="s2">&quot;are&quot;</span> <span class=" -ElpiVariable">A</span> <span class="s2">&quot;years old&quot;</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">I picked P = mallory</blockquote><blockquote class="alectryon-message">I picked Q = mallory</blockquote><blockquote class="alectryon-message">I picked Q = bob</blockquote><blockquote class="alectryon-message">the <span class="nb">last</span> choice worked!</blockquote><blockquote class="alectryon-message">mallory <span class="kn">and</span> bob are <span class="mi">23</span> years old</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = <span class="mi">23</span></blockquote><blockquote class="alectryon-message">P = mallory</blockquote><blockquote class="alectryon-message">Q = bob</blockquote></div></div></small></span></pre><div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="e elpi">not</code> is a black hole</p>
<p class="last">The <code class="e elpi">not(<span class="n-ElpiVariable">P</span><span class="o">)</span></code> predicate tries to solve the query <code class="e elpi"><span class="n-ElpiVariable">P</span></code>: it fails if
<code class="e elpi"><span class="n-ElpiVariable">P</span></code> succeeds, and succeeds if <code class="e elpi"><span class="n-ElpiVariable">P</span></code> fails. In any case no trace is left
of the computation for <code class="e elpi"><span class="n-ElpiVariable">P</span></code>. E.g. <code class="e elpi">not(<span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">=</span> <span class="m-ElpiInteger">1</span><span class="k-ElpiKeyword">,</span> <span class="m-ElpiInteger">2</span> <span class="k-ElpiKeyword">&lt;</span> <span class="m-ElpiInteger">1</span><span class="o">)</span></code> succeeds, but
the assignment for <code class="e elpi"><span class="n-ElpiVariable">X</span></code> is undone. See also the section
about the <a class="reference internal" href="#foundations">foundations</a> of ŒªProlog.</p>
</div>
</div>
<div class="section" id="facts-and-conditional-rules">
<h2><a class="toc-backref" href="#toc-entry-4">Facts and conditional rules</a></h2>
<p>The rules we have seen so far are <em>facts</em>: they always hold.
In general rules can only be applied if some <em>condition</em> holds. Conditions are
also called premises, we may use the two terms interchangeably.</p>
<p>Here we add to our program a rule that defines what <code class="e elpi">older <span class="n-ElpiVariable">P</span> <span class="n-ElpiVariable">Q</span></code> means
in terms of the <code class="e elpi">age</code> of <code class="e elpi"><span class="n-ElpiVariable">P</span></code> and <code class="e elpi"><span class="n-ElpiVariable">Q</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="e elpi"><span class="k-ElpiKeyword">:-</span></code> separates the <em>head</em> of a rule from the <em>premises</em></p>
</div>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">older</span> <span class="k k-ElpiMode">o:</span><span class="kt">person</span>, <span class="k k-ElpiMode">o:</span><span class="kt">person</span>.
  older <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">Q</span> <span class="k k-ElpiKeyword">:-</span> age <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span> age <span class=" -ElpiVariable">Q</span> <span class=" -ElpiVariable">M</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">N</span> <span class="k k-ElpiKeyword">&gt;</span> <span class=" -ElpiVariable">M</span>.

<span class="si">}}</span>.</span></span></pre><p>The rule reads: <code class="e elpi"><span class="n-ElpiVariable">P</span></code> is older than <code class="e elpi"><span class="n-ElpiVariable">Q</span></code> if
<code class="e elpi"><span class="n-ElpiVariable">N</span></code> is the age of <code class="e elpi"><span class="n-ElpiVariable">P</span></code>
<em>and</em> <code class="e elpi"><span class="n-ElpiVariable">M</span></code> is the age of <code class="e elpi"><span class="n-ElpiVariable">Q</span></code>
<em>and</em> <code class="e elpi"><span class="n-ElpiVariable">N</span></code> is greater than <code class="e elpi"><span class="n-ElpiVariable">M</span></code>.</p>
<p>Let's run a query using older:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk5"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  older bob <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;bob is older than&quot;</span> <span class=" -ElpiVariable">X</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bob <span class="kr">is</span> older than alice</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = alice</blockquote></div></div></small></span></pre><p>The query <code class="e elpi">older bob <span class="n-ElpiVariable">X</span></code> is unified with the head of
the program rule <code class="e elpi">older <span class="n-ElpiVariable">P</span> <span class="n-ElpiVariable">Q</span></code>
assigning <code class="e elpi"><span class="n-ElpiVariable">P</span> <span class="k-ElpiKeyword">=</span> bob</code> and <code class="e elpi"><span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">=</span> <span class="n-ElpiVariable">Q</span></code>.  Then three new queries are run:</p>
<pre class="code elpi literal-block">
age bob <span class="n-ElpiVariable">N</span>
age <span class="n-ElpiVariable">Q</span> <span class="n-ElpiVariable">M</span>
<span class="n-ElpiVariable">N</span> <span class="k-ElpiKeyword">&gt;</span> <span class="n-ElpiVariable">M</span>
</pre>
<p>The former assigns <code class="e elpi"><span class="n-ElpiVariable">N</span> <span class="k-ElpiKeyword">=</span> <span class="m-ElpiInteger">23</span></code>, the second one first
sets <code class="e elpi"><span class="n-ElpiVariable">Q</span> <span class="k-ElpiKeyword">=</span> mallory</code> and <code class="e elpi"><span class="n-ElpiVariable">M</span> <span class="k-ElpiKeyword">=</span> <span class="m-ElpiInteger">23</span></code>.  This makes the last
query to fail, since <code class="e elpi"><span class="m-ElpiInteger">23</span> <span class="k-ElpiKeyword">&gt;</span> <span class="m-ElpiInteger">23</span></code> is false.  Hence the
second query is run again and again until <code class="e elpi"><span class="n-ElpiVariable">Q</span></code> is
set to <code class="e elpi">alice</code> and <code class="e elpi"><span class="n-ElpiVariable">M</span></code> to <code class="e elpi"><span class="m-ElpiInteger">20</span></code>.</p>
<p>Variables in the query are said to be existentially
quantified because Elpi will try to find one
possible value for them.</p>
<p>Conversely, the variables used in rules are
universally quantified in the front of the rule.
This means that the same program rule can be used
multiple times, and each time the variables are fresh.</p>
<p>In the following example the variable <code class="e elpi"><span class="n-ElpiVariable">P</span></code> in <code class="e elpi">older <span class="n-ElpiVariable">P</span> <span class="n-ElpiVariable">Q</span> <span class="k-ElpiKeyword">:-</span> <span class="o">...</span></code>
once takes <code class="e elpi">bob</code> and another time takes <code class="e elpi">mallory</code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk6"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  older bob <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span> older mallory <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;both bob and mallory are older than&quot;</span> <span class=" -ElpiVariable">X</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">both bob <span class="kn">and</span> mallory are older than alice</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = alice</blockquote></div></div></small></span></pre></div>
</div>
<div class="section" id="terms-with-binders">
<h1><a class="toc-backref" href="#toc-entry-5">Terms with binders</a></h1>
<p>So far the syntax of terms is based on constants
(eg <code class="e elpi">age</code> or <code class="e elpi">mallory</code>) and variables (eg <code class="e elpi"><span class="n-ElpiVariable">X</span></code>).</p>
<p>ŒªProlog adds another term constructor:
Œª-abstraction (written <code class="e elpi"><span class="n-ElpiVariable">x\</span> <span class="o">...</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the variable name before the <tt class="docutils literal">\</tt> can be a capital</p>
<p class="last">Given that it is explicitly bound Elpi needs not to guess if it is a global
symbol or a rule variable (that required the convention of using capitals for
variables in the first place).</p>
</div>
<div class="section" id="abstraction">
<h2><a class="toc-backref" href="#toc-entry-6">Œª-abstraction</a></h2>
<p>Functions built using Œª-abstraction can be applied
to arguments and honor the usual Œ≤-reduction rule
(the argument is substituted for the bound variable).</p>
<p>In the following example <code class="e elpi"><span class="n-ElpiVariable">F</span> <span class="m-ElpiInteger">23</span></code> reads, once
the Œ≤-reduction is performed, <code class="e elpi">age alice <span class="m-ElpiInteger">23</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk7"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">F</span> <span class="k k-ElpiKeyword">=</span> (<span class=" -ElpiVariable">x\</span> age alice x)<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;F =&quot;</span> <span class=" -ElpiVariable">F</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;F 20 =&quot;</span> (<span class=" -ElpiVariable">F</span> <span class="m m-ElpiInteger">20</span>)<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;F 23 =&quot;</span> (<span class=" -ElpiVariable">F</span> <span class="m m-ElpiInteger">23</span>)

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">F = c0 \ age alice c0</blockquote><blockquote class="alectryon-message">F <span class="mi">20</span> = age alice <span class="mi">20</span></blockquote><blockquote class="alectryon-message">F <span class="mi">23</span> = age alice <span class="mi">23</span></blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  F = c0 \
age alice c0</blockquote></div></div></small></span></pre><p>Let's now write the &quot;hello world&quot; of ŒªProlog: an
interpreter and type checker for the simply
typed Œª-calculus. We call this program <code class="highlight coq"><span class="n">stlc</span></code>.</p>
<p>We start by declaring that <code class="e elpi">term</code> is a type and
that <code class="e elpi">app</code> and <code class="e elpi">fun</code> are constructors of that type.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> stlc <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">kind</span>  <span class=" -ElpiFunction">term</span>  <span class="kt">type</span>.

  <span class="k k-ElpiKeyword">type</span>  <span class=" -ElpiFunction">app</span>   <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
  <span class="k k-ElpiKeyword">type</span>  <span class=" -ElpiFunction">fun</span>   <span class="kt">(term</span> <span class="kt">-&gt;</span> <span class="kt">term)</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.

<span class="si">}}</span>.</span></span></pre><p>The constructor <code class="e elpi">app</code> takes two terms
while <code class="e elpi">fun</code> only one (of functional type).</p>
<p>Note that</p>
<ul class="simple">
<li>there is no constructor for variables, we will
use the notion of bound variable of ŒªProlog in order
to represent variables</li>
<li><code class="e elpi">fun</code> takes a function as subterm, i.e. something
we can build using the Œª-abstraction <code class="e elpi"><span class="n-ElpiVariable">x\</span> <span class="o">...</span></code></li>
</ul>
<p>As a consequence, the identity function Œªx.x is written like this:</p>
<pre class="code elpi literal-block">
fun (<span class="n-ElpiVariable">x\</span> x<span class="o">)</span>
</pre>
<p>while the first projection Œªx.Œªy.x is written:</p>
<pre class="code elpi literal-block">
fun (<span class="n-ElpiVariable">x\</span> fun <span class="o">(</span><span class="n-ElpiVariable">y\</span> x<span class="o">))</span>
</pre>
<p>Another consequence of this approach is that there is no
such thing as a free variable in our representation of the Œª-calculus.
Variables are only available under the Œª-abstraction of the
programming language, that gives them a well defined scope and
substitution operation (Œ≤-reduction).</p>
<p>This approach is called <a class="reference external" href="https://en.wikipedia.org/wiki/Higher-order_abstract_syntax">HOAS</a>.</p>
<p>We can now implement weak head reduction, that is we stop reducing
when the term is a <code class="e elpi">fun</code> or a global constant (potentially applied).
If the term is <code class="e elpi">app (fun <span class="n-ElpiVariable">F</span><span class="o">)</span> <span class="n-ElpiVariable">A</span></code> then we compute the reduct <code class="e elpi"><span class="n-ElpiVariable">F</span> <span class="n-ElpiVariable">A</span></code>.
Note that <code class="e elpi"><span class="n-ElpiVariable">F</span></code> is a ŒªProlog function, so passing an argument to it
implements the substitution of the actual argument for the bound variable.</p>
<p>We first give a type and a mode for our predicate <code class="e elpi">whd</code>. It reads
&quot;whd takes a term in input and gives a term in output&quot;. We will
explain what input means precisely later, for now just think about it
as a comment.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">whd</span> <span class="k k-ElpiMode">i:</span><span class="kt">term</span>, <span class="k k-ElpiMode">o:</span><span class="kt">term</span>.

  <span class="c">% when the head &quot;Hd&quot; of an &quot;app&quot; (lication) is a</span>
  <span class="c">% &quot;fun&quot; we substitute and continue</span>
  whd (<span class="k k-ElpiKeyword">app</span> <span class=" -ElpiVariable">Hd</span> <span class=" -ElpiVariable">Arg</span>) <span class=" -ElpiVariable">Reduct</span> <span class="k k-ElpiKeyword">:-</span> whd <span class=" -ElpiVariable">Hd</span> (<span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">F</span>)<span class="k k-ElpiKeyword">,</span> <span class="k k-ElpiKeyword">!,</span>
    whd (<span class=" -ElpiVariable">F</span> <span class=" -ElpiVariable">Arg</span>) <span class=" -ElpiVariable">Reduct</span>.

  <span class="c">% otherwise a term X is already in normal form.</span>
  whd <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Reduct</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">Reduct</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">X</span>.

<span class="si">}}</span>.</span></span></pre><p>Recall that, due to backtracking, all rules are potentially used.
Here whenever the first premise of the first rule succeeds
we want the second rule to be skipped, since we found a redex.</p>
<p>The premises of a rule are run in order and the <code class="e elpi"><span class="k-ElpiKeyword">!</span></code> operator discards all
other rules following the current one. Said otherwise it commits to
the currently chosen rule for the current query (but leaves
all rules available for subsequent queries, they are not erased from the
program). So, as soon as <code class="e elpi">whd <span class="n-ElpiVariable">Hd</span> (fun <span class="n-ElpiVariable">F</span><span class="o">)</span></code> succeeds we discard the second
rule.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk8"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">I</span> <span class="k k-ElpiKeyword">=</span> (<span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">x\</span>x)<span class="k k-ElpiKeyword">,</span>
  whd <span class=" -ElpiVariable">I</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;Œªx.x ~&gt;&quot;</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
  whd (<span class="k k-ElpiKeyword">app</span> <span class=" -ElpiVariable">I</span> <span class=" -ElpiVariable">I</span>) <span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;(Œªx.x) (Œªx.x) ~&gt;&quot;</span> <span class=" -ElpiVariable">T1</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kr">Œª</span><span class="nv">x</span>.x ~&gt; <span class="kr">fun</span> <span class="nv">c0</span> \ c0</blockquote><blockquote class="alectryon-message">(<span class="kr">Œª</span><span class="nv">x</span>.x) (<span class="kr">Œª</span><span class="nv">x</span>.x) ~&gt; <span class="kr">fun</span> <span class="nv">c0</span> \ c0</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">I = <span class="kr">fun</span> <span class="nv">c0</span> \ c0</blockquote><blockquote class="alectryon-message">T = <span class="kr">fun</span> <span class="nv">c0</span> \ c0</blockquote><blockquote class="alectryon-message">T1 = <span class="kr">fun</span> <span class="nv">c0</span> \ c0</blockquote></div></div></small></span></pre><p>Another little test using global constants:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">foo, bar</span> <span class="kt">term</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk9"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">Fst</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)<span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">app</span> (<span class="k k-ElpiKeyword">app</span> <span class=" -ElpiVariable">Fst</span> foo) bar<span class="k k-ElpiKeyword">,</span>
  whd <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;(Fst foo bar) ~&gt;&quot;</span> <span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">S</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">app</span> foo bar<span class="k k-ElpiKeyword">,</span>
  whd <span class=" -ElpiVariable">S</span> <span class=" -ElpiVariable">S1</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;(foo bar) ~&gt;&quot;</span> <span class=" -ElpiVariable">S1</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(Fst foo bar) ~&gt; foo</blockquote><blockquote class="alectryon-message">(foo bar) ~&gt; app foo bar</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Fst = <span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0</blockquote><blockquote class="alectryon-message">S = app foo bar</blockquote><blockquote class="alectryon-message">S1 = app foo bar</blockquote><blockquote class="alectryon-message">T = app (app (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) foo) bar</blockquote><blockquote class="alectryon-message">T1 = foo</blockquote></div></div></small></span></pre><p>A last test with a lambda term that has no weak head normal form:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Bound</span> <span class="kn">Steps</span> <span class="mi">1000</span>. <span class="c">(* Let&#39;s be cautious *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chka" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chka"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">Delta</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">app</span> x x)<span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">Omega</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">app</span> <span class=" -ElpiVariable">Delta</span> <span class=" -ElpiVariable">Delta</span><span class="k k-ElpiKeyword">,</span>
  whd <span class=" -ElpiVariable">Omega</span> <span class=" -ElpiVariable">Hummm</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;not going to happen&quot;</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">137</span>-<span class="mi">142</span>
Hummm <span class="kr">is</span> linear: name it _Hummm (discard) or Hummm_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="nb">elpi</span> run out of steps (<span class="mi">1000</span>)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Bound</span> <span class="kn">Steps</span> <span class="mi">0</span>.</span></span></pre></div>
<div class="section" id="pi-x-and">
<h2><a class="toc-backref" href="#toc-entry-7"><code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> and <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code></a></h2>
<p>We have seen how to implement substitution using the binders of ŒªProlog.
More often than not we need to move under binders rather than remove them by
substituting some term in place of the bound variable.</p>
<p>In order to move under a binder and inspect the body of a function ŒªProlog
provides the <code class="e elpi">pi</code> quantifier and the <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> connective.</p>
<p>A good showcase for these features is to implement a type checker
for the simply typed lambda calculus.
See also <a class="reference external" href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">the Wikipedia page on the simply typed lambda calculus</a>.</p>
<p>We start by defining the data type of simple types.
We then declare a new predicate <code class="e elpi">of</code> (for &quot;type of&quot;) and finally
we provide two rules, one for each term constructor.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">kind</span>  <span class=" -ElpiFunction">ty</span>   <span class="kt">type</span>.           <span class="c">% the data type of types</span>
  <span class="k k-ElpiKeyword">type</span>  <span class=" -ElpiFunction">arr</span>  <span class="kt">ty</span> <span class="kt">-&gt;</span> <span class="kt">ty</span> <span class="kt">-&gt;</span> <span class="kt">ty</span>. <span class="c">% our type constructor</span>

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">of</span> <span class="k k-ElpiMode">i:</span><span class="kt">term</span>, <span class="k k-ElpiMode">o:</span><span class="kt">ty</span>. <span class="c">% the type checking algorithm</span>

  <span class="c">% for the app node we ensure the head is a function from</span>
  <span class="c">% A to B, and that the argument is of type A</span>
  of (<span class="k k-ElpiKeyword">app</span> <span class=" -ElpiVariable">Hd</span> <span class=" -ElpiVariable">Arg</span>) <span class=" -ElpiVariable">B</span> <span class="k k-ElpiKeyword">:-</span>
    of <span class=" -ElpiVariable">Hd</span> (arr <span class=" -ElpiVariable">A</span> <span class=" -ElpiVariable">B</span>)<span class="k k-ElpiKeyword">,</span> of <span class=" -ElpiVariable">Arg</span> <span class=" -ElpiVariable">A</span>.

  <span class="c">% for lambda, instead of using a context (a list) of bound</span>
  <span class="c">% variables we use pi and ==&gt; , explained below</span>
  of (<span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">F</span>) (arr <span class=" -ElpiVariable">A</span> <span class=" -ElpiVariable">B</span>) <span class="k k-ElpiKeyword">:-</span>
    <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\ of x <span class=" -ElpiVariable">A</span> <span class="k k-ElpiKeyword">==&gt;</span> of (<span class=" -ElpiVariable">F</span> x) <span class=" -ElpiVariable">B</span>.

<span class="si">}}</span>.</span></span></pre><p>The <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">name</span>\ code</code> syntax is reserved, as well as
<code class="e elpi"><span class="k-ElpiKeyword">rule</span> <span class="k-ElpiKeyword">==&gt;</span> code</code>.</p>
<p>Operationally <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ code</code> introduces a fresh
constant <code class="e elpi">c</code> for <code class="e elpi">x</code> and then runs <code class="e elpi">code</code>.
Operationally <code class="e elpi"><span class="k-ElpiKeyword">rule</span> <span class="k-ElpiKeyword">==&gt;</span> code</code> adds <code class="e elpi"><span class="k-ElpiKeyword">rule</span></code> to
the program and runs <code class="e elpi">code</code>.  Such extra rule is
said to be hypothetical.
Both the constant for <code class="e elpi">x</code> and <code class="e elpi"><span class="k-ElpiKeyword">rule</span></code> are
removed once <code class="e elpi">code</code> terminates.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>hypothetical rules are added at the <em>top</em> of the program</p>
<p class="last">Hypothetical rules hence take precedence over static rules, since
they are tried first.</p>
</div>
<p>Note that in this last example the hypothetical rule is going to be
<code class="e elpi">of c <span class="n-ElpiVariable">A</span></code> for a fixed <code class="e elpi"><span class="n-ElpiVariable">A</span></code> and a fresh constant <code class="e elpi">c</code>.
The variable <code class="e elpi"><span class="n-ElpiVariable">A</span></code> is fixed but not assigned yet, meaning
that <code class="e elpi">c</code> has a type, and only one, but we may not know it yet.</p>
<p>Now let's assign a type to Œªx.Œªy.x:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkb"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;The type of Œªx.Œªy.x is:&quot;</span> <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kp">type of</span> <span class="kr">Œª</span><span class="nv">x</span>.<span class="kr">Œª</span><span class="nv">y</span>.x <span class="kr">is</span>: arr X0 (arr X1 X0)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Ty = arr X0 (arr X1 X0)</blockquote></div></div></small></span></pre><p>Let's run this example step by step:</p>
<p>The rule for <code class="e elpi">fun</code> is used:</p>
<ul class="simple">
<li><code class="e elpi">arrow <span class="n-ElpiVariable">A1</span> <span class="n-ElpiVariable">B1</span></code> is assigned to <code class="e elpi"><span class="n-ElpiVariable">Ty</span></code> by unification</li>
<li>the <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> quantifier creates a fresh constant <code class="e elpi">c1</code> to play
the role of <code class="e elpi">x</code></li>
<li>the <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> connective adds the rule <code class="e elpi">of c1 <span class="n-ElpiVariable">A1</span></code> the program</li>
<li>the new query <code class="e elpi">of (fun <span class="n-ElpiVariable">y\</span> c1<span class="o">)</span> <span class="n-ElpiVariable">B1</span></code> is run.</li>
</ul>
<p>Again, the rule for <code class="e elpi">fun</code> is used (since its variables are
universally quantified, we use <code class="e elpi"><span class="n-ElpiVariable">A2</span></code>, <code class="e elpi"><span class="n-ElpiVariable">B2</span></code>... this time):</p>
<ul class="simple">
<li><code class="e elpi">arrow <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">B2</span></code> is assigned to <code class="e elpi"><span class="n-ElpiVariable">B1</span></code> by unification</li>
<li>the <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> quantifier creates a fresh constant <code class="e elpi">c2</code> to play
the role of <code class="e elpi">x</code></li>
<li>the <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> connective adds the rule <code class="e elpi">of c2 <span class="n-ElpiVariable">A2</span></code> the program</li>
<li>the new query <code class="e elpi">of c1 <span class="n-ElpiVariable">B2</span></code> is run.</li>
</ul>
<p>The (hypothetical) rule <code class="e elpi">of c1 <span class="n-ElpiVariable">A1</span></code> is used:</p>
<ul class="simple">
<li>unification assigns <code class="e elpi"><span class="n-ElpiVariable">A1</span></code> to <code class="e elpi"><span class="n-ElpiVariable">B2</span></code></li>
</ul>
<p>The value of <code class="e elpi"><span class="n-ElpiVariable">Ty</span></code> is hence <code class="e elpi">arr <span class="n-ElpiVariable">A1</span> (arr <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">A1</span><span class="o">)</span></code>, a good type
for Œªx.Œªy.x (the first argument and the output have the same type <code class="e elpi"><span class="n-ElpiVariable">A1</span></code>).</p>
<p>What about the term Œªx.(x x) ?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkc"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">Delta</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">app</span> x x)<span class="k k-ElpiKeyword">,</span>
  (of <span class=" -ElpiVariable">Delta</span> <span class=" -ElpiVariable">Ty</span> <span class="k k-ElpiKeyword">;</span> coq.say <span class="s2">&quot;Error:&quot;</span> <span class=" -ElpiVariable">Delta</span> <span class="s2">&quot;has no type&quot;</span>)

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">58</span>-<span class="mi">60</span>
Ty <span class="kr">is</span> linear: name it _Ty (discard) or Ty_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Error: <span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0 has no type</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Delta = <span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0</blockquote><blockquote class="alectryon-message">Ty = X0</blockquote></div></div></small></span></pre><p>The <code class="e elpi"><span class="k-ElpiKeyword">;</span></code> infix operator stands for disjunction. Since we see the message
<code class="e elpi">of</code> failed: the term <code class="e elpi">fun (<span class="n-ElpiVariable">x\</span> app x x<span class="o">)</span></code> is not well typed.</p>
<p>First, the rule for elpi:<code class="highlight coq"><span class="kr">fun</span></code> is selected:</p>
<ul class="simple">
<li><code class="e elpi">arrow <span class="n-ElpiVariable">A1</span> <span class="n-ElpiVariable">B1</span></code> is assigned to <code class="e elpi"><span class="n-ElpiVariable">Ty</span></code> by unification</li>
<li>the <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> quantifier creates a fresh constant <code class="e elpi">c1</code> to play the
role of <code class="e elpi">x</code></li>
<li>the <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> connective adds the rule <code class="e elpi">of c1 <span class="n-ElpiVariable">A1</span></code> the program</li>
<li>the new query <code class="e elpi">of (app c1 c1<span class="o">)</span> <span class="n-ElpiVariable">B1</span></code> is run.</li>
</ul>
<p>Then it's the turn of typing the application:</p>
<ul>
<li><p class="first">the query <code class="e elpi">of c1 (arr <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">B2</span><span class="o">)</span></code> assigns to <code class="e elpi"><span class="n-ElpiVariable">A1</span></code> the
value <code class="e elpi">arr <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">B2</span></code>.  This means that the
hypothetical rule is now <code class="e elpi">of c1 (arr <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">B2</span><span class="o">)</span></code>.</p>
</li>
<li><p class="first">the query <code class="e elpi">of c1 <span class="n-ElpiVariable">A2</span></code> fails because the unification</p>
<pre class="code elpi literal-block">
of c1 <span class="n-ElpiVariable">A2</span> <span class="k-ElpiKeyword">=</span> of c1 (arr <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">B2</span><span class="o">)</span>
</pre>
<p>has no solution, in particular the sub problem <code class="e elpi"><span class="n-ElpiVariable">A2</span> <span class="k-ElpiKeyword">=</span> (arr <span class="n-ElpiVariable">A2</span> <span class="n-ElpiVariable">B2</span><span class="o">)</span></code>
fails the so called occur check.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="logical-foundations">
<span id="foundations"></span><h1><a class="toc-backref" href="#toc-entry-8">Logical foundations</a></h1>
<p>This section tries to link, informally, ŒªProlog with logic, assuming the reader
has some familiarity with first order intuitionistic logic and proof theory.
The reader which is not familiar with that can probably skip this section,
although section <a class="reference internal" href="#functional-style">functional-style</a> contains some explanations about
the scope of variables which are based on the logical foundations of
the language.</p>
<p>The semantics of a ŒªProlog program is given by interpreting
it in terms of logical formulas and proof search in intuitionistic logic.</p>
<p>A rule</p>
<pre class="code elpi literal-block">
p <span class="n-ElpiVariable">A</span> <span class="n-ElpiVariable">B</span> <span class="k-ElpiKeyword">:-</span> q <span class="n-ElpiVariable">A</span> <span class="n-ElpiVariable">C</span><span class="k-ElpiKeyword">,</span> r <span class="n-ElpiVariable">C</span> <span class="n-ElpiVariable">B</span><span class="o">.</span>
</pre>
<p>has to be understood as a formula</p>
<div class="math">
\begin{equation*}
\forall A~B~C, (\mathrm{q}~A~C \wedge  \mathrm{r}~C~B) \rightarrow  \mathrm{p}~A~B
\end{equation*}
</div>
<p>A query is a goal that is proved by backchaining
rules.  For example <code class="e elpi">p <span class="m-ElpiInteger">3</span> <span class="n-ElpiVariable">X</span></code>
is solved by unifying it with the conclusion of
the formula above (that sets <code class="e elpi"><span class="n-ElpiVariable">A</span></code> to <code class="e elpi"><span class="m-ElpiInteger">3</span></code>) and
generating two new goals, <code class="e elpi">q <span class="m-ElpiInteger">3</span> <span class="n-ElpiVariable">C</span></code> and
<code class="e elpi">r <span class="n-ElpiVariable">C</span> <span class="n-ElpiVariable">B</span></code>. Note that <code class="e elpi"><span class="n-ElpiVariable">C</span></code> is an argument to both
<code class="e elpi">q</code> and <code class="e elpi">r</code> and acts as a link: if solving <code class="e elpi">q</code>
fixes <code class="e elpi"><span class="n-ElpiVariable">C</span></code> then the query for <code class="e elpi">r</code> sees that.
Similarly for <code class="e elpi"><span class="n-ElpiVariable">B</span></code>, that is identified with <code class="e elpi"><span class="n-ElpiVariable">X</span></code>,
and is hence a link from the solution of <code class="e elpi">r</code> to
the solution of <code class="e elpi">p</code>.</p>
<p>A rule like:</p>
<pre class="code elpi literal-block">
of (fun <span class="n-ElpiVariable">F</span><span class="o">)</span> (arr <span class="n-ElpiVariable">A</span> <span class="n-ElpiVariable">B</span><span class="o">)</span> <span class="k-ElpiKeyword">:-</span>
  <span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ of x <span class="n-ElpiVariable">A</span> <span class="k-ElpiKeyword">==&gt;</span> of (<span class="n-ElpiVariable">F</span> x<span class="o">)</span> <span class="n-ElpiVariable">B</span><span class="o">.</span>
</pre>
<p>reads, as a logical formula:</p>
<div class="math">
\begin{equation*}
\forall F~A~B, (\forall x, \mathrm{of}~x~A \rightarrow  \mathrm{of}~(F~x)~B) \rightarrow  \mathrm{of}~(\mathrm{fun}~F)~(\mathrm{arr}~A~B)
\end{equation*}
</div>
<p>where <span class="math">\(F\)</span> stands for a function.
Alternatively, using the inference rule notation typically used for
type systems:</p>
<div class="math">
\begin{equation*}
\frac{\Gamma, \mathrm{of}~x~A \vdash \mathrm{of}~(F~x)~B  \quad   x~\mathrm{fresh}}{\Gamma \vdash \mathrm{of}~(\mathrm{fun}~F)~(\mathrm{arr}~A~B)}
\end{equation*}
</div>
<p>Hence, <code class="e elpi">x</code> and <code class="e elpi">of x <span class="n-ElpiVariable">A</span></code> are available only
temporarily to prove  <code class="e elpi">of (<span class="n-ElpiVariable">F</span> x<span class="o">)</span> <span class="n-ElpiVariable">B</span></code> and this is
also why <code class="e elpi"><span class="n-ElpiVariable">A</span></code> cannot change during this sub proof (<code class="e elpi"><span class="n-ElpiVariable">A</span></code> is
quantified once and forall outside).</p>
<p>Each program execution is a proof (tree) of the query
and is made of the program rules seen as proof rules or axioms.</p>
<p>As we hinted before negation is a black hole, indeed the usual definition of
<span class="math">\(\neg A\)</span> as <span class="math">\(A \to \bot\)</span> is the one of a function with no output
(see also the <a class="reference external" href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#Natural_deduction_and_lambda_calculus">the Wikipedia page on the Curry-Howard correspondence</a>).</p>
</div>
<div class="section" id="modes-and-constraints">
<h1><a class="toc-backref" href="#toc-entry-9">Modes and constraints</a></h1>
<p>Elpi extends ŒªProlog with <em>syntactic constraints</em>
and rules to manipulate the store of constraints.</p>
<p>Syntactic constraints are goals suspended on
a variable which are resumed as soon as that variable
gets instantiated. While suspended they are kept in a store
which can be manipulated by dedicated rules.</p>
<p>A companion facility is the declaration of <em>modes</em>.
The argument of a predicate can be marked as input
to avoid instantiating the goal when it is unified
with the head of a rule (an input argument
is matched, rather than unified).</p>
<p>A simple example: Peano's addition:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> peano <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">kind</span> <span class=" -ElpiFunction">nat</span> <span class="kt">type</span>.
<span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">z</span> <span class="kt">nat</span>.
<span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">s</span> <span class="kt">nat</span> <span class="kt">-&gt;</span> <span class="kt">nat</span>.

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">add</span> <span class="k k-ElpiMode">o:</span><span class="kt">nat</span>, <span class="k k-ElpiMode">o:</span><span class="kt">nat</span>, <span class="k k-ElpiMode">o:</span><span class="kt">nat</span>.

add (s <span class=" -ElpiVariable">X</span>) <span class=" -ElpiVariable">Y</span> (s <span class=" -ElpiVariable">Z</span>) <span class="k k-ElpiKeyword">:-</span> add <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Y</span> <span class=" -ElpiVariable">Z</span>.
add z <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">X</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkd"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  add (s (s z)) (s z) <span class=" -ElpiVariable">R</span><span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;2 + 1 =&quot;</span> <span class=" -ElpiVariable">R</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">2</span> + <span class="mi">1</span> = s (s (s z))</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">R = s (s (s z))</blockquote></div></div></small></span></pre><p>Unfortunately the relation does not work well
when the first argument is a variable.  Depending on the
order of the rules for <code class="e elpi">add</code> Elpi can either diverge or pick
<code class="e elpi">z</code> as a value for <code class="e elpi"><span class="n-ElpiVariable">X</span></code> (that may not be what one wants)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Bound</span> <span class="kn">Steps</span> <span class="mi">100</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chke" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chke"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> add <span class=" -ElpiVariable">X</span> (s z) <span class=" -ElpiVariable">Y</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">48</span>-<span class="mi">49</span>
X <span class="kr">is</span> linear: name it _X (discard) or X_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">56</span>-<span class="mi">57</span>
Y <span class="kr">is</span> linear: name it _Y (discard) or Y_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="nb">elpi</span> run out of steps (<span class="mi">100</span>)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Bound</span> <span class="kn">Steps</span> <span class="mi">0</span>.</span></span></pre><p>Indeed the first rule for add can be applied forever.
If one exchanges the two rules in the program, then Elpi
terminates picking <code class="e elpi">z</code> for <code class="e elpi"><span class="n-ElpiVariable">X</span></code>.</p>
<p>We can use the mode directive in order to
<em>match</em> arguments marked as <code class="e elpi">i<span class="err">:</span></code> against the patterns
in the head of rules, rather than unifying them.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> peano2 <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">kind</span> <span class=" -ElpiFunction">nat</span> <span class="kt">type</span>.
<span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">z</span> <span class="kt">nat</span>.
<span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">s</span> <span class="kt">nat</span> <span class="kt">-&gt;</span> <span class="kt">nat</span>.

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">sum</span> <span class="k k-ElpiMode">i:</span><span class="kt">nat</span>, <span class="k k-ElpiMode">i:</span><span class="kt">nat</span>, <span class="k k-ElpiMode">o:</span><span class="kt">nat</span>.

sum (s <span class=" -ElpiVariable">X</span>) <span class=" -ElpiVariable">Y</span> (s <span class=" -ElpiVariable">Z</span>) <span class="k k-ElpiKeyword">:-</span> sum <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Y</span> <span class=" -ElpiVariable">Z</span>.
sum z <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">X</span>.
sum <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
  coq.error <span class="s2">&quot;nothing matched but for this catch all clause!&quot;</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chkf"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> sum <span class=" -ElpiVariable">X</span> (s z) <span class=" -ElpiVariable">Y</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">255</span>-<span class="mi">256</span>
X <span class="kr">is</span> linear: name it _X (discard) or X_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">263</span>-<span class="mi">264</span>
Y <span class="kr">is</span> linear: name it _Y (discard) or Y_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">nothing matched but <span class="kr">for</span> this catch <span class="kp">all</span> clause!</blockquote></div></div></small></span></pre><p>The query fails because no rule first argument matches <code class="e elpi"><span class="n-ElpiVariable">X</span></code>.</p>
<p>Instead of failing we can suspend goals and turn them into
syntactic constraints</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> peano3 <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">kind</span> <span class=" -ElpiFunction">nat</span> <span class="kt">type</span>.
<span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">z</span> <span class="kt">nat</span>.
<span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">s</span> <span class="kt">nat</span> <span class="kt">-&gt;</span> <span class="kt">nat</span>.

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">sum</span> <span class="k k-ElpiMode">i:</span><span class="kt">nat</span>, <span class="k k-ElpiMode">i:</span><span class="kt">nat</span>, <span class="k k-ElpiMode">o:</span><span class="kt">nat</span>.

sum (s <span class=" -ElpiVariable">X</span>) <span class=" -ElpiVariable">Y</span> (s <span class=" -ElpiVariable">Z</span>) <span class="k k-ElpiKeyword">:-</span> sum <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Y</span> <span class=" -ElpiVariable">Z</span>.
sum z <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">X</span>.
sum <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Y</span> <span class=" -ElpiVariable">Z</span> <span class="k k-ElpiKeyword">:-</span>
  <span class="c">% the head of the rule always unifies with the query, so</span>
  <span class="c">% we double check X is a variable (we could also be</span>
  <span class="c">% here because the other rules failed)</span>
  var <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% then we declare the constraint and schedule its resumption</span>
  <span class="c">% on the assignment of X</span>
  declare_constraint (sum <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Y</span> <span class=" -ElpiVariable">Z</span>) <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk10"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> sum <span class=" -ElpiVariable">X</span> (s z) <span class=" -ElpiVariable">Z</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">479</span>-<span class="mi">480</span>
X <span class="kr">is</span> linear: name it _X (discard) or X_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">487</span>-<span class="mi">488</span>
Z <span class="kr">is</span> linear: name it _Z (discard) or Z_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = X0</blockquote><blockquote class="alectryon-message">Z = X1</blockquote><blockquote class="alectryon-message">Syntactic constraints:
 sum X0 (s z) X1  /* suspended on X0 */</blockquote></div></div></small></span></pre><p>Syntactic constraints are resumed when the variable
they are suspended on is assigned:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk11"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  sum <span class=" -ElpiVariable">X</span> (s z) <span class=" -ElpiVariable">Z</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">=</span> z<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;The result is:&quot;</span> <span class=" -ElpiVariable">Z</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The result <span class="kr">is</span>: s z</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = z</blockquote><blockquote class="alectryon-message">Z = s z</blockquote></div></div></small></span></pre><p>Here a couple more examples. Keep in mind that:</p>
<ul class="simple">
<li>resumption can cause failure</li>
<li>recall that <code class="e elpi"><span class="k-ElpiKeyword">;</span></code> stands for disjunction</li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chk12"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> sum <span class=" -ElpiVariable">X</span> (s z) (s (s z))<span class="k k-ElpiKeyword">,</span>  <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">=</span> z <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command peano3 failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk13"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> sum <span class=" -ElpiVariable">X</span> (s z) (s (s z))<span class="k k-ElpiKeyword">,</span> (<span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">=</span> z <span class="k k-ElpiKeyword">;</span> <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">=</span> s z) <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = s z</blockquote></div></div></small></span></pre><p>In this example the computation suspends, then makes progress,
then suspends again...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk14"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

   sum <span class=" -ElpiVariable">X</span> (s z) <span class=" -ElpiVariable">Y</span><span class="k k-ElpiKeyword">,</span>
   print_constraints<span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;Currently Y =&quot;</span> <span class=" -ElpiVariable">Y</span><span class="k k-ElpiKeyword">,</span>
   <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">=</span> s <span class=" -ElpiVariable">Z</span><span class="k k-ElpiKeyword">,</span>
   print_constraints<span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;Currently Y =&quot;</span> <span class=" -ElpiVariable">Y</span><span class="k k-ElpiKeyword">,</span>
   <span class=" -ElpiVariable">Z</span> <span class="k k-ElpiKeyword">=</span> z<span class="k k-ElpiKeyword">,</span>
   coq.say <span class="s2">&quot;Finally Y =&quot;</span> <span class=" -ElpiVariable">Y</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">sum X0 (s z) X1  /* suspended on X0 */</blockquote><blockquote class="alectryon-message">Currently Y = X1</blockquote><blockquote class="alectryon-message">sum X2 (s z) X3  /* suspended on X2 */</blockquote><blockquote class="alectryon-message">Currently Y = s X3</blockquote><blockquote class="alectryon-message">Finally Y = s (s z)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = s z</blockquote><blockquote class="alectryon-message">Y = s (s z)</blockquote><blockquote class="alectryon-message">Z = z</blockquote></div></div></small></span></pre><p>Sometimes the set of syntactic constraints becomes unsatisfiable
and we would like to be able to fail early.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">even</span> <span class="k k-ElpiMode">i:</span><span class="kt">nat</span>.
<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">odd</span>  <span class="k k-ElpiMode">i:</span><span class="kt">nat</span>.

even z.
even (s <span class=" -ElpiVariable">X</span>) <span class="k k-ElpiKeyword">:-</span> odd <span class=" -ElpiVariable">X</span>.
odd (s <span class=" -ElpiVariable">X</span>) <span class="k k-ElpiKeyword">:-</span> even <span class=" -ElpiVariable">X</span>.

odd <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">:-</span> var <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span> declare_constraint (odd <span class=" -ElpiVariable">X</span>) <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span>.
even <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">:-</span> var <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span> declare_constraint (even <span class=" -ElpiVariable">X</span>) <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk15"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> even (s <span class=" -ElpiVariable">X</span>)<span class="k k-ElpiKeyword">,</span> odd (s <span class=" -ElpiVariable">X</span>) <span class="si">}}</span>. <span class="c">(* hum, not nice *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = X0</blockquote><blockquote class="alectryon-message">Syntactic constraints:
 even X0  /* suspended on X0 */ odd X0  /* suspended on X0 */</blockquote></div></div></small></span></pre><div class="section" id="constraint-handling-rules">
<h2><a class="toc-backref" href="#toc-entry-10">Constraint Handling Rules</a></h2>
<p>A constraint (handling) rule can see the store of syntactic constraints
as a whole, remove constraints and/or create new goals:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">constraint</span> <span class=" -ElpiFunction">even odd </span>{
  <span class="c">% if two distinct, conflicting, constraints about the same X</span>
  <span class="c">% are part of the constraint store</span>
  <span class="k k-ElpiKeyword">rule</span> (even <span class=" -ElpiVariable">X</span>) (odd <span class=" -ElpiVariable">X</span>) <span class="k k-ElpiKeyword">&lt;=&gt;</span>
   <span class="c">% generate the following goal</span>
   (coq.say <span class=" -ElpiVariable">X</span> <span class="s2">&quot;can&#39;t be even and odd at the same time&quot;</span><span class="k k-ElpiKeyword">,</span> fail).
}

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chk16"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> even (s <span class=" -ElpiVariable">X</span>)<span class="k k-ElpiKeyword">,</span> odd (s <span class=" -ElpiVariable">X</span>) <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X0 can&#39;t be even <span class="kn">and</span> odd <span class="nb">at</span> the same <span class="kp">time</span></blockquote><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command peano3 failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small></span></pre><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="e elpi">fail</code> is a predicate with no solution</p>
</div>
<p>See also the Wikipedia page on <a class="reference external" href="https://en.wikipedia.org/wiki/Constraint_Handling_Rules">Constraint Handling Rules</a>
for an introduction to the sub language to manipulate constraints.</p>
</div>
</div>
<div class="section" id="functional-style-1">
<span id="functional-style"></span><h1><a class="toc-backref" href="#toc-entry-11">Functional style</a></h1>
<p>Elpi is a relational language, not a functional one. Still some features
typical of functional programming are available, with some caveats.</p>
<div class="section" id="spilling-relation-composition">
<h2><a class="toc-backref" href="#toc-entry-12">Spilling (relation composition)</a></h2>
<p>Chaining &quot;relations&quot; can be painful, especially when
they look like functions. Here we use <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L526">std.append</a>
and <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L514">std.rev</a> to build a palindrome:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> function <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">make-palindrome</span> <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">A</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">A</span>.

make-palindrome <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">Result</span> <span class="k k-ElpiKeyword">:-</span>
  std.rev <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">TMP</span><span class="k k-ElpiKeyword">,</span>
  std.append <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">TMP</span> <span class=" -ElpiVariable">Result</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk17"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  make-palindrome <span class="k k-ElpiKeyword">[</span><span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">3</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">A</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">193</span>-<span class="mi">194</span>
A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = [<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>]</blockquote></div></div></small></span></pre><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">variables (capital letters) can be used in
types in order to describe ML-like polymorphism.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="e elpi">list <span class="n-ElpiVariable">A</span></code> is a built-in data type</p>
<p class="last">The empty list is written <code class="e elpi"><span class="k-ElpiKeyword">[]</span></code>, while the cons constructor
is written <code class="e elpi"><span class="k-ElpiKeyword">[</span><span class="n-ElpiVariable">Hd</span> <span class="k-ElpiKeyword">|</span> <span class="n-ElpiVariable">Tail</span><span class="k-ElpiKeyword">]</span></code>. Iterated cons can be written
<code class="e elpi"><span class="k-ElpiKeyword">[</span> <span class="n-ElpiVariable">E1</span><span class="k-ElpiKeyword">,</span> <span class="n-ElpiVariable">E2</span> <span class="k-ElpiKeyword">|</span> <span class="n-ElpiVariable">Tail</span> <span class="k-ElpiKeyword">]</span></code> and <code class="e elpi"><span class="k-ElpiKeyword">|</span> <span class="n-ElpiVariable">Tail</span></code> can be omitted if the list
is nil terminated.</p>
</div>
<p>The <code class="e elpi">make-palindrome</code> predicate has to use a temporary variable
just to pass the output of a function as the input to another function.</p>
<p>Spilling is a syntactic elaboration which does that for you.
Expressions between <code class="highlight coq"><span class="o">{</span></code> and <code class="highlight coq"><span class="o">}</span></code> are
said to be spilled out and placed just before the predicate
that contains them.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">make-palindrome2</span> <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">A</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">A</span>.

make-palindrome2 <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">Result</span> <span class="k k-ElpiKeyword">:-</span>
  std.append <span class=" -ElpiVariable">L</span> {std.rev <span class=" -ElpiVariable">L</span>} <span class=" -ElpiVariable">Result</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk18"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  make-palindrome2 <span class="k k-ElpiKeyword">[</span><span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">3</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">A</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">181</span>-<span class="mi">182</span>
A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = [<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>]</blockquote></div></div></small></span></pre><p>The two versions of <code class="e elpi">make-palindrome</code> are equivalent.
Actually the latter is elaborated into the former.</p>
</div>
<div class="section" id="apis-for-built-in-data">
<h2><a class="toc-backref" href="#toc-entry-13">APIs for built-in data</a></h2>
<p>Functions about built-in data types are available via the
<a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L85">calc</a> predicate or its infix version <code class="e elpi"><span class="k-ElpiKeyword">is</span></code>. Example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk19"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

   calc ( <span class="s2">&quot;result &quot;</span> <span class="k k-ElpiKeyword">^</span> <span class="s2">&quot;=&quot;</span> ) <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span>
   <span class=" -ElpiVariable">Y</span> <span class="k k-ElpiKeyword">is</span> <span class="m m-ElpiInteger">3</span> <span class="k k-ElpiKeyword">+</span> <span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span>
   coq.say <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">Y</span> 

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">result = <span class="mi">5</span></blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">X = result =</blockquote><blockquote class="alectryon-message">Y = <span class="mi">5</span></blockquote></div></div></small></span></pre><p>The <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L85">calc</a> predicate works nicely with spilling:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1a"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> coq.say <span class="s2">&quot;result =&quot;</span> {calc (<span class="m m-ElpiInteger">2</span> <span class="k k-ElpiKeyword">+</span> <span class="m m-ElpiInteger">3</span>)} <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">result = <span class="mi">5</span></blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">%arg1 = <span class="mi">5</span></blockquote></div></div></small></span></pre></div>
<div class="section" id="allocation-of-variables">
<h2><a class="toc-backref" href="#toc-entry-14">Allocation of variables</a></h2>
<p>The language let's one use Œª-abstraction also to write anonymous rules
but one has to be wary of where variables are bound (allocated really).</p>
<p>In our example we use the higher order predicate <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L573">std.map</a>:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span> <span class="n-ElpiFunction">std.map</span> <span class="k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">A</span>, <span class="k-ElpiMode">i:</span><span class="kt">(A</span> <span class="err">-</span><span class="kt">&gt;</span> <span class="kt">B</span> <span class="err">-</span><span class="kt">&gt;</span> <span class="kt">prop)</span>, <span class="k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">B</span>.
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="e elpi">prop</code> is the type of predicates</p>
<p>The actual type of the <code class="e elpi">std.map</code> symbol is:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">std.map</span> <span class="kt">list</span> <span class="kt">A</span> <span class="kt">-&gt;</span> <span class="kt">(A</span> <span class="kt">-&gt;</span> <span class="kt">B</span> <span class="kt">-&gt;</span> <span class="kt">prop)</span> <span class="kt">-&gt;</span> <span class="kt">list</span> <span class="kt">B</span> <span class="kt">-&gt;</span> <span class="kt">prop</span>.
</pre>
<p class="last">The <code class="e elpi">pred</code> directive complements a type declaration for predicates
(the trailing <code class="e elpi"><span class="k-ElpiKeyword">-&gt;</span> prop</code> is implicit) with a mode declaration for
each argument.</p>
</div>
<p>The type of the second argument of <code class="e elpi">std.map</code>
is the one of a predicate relating <code class="e elpi"><span class="n-ElpiVariable">A</span></code> with <code class="e elpi"><span class="n-ElpiVariable">B</span></code>.</p>
<p>Let's try to call <code class="e elpi">std.map</code> passing an anonymous rule (as we
would do in a functional language by passing an anonymous function):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">bad</span> <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">int</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">int</span>.

bad <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">Result</span> <span class="k k-ElpiKeyword">:-</span>
  std.map <span class=" -ElpiVariable">L</span> (<span class=" -ElpiVariable">x\</span> <span class=" -ElpiVariable">r\</span> <span class=" -ElpiVariable">TMP</span> <span class="k k-ElpiKeyword">is</span> x <span class="k k-ElpiKeyword">+</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> r <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">TMP</span>) <span class=" -ElpiVariable">Result</span>.

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">good</span> <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">int</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">int</span>.
good <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">Result</span> <span class="k k-ElpiKeyword">:-</span>
  std.map <span class=" -ElpiVariable">L</span> good.aux <span class=" -ElpiVariable">Result</span>.
good.aux <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">R</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">TMP</span> <span class="k k-ElpiKeyword">is</span> <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">+</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">R</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">TMP</span>.

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">good2</span> <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">int</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">int</span>.
good2 <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">Result</span> <span class="k k-ElpiKeyword">:-</span>
  std.map <span class=" -ElpiVariable">L</span> (<span class=" -ElpiVariable">x\</span> <span class=" -ElpiVariable">r\</span> <span class="k k-ElpiKeyword">sigma</span> <span class=" -ElpiVariable">TMP</span>\ <span class=" -ElpiVariable">TMP</span> <span class="k k-ElpiKeyword">is</span> x <span class="k k-ElpiKeyword">+</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> r <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">TMP</span>) <span class=" -ElpiVariable">Result</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1b"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  not(bad <span class="k k-ElpiKeyword">[</span><span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">3</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">R1</span>)<span class="k k-ElpiKeyword">,</span>
  good <span class="k k-ElpiKeyword">[</span><span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">3</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">R2</span><span class="k k-ElpiKeyword">,</span>
  good2 <span class="k k-ElpiKeyword">[</span><span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">3</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">R3</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">400</span>-<span class="mi">402</span>
R1 <span class="kr">is</span> linear: name it _R1 (discard) or R1_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">420</span>-<span class="mi">422</span>
R2 <span class="kr">is</span> linear: name it _R2 (discard) or R2_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">440</span>-<span class="mi">442</span>
R3 <span class="kr">is</span> linear: name it _R3 (discard) or R3_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">R1 = X0</blockquote><blockquote class="alectryon-message">R2 = [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</blockquote><blockquote class="alectryon-message">R3 = [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</blockquote></div></div></small></span></pre><p>The problem with <code class="e elpi">bad</code> is that <code class="e elpi"><span class="n-ElpiVariable">TMP</span></code> is fresh each time the rule
is used, but not every time the anonymous rule passed to <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L573">map</a>
is used. Technically <code class="e elpi"><span class="n-ElpiVariable">TMP</span></code> is quantified (allocated) where <code class="e elpi"><span class="n-ElpiVariable">L</span></code>
and <code class="e elpi"><span class="n-ElpiVariable">Result</span></code> are.</p>
<p>There are two ways to quantify <code class="e elpi"><span class="n-ElpiVariable">TMP</span></code> correctly, that is inside the
anonymous predicate. One is to actually name the predicate. Another one is
to use the <code class="e elpi"><span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">x</span>\ </code> quantifier to allocate <code class="e elpi"><span class="n-ElpiVariable">TMP</span></code> at every call.
We recommend to name the auxiliary predicate.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">predicates whose name ends in <code class="highlight coq"><span class="o">.</span><span class="n">aux</span></code> don't trigger a missing type
declaration warning</p>
</div>
<p>One last way to skin the cat is to use <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> as follows. It gives us
the occasion to clarify further the scope of variables.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">good3</span> <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">int</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">int</span>.
good3 <span class=" -ElpiVariable">L</span> <span class=" -ElpiVariable">Result</span> <span class="k k-ElpiKeyword">:-</span>
  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">aux</span>\
    (<span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">TMP X R</span>\ aux <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">R</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">TMP</span> <span class="k k-ElpiKeyword">is</span> <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">+</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">R</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">TMP</span>) <span class="k k-ElpiKeyword">==&gt;</span>
    std.map <span class=" -ElpiVariable">L</span> aux <span class=" -ElpiVariable">Result</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1c"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  good3 <span class="k k-ElpiKeyword">[</span><span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">2</span><span class="k k-ElpiKeyword">,</span><span class="m m-ElpiInteger">3</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">R</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">207</span>-<span class="mi">208</span>
R <span class="kr">is</span> linear: name it _R (discard) or R_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">R = [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</blockquote></div></div></small></span></pre><p>In this case the auxiliary predicate <code class="e elpi">aux</code>
is only visible inside <code class="e elpi">good3</code>.
What is interesting to remark is that the quantifications are explicit
in the hypothetical rule, and they indicate clearly that each and every
time <code class="e elpi">aux</code> is used <code class="e elpi"><span class="n-ElpiVariable">TMP</span></code>, <code class="e elpi"><span class="n-ElpiVariable">X</span></code> and <code class="e elpi"><span class="n-ElpiVariable">R</span></code> are fresh.</p>
<p>The <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> quantifier is dual to <code class="e elpi"><span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">x</span>\ </code>: since here it
occurs negatively it has the same meaning. That is, the hypothetical rule
could be written <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">X R</span>\ aux <span class="n-ElpiVariable">X</span> <span class="n-ElpiVariable">R</span> <span class="k-ElpiKeyword">:-</span> <span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">TMP</span>\ <span class="n-ElpiVariable">TMP</span> <span class="k-ElpiKeyword">is</span> <span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">+</span> <span class="m-ElpiInteger">1</span><span class="k-ElpiKeyword">,</span> <span class="n-ElpiVariable">R</span> <span class="k-ElpiKeyword">=</span> <span class="n-ElpiVariable">TMP</span></code>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p><code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> and <code class="e elpi"><span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">x</span>\ </code> can quantify on a bunch of variables
at once</p>
<p class="last">That is, <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x y</span>\ <span class="o">...</span></code> is equivalent to <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ <span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">y</span>\ <span class="o">...</span></code> and
<code class="e elpi"><span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">x y</span>\ <span class="o">...</span></code> is equivalent to <code class="e elpi"><span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">x</span>\ <span class="k-ElpiKeyword">sigma</span> <span class="n-ElpiVariable">y</span>\ <span class="o">...</span></code>.</p>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p><code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> can load more than one clause at once</p>
<p>It is sufficient to put a list on the left hand side, eg <code class="e elpi"><span class="k-ElpiKeyword">[</span> rule1<span class="k-ElpiKeyword">,</span> rule2 <span class="k-ElpiKeyword">]</span> <span class="k-ElpiKeyword">==&gt;</span> code</code>.
Moreover one can synthesize a rule before loading it, eg:</p>
<pre class="code elpi last literal-block">
<span class="n-ElpiVariable">Rules</span> <span class="k-ElpiKeyword">=</span> <span class="k-ElpiKeyword">[</span> one-more-rule <span class="k-ElpiKeyword">|</span> <span class="n-ElpiVariable">ExtraRules</span> <span class="k-ElpiKeyword">],</span> <span class="n-ElpiVariable">Rules</span> <span class="k-ElpiKeyword">==&gt;</span> code
</pre>
</div>
<p>The last remark worth making is that bound variables are intimately related
to universal quantification, while unification variables are related to
existential quantification.  It goes without saying that the following
two formulas are not equivalent and while the former is trivial the latter
is in general false:</p>
<div class="math">
\begin{align*}
\forall x, \exists Y, Y = x\\
\exists Y, \forall x, Y = x
\end{align*}
</div>
<p>Let's run these two corresponding queries:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1d"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\ <span class="k k-ElpiKeyword">sigma</span> <span class=" -ElpiVariable">Y</span>\ <span class=" -ElpiVariable">Y</span> <span class="k k-ElpiKeyword">=</span> x<span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;Y =&quot;</span> <span class=" -ElpiVariable">Y</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Y = c0</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chk1e"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> <span class="k k-ElpiKeyword">sigma</span> <span class=" -ElpiVariable">Y</span>\ <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\ <span class=" -ElpiVariable">Y</span> <span class="k k-ElpiKeyword">=</span> x<span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;Y =&quot;</span> <span class=" -ElpiVariable">Y</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command function failed without giving
a specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small></span></pre><p>Another way to put it: <code class="e elpi">x</code> is in the scope of <code class="e elpi"><span class="n-ElpiVariable">Y</span></code> only in the first
formula since it is quantified before it. Hence <code class="e elpi">x</code> can be assigned to
<code class="e elpi"><span class="n-ElpiVariable">Y</span></code> in that case, but not in the second query, where it is quantified
after.</p>
<p>More in general, ŒªProlog tracks the bound variables that are in scope of each
unification variable. There are only two ways to put a bound variable
in the scope:</p>
<ul>
<li><p class="first">quantify the unification variable under the bound one (first formula)</p>
</li>
<li><p class="first">pass the bound variable to the unification variable explicitly: in this
case the unification variable needs to have a functional type.
Indeed <span class="math">\(\exists Y, \forall x, (Y x) = x\)</span> has a solution: <code class="e elpi"><span class="n-ElpiVariable">Y</span></code> can be
the identity function.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1f"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> <span class="k k-ElpiKeyword">sigma</span> <span class=" -ElpiVariable">Y</span>\ <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\ <span class=" -ElpiVariable">Y</span> x <span class="k k-ElpiKeyword">=</span> x<span class="k k-ElpiKeyword">,</span> coq.say <span class="s2">&quot;Y =&quot;</span> <span class=" -ElpiVariable">Y</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Y = c1 \ c1</blockquote></div></div></small></span></pre></li>
</ul>
<p>If we look again at the rule for type checking
Œª-abstraction:</p>
<pre class="code elpi literal-block">
of (fun <span class="n-ElpiVariable">F</span><span class="o">)</span> (arr <span class="n-ElpiVariable">A</span> <span class="n-ElpiVariable">B</span><span class="o">)</span> <span class="k-ElpiKeyword">:-</span>
  <span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ of x <span class="n-ElpiVariable">A</span> <span class="k-ElpiKeyword">==&gt;</span> of (<span class="n-ElpiVariable">F</span> x<span class="o">)</span> <span class="n-ElpiVariable">B</span><span class="o">.</span>
</pre>
<p>we can see that the only unification variable that sees the fresh
<code class="highlight coq"><span class="n">x</span></code> is <code class="e elpi"><span class="n-ElpiVariable">F</span></code>, because we pass <code class="e elpi">x</code> to <code class="e elpi"><span class="n-ElpiVariable">F</span></code> explicitly
(recall all unification variables such as <code class="e elpi"><span class="n-ElpiVariable">F</span></code>, <code class="e elpi"><span class="n-ElpiVariable">A</span></code>, <code class="e elpi"><span class="n-ElpiVariable">B</span></code> are
quantified upfront, before the <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code>).
Indeed when we write:</p>
<div class="math">
\begin{equation*}
\frac{\Gamma, x : A \vdash f : B}{\Gamma \vdash \lambda x.f : A \rightarrow  B}
\end{equation*}
</div>
<p>on paper, the variable denoted by <code class="e elpi">x</code> being bound there can only occur in
<span class="math">\(f\)</span>, not in <span class="math">\(\Gamma\)</span> or <span class="math">\(B\)</span> for example (although a
<em>different</em> variable could be named the same, hence the usual freshness side
conditions which are not really necessary using HOAS).</p>
<p>Remark that in the premise the variable <span class="math">\(x\)</span> is still bound, this time
not by a Œª-abstraction but by the context <span class="math">\(\Gamma, x : A\)</span>.
In ŒªProlog the context is the set of hypothetical rules and <code class="e elpi"><span class="n-ElpiVariable">pi\</span> </code>
-quantified variables and is implicitly handled by the runtime of the
programming language.</p>
<p>A slogan to keep in mind is that:</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">There is no such thing as a free variable!</p>
</div>
<p>Indeed the variable bound by the Œª-abstraction (of our data) is
replaced by a fresh variable bound by the context (of our program). This is
called binder mobility. See also the paper 
<a class="reference external" href="https://hal.inria.fr/hal-01884210/">Mechanized metatheory revisited</a> by
Dale Miller which is an excellent
introduction to these concepts.</p>
</div>
</div>
<div class="section" id="debugging">
<h1><a class="toc-backref" href="#toc-entry-15">Debugging</a></h1>
<p>The most sophisticated debugging feature can be used via
the Visual Studio Code extension <tt class="docutils literal"><span class="pre">gares.elpi-lang</span></tt> and its
<tt class="docutils literal">Elpi Tracer</tt> tab.</p>
<div class="section" id="trace-browser">
<h2><a class="toc-backref" href="#toc-entry-16">Trace browser</a></h2>
<p>In order to generate a trace one needs to execute the
<tt class="docutils literal">Elpi Trace Browser.</tt> command and then run any Elpi code.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Elpi Trace Browser. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk20"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span> <span class="c">% We run the query in the stlc program</span>

  of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">arr X0 (arr X1 X0)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Ty = arr X0 (arr X1 X0)</blockquote></div></div></small></span></pre><p>The trace file is generated in <tt class="docutils literal">/tmp/traced.tmp.json</tt>. 
If it does not load automatically one can do it manually by clicking on
the load icon, in the upper right corner of the Elpi Tracer panel.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>partial display of goals</p>
<p class="last">At the time of writing one may need to disable syntax highlighting in
the extension settings in order to get a correct display.</p>
</div>
<p>The trace browser displays, on the left column, a list of cards corresponding
to a step performed by the interpreter. The right side of the
panel gives more details about the selected step. In the image below one
can see the goal, the rule being applied, the assignments performed by the
unification of the rule's head with the goal, the subgoals generated.</p>
<img alt="tracer.png" src="tracer.png" style="width: 800px;" />
<p>One can also look at the trace in text format (if VSCode is not an option,
for example).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Trace</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk21"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span> <span class="c">% We run the query in the stlc program</span>

  of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">run <span class="mi">1</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">4</span> user:curgoal = , 
                                  of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 , coq.say X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">4</span> user:rule = <span class="kn">and</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">4</span> user:subgoal = <span class="mi">5</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">5</span> user:newgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">4</span> user:subgoal = <span class="mi">6</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">6</span> user:newgoal = coq.say X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">4</span> user:rule:<span class="kn">and</span> = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">2</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">5</span> user:curgoal = of 
                                  of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">5</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">5</span> user:rule:backchain:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">3</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">5</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
                                             (of (<span class="kr">fun</span> <span class="nv">A0</span>) (arr A2 A1)) :- (
                                              pi (c0 \
                                               (of c0 A2 =&gt; of (A0 c0) A1))). 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = A0 := c0 \
                                 <span class="kr">fun</span> <span class="nv">c1</span> \ c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = X0 := arr X1 X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">5</span> user:subgoal = <span class="mi">7</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:newgoal = pi c0 \ of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">3</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">7</span> user:curgoal = pi 
                                  pi c0 \ of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">7</span> user:rule = pi 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">7</span> user:subgoal = <span class="mi">8</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">8</span> user:newgoal = of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">8</span> user:rule:pi = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">4</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">8</span> user:curgoal = =&gt; 
                                  of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">8</span> user:rule = implication 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">8</span> user:subgoal = <span class="mi">9</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">9</span> user:newgoal = of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">9</span> user:rule:implication = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">9</span> user:curgoal = of 
                                  of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">9</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">9</span> user:rule:backchain:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">4</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">9</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
                                             (of (<span class="kr">fun</span> <span class="nv">A0</span>) (arr A2 A1)) :- (
                                              pi (c0 \
                                               (of c0 A2 =&gt; of (A0 c0) A1))). 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A0 := c1 \
                                 c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = X2 := arr X3 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">9</span> user:subgoal = <span class="mi">10</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:newgoal = pi c1 \ of c1 X3 =&gt; of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">6</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">10</span> user:curgoal = pi 
                                   pi c1 \ of c1 X3 =&gt; of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">10</span> user:rule = pi 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">10</span> user:subgoal = <span class="mi">11</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">11</span> user:newgoal = of c1 X3 =&gt; of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">11</span> user:rule:pi = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">7</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">11</span> user:curgoal = =&gt; 
                                   of c1 X3 =&gt; of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">11</span> user:rule = implication 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">11</span> user:subgoal = <span class="mi">12</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">12</span> user:newgoal = of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">12</span> user:rule:implication = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">8</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">12</span> user:curgoal = of 
                                   of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">12</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">12</span> user:rule:backchain:candidates = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">12</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
                                              (of c0 X1) :- . 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X1 := X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">12</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">9</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:curgoal = coq.say 
                                  coq.say (arr X4 (arr X3 X4)) 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:rule = builtin 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:rule:builtin:name = coq.say 
</blockquote><blockquote class="alectryon-message">arr X4 (arr X3 X4)</blockquote><blockquote class="alectryon-message">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:rule:builtin = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Ty = arr X4 (arr X3 X4)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chk22"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

  of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">app</span> x x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">run <span class="mi">1</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">13</span> user:curgoal = , 
                                   of (<span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0) X0 , coq.say X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">13</span> user:rule = <span class="kn">and</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">13</span> user:subgoal = <span class="mi">14</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">14</span> user:newgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0) X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">13</span> user:subgoal = <span class="mi">15</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">15</span> user:newgoal = coq.say X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">13</span> user:rule:<span class="kn">and</span> = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">2</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">14</span> user:curgoal = of 
                                   of (<span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0) X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">14</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">14</span> user:rule:backchain:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">3</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">14</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
                                              (of (<span class="kr">fun</span> <span class="nv">A0</span>) (arr A2 A1)) :- (
                                               pi (c0 \
                                                (of c0 A2 =&gt; of (A0 c0) A1))). 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = A0 := c0 \
                                 app c0 c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = X0 := arr X1 X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">14</span> user:subgoal = <span class="mi">16</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:newgoal = pi c0 \ of c0 X1 =&gt; of (app c0 c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">3</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">16</span> user:curgoal = pi 
                                   pi c0 \ of c0 X1 =&gt; of (app c0 c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">16</span> user:rule = pi 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">16</span> user:subgoal = <span class="mi">17</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">17</span> user:newgoal = of c0 X1 =&gt; of (app c0 c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">17</span> user:rule:pi = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">4</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">17</span> user:curgoal = =&gt; 
                                   of c0 X1 =&gt; of (app c0 c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">17</span> user:rule = implication 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">17</span> user:subgoal = <span class="mi">18</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">18</span> user:newgoal = of (app c0 c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">18</span> user:rule:implication = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">18</span> user:curgoal = of 
                                   of (app c0 c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">18</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">18</span> user:rule:backchain:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">10</span>, column <span class="mi">2</span>, characters <span class="mi">293</span>-<span class="mi">343</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">4</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">18</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">10</span>, column <span class="mi">2</span>, characters <span class="mi">293</span>-<span class="mi">343</span>: 
                                              (of (app A0 A3) A2) :- (
                                               of A0 (arr A1 A2)), 
                                               (of A3 A1). 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A0 := c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A3 := c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A2 := X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">18</span> user:subgoal = <span class="mi">19</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:newgoal = of c0 (arr X3^<span class="mi">1</span> X2) 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:subgoal = <span class="mi">20</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">20</span> user:newgoal = of c0 X3^<span class="mi">1</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">6</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">19</span> user:curgoal = of 
                                   of c0 (arr X3^<span class="mi">1</span> X2) 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">19</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">19</span> user:rule:backchain:candidates = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">19</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
                                              (of c0 X1) :- . 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">0</span> user:assign:expand = X3^<span class="mi">1</span> := X4 c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">0</span> user:assign:restrict = <span class="mi">0</span> X4 c0 := c0 \
                                          .X5 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">0</span> user:assign = X1 := arr X5 X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">19</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">7</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:curgoal = of 
                                   of c0 X5 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:rule:backchain:candidates = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">6</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
                                              (of c0 (arr X5 X2)) :- . 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:backchain:<span class="kp">fail</span>-to = <span class="nb">unify</span> X5 <span class="kr">with</span> arr X5 X2 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">7</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:rule:backchain = <span class="kp">fail</span> 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command stlc failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small></span></pre><p>The trace can be limited to a range of steps. Look at the
numbers <tt class="docutils literal">run HERE {{{</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Trace</span> <span class="mi">6</span> <span class="mi">8</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk23"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

  of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">run <span class="mi">6</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">27</span> user:curgoal = pi 
                                   pi c1 \ of c1 X0 =&gt; of c0 X1 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">27</span> user:rule = pi 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">27</span> user:subgoal = <span class="mi">28</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">28</span> user:newgoal = of c1 X0 =&gt; of c0 X1 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">28</span> user:rule:pi = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">7</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">28</span> user:curgoal = =&gt; 
                                   of c1 X0 =&gt; of c0 X1 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">28</span> user:rule = implication 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">28</span> user:subgoal = <span class="mi">29</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">29</span> user:newgoal = of c0 X1 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">29</span> user:rule:implication = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">8</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">29</span> user:curgoal = of 
                                   of c0 X1 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">29</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">29</span> user:rule:backchain:candidates = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">29</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
                                              (of c0 X2) :- . 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X2 := X1 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">29</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">arr X1 (arr X0 X1)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Ty = arr X1 (arr X0 X1)</blockquote></div></div></small></span></pre><p>The trace can be limited to a (list of) predicates as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Trace</span> <span class="s2">&quot;of&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk24"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

  of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">run <span class="mi">2</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">31</span> user:curgoal = of 
                                   of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">31</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">31</span> user:rule:backchain:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">3</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">31</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
                                              (of (<span class="kr">fun</span> <span class="nv">A0</span>) (arr A2 A1)) :- (
                                               pi (c0 \
                                                (of c0 A2 =&gt; of (A0 c0) A1))). 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = A0 := c0 \
                                 <span class="kr">fun</span> <span class="nv">c1</span> \ c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = X0 := arr X1 X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">31</span> user:subgoal = <span class="mi">33</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:newgoal = pi c0 \ of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">35</span> user:curgoal = of 
                                   of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">35</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">35</span> user:rule:backchain:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">4</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">35</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">2</span>, characters <span class="mi">459</span>-<span class="mi">514</span>: 
                                              (of (<span class="kr">fun</span> <span class="nv">A0</span>) (arr A2 A1)) :- (
                                               pi (c0 \
                                                (of c0 A2 =&gt; of (A0 c0) A1))). 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A0 := c1 \
                                 c0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = X2 := arr X3 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">35</span> user:subgoal = <span class="mi">36</span> 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:newgoal = pi c1 \ of c1 X3 =&gt; of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">run <span class="mi">8</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">38</span> user:curgoal = of 
                                   of c0 X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">38</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">38</span> user:rule:backchain:candidates = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">38</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
                                              (of c0 X1) :- . 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X1 := X4 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">38</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">arr X4 (arr X3 X4)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Ty = arr X4 (arr X3 X4)</blockquote></div></div></small></span></pre><p>One can combine the range of steps with the predicate:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Trace</span> <span class="mi">6</span> <span class="mi">8</span> <span class="s2">&quot;of&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk25"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

  of (<span class="k k-ElpiKeyword">fun</span> (<span class=" -ElpiVariable">x\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">y\</span> x)) <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">Ty</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">run <span class="mi">8</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">47</span> user:curgoal = of 
                                   of c0 X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">47</span> user:rule = backchain 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">47</span> user:rule:backchain:candidates = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">select <span class="mi">5</span> {{{  
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">47</span> user:rule:backchain:<span class="kp">try</span> = File <span class="s2">&quot;(context step_id:4)&quot;</span>, line <span class="mi">1</span>, column <span class="mi">0</span>, characters <span class="mi">0</span>-<span class="mi">0</span>: 
                                              (of c0 X1) :- . 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X1 := X0 
</blockquote><blockquote class="alectryon-message">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">47</span> user:rule:backchain = success 
</blockquote><blockquote class="alectryon-message">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</blockquote><blockquote class="alectryon-message">arr X0 (arr X2 X0)</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Ty = arr X0 (arr X2 X0)</blockquote></div></div></small></span></pre><p>To switch traces off:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Trace</span> Off.</span></span></pre></div>
<div class="section" id="good-old-print">
<h2><a class="toc-backref" href="#toc-entry-17">Good old print</a></h2>
<p>A common ŒªProlog idiom is to have a debug rule
lying around.  The <code class="e elpi"><span class="err">:</span>if</code> attribute can be used to
make the rule conditionally interpreted (only if the
given debug variable is set).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> Debug <span class="s2">&quot;DEBUG_MYPRED&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Program</span> <span class="kn">debug</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">mypred</span> <span class="k k-ElpiMode">i:</span><span class="kt">int</span>.

  <span class="k k-ElpiMode">:if</span> <span class="s2">&quot;DEBUG_MYPRED&quot;</span>
  mypred <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">:-</span>
    coq.say <span class="s2">&quot;calling mypred on &quot;</span> <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">,</span> fail.

  mypred <span class="m m-ElpiInteger">0</span> <span class="k k-ElpiKeyword">:-</span> coq.say <span class="s2">&quot;ok&quot;</span>.
  mypred <span class=" -ElpiVariable">M</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">N</span> <span class="k k-ElpiKeyword">is</span> <span class=" -ElpiVariable">M</span> <span class="k k-ElpiKeyword">-</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> mypred <span class=" -ElpiVariable">N</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk26"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> mypred <span class="m m-ElpiInteger">3</span> <span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">calling mypred on  <span class="mi">3</span></blockquote><blockquote class="alectryon-message">calling mypred on  <span class="mi">2</span></blockquote><blockquote class="alectryon-message">calling mypred on  <span class="mi">1</span></blockquote><blockquote class="alectryon-message">calling mypred on  <span class="mi">0</span></blockquote><blockquote class="alectryon-message">ok</blockquote></div></div></small></span></pre></div>
<div class="section" id="printing-entire-programs">
<h2><a class="toc-backref" href="#toc-entry-18">Printing entire programs</a></h2>
<p>Given that programs are not written in a single place, but rather obtained by
accumulating code, Elpi is able to print a (full) program to an text file
as follows. The obtained file provides a facility to filter rules by their
predicate. Note that the first component of the path is a Coq Load Path (i.e.
coqc options -R and -Q), the text file will be placed in the directory
bound to it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Print</span> stlc <span class="s2">&quot;elpi_examples/stlc&quot;</span>.</span></span></pre><p>Look at the <a class="reference external" href="https://lpcic.github.io/coq-elpi/stlc.txt">generated page</a>.
Finally, one can bound the number of backchaining steps
performed by the interpreter:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> <span class="m m-ElpiInteger">0</span> <span class="k k-ElpiKeyword">=</span> <span class="m m-ElpiInteger">0</span><span class="k k-ElpiKeyword">,</span> <span class="m m-ElpiInteger">1</span> <span class="k k-ElpiKeyword">=</span> <span class="m m-ElpiInteger">1</span> <span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Bound</span> <span class="kn">Steps</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chk27"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span> <span class="m m-ElpiInteger">0</span> <span class="k k-ElpiKeyword">=</span> <span class="m m-ElpiInteger">0</span><span class="k k-ElpiKeyword">,</span> <span class="m m-ElpiInteger">1</span> <span class="k k-ElpiKeyword">=</span> <span class="m m-ElpiInteger">1</span> <span class="si">}}</span>. <span class="c">(* it needs 2 steps! *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="nb">elpi</span> run out of steps (<span class="mi">1</span>)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Bound</span> <span class="kn">Steps</span> <span class="mi">0</span>. <span class="c">(* Go back to no bound *)</span></span></span></pre></div>
<div class="section" id="common-pitfalls">
<h2><a class="toc-backref" href="#toc-entry-19">Common pitfalls</a></h2>
<p>Well, no programming language is perfect.</p>
<div class="section" id="precedence-of-e-and">
<h3><a class="toc-backref" href="#toc-entry-20">Precedence of <code class="e elpi"><span class="k-ElpiKeyword">,</span></code>, :e: <code class="highlight coq"><span class="o">==&gt;</span></code> and <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code></a></h3>
<p>In this tutorial we only used :e: <code class="highlight coq"><span class="o">==&gt;</span></code> but Elpi also provides
the standard ŒªProlog implication <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code>. They have the same meaning
but different precedences w.r.t. <code class="e elpi"><span class="k-ElpiKeyword">,</span></code>.</p>
<p>The code <code class="e elpi">a<span class="k-ElpiKeyword">,</span> c <span class="k-ElpiKeyword">==&gt;</span> d<span class="k-ElpiKeyword">,</span> e</code> reads <code class="e elpi">a<span class="k-ElpiKeyword">,</span> (c <span class="k-ElpiKeyword">==&gt;</span> <span class="o">(</span>d<span class="k-ElpiKeyword">,</span>e<span class="o">))</span></code>, that means that
the rule <code class="e elpi">c</code> is available to both <code class="e elpi">d</code> and <code class="e elpi">e</code>.</p>
<p>On the contrary the code <code class="e elpi">a<span class="k-ElpiKeyword">,</span> c <span class="k-ElpiKeyword">=&gt;</span> d<span class="k-ElpiKeyword">,</span> e</code> reads <code class="e elpi">a<span class="k-ElpiKeyword">,</span> (c <span class="k-ElpiKeyword">==&gt;</span> d<span class="o">)</span><span class="k-ElpiKeyword">,</span> e</code>,
making <code class="e elpi">c</code> only available to <code class="e elpi">d</code>.</p>
<p>So, <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> binds stronger than <code class="e elpi"><span class="k-ElpiKeyword">,</span></code>, while <code class="e elpi"><span class="k-ElpiKeyword">==&gt;</span></code> binds stronger only
on the left.</p>
<p>According to our experience the precedence of <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> is a common source
of mistakes for beginners, if only because it is not stable by adding of
debug prints, that is <code class="e elpi">a <span class="k-ElpiKeyword">=&gt;</span> b</code> and <code class="e elpi">a <span class="k-ElpiKeyword">=&gt;</span> print <span class="s2">&quot;doing b&quot;</span><span class="k-ElpiKeyword">,</span> b</code> have
very different meaning (<code class="e elpi">a</code> becomes only available to <code class="highlight coq"><span class="n">print</span></code>!).</p>
<p>In this tutorial we only used <code class="e elpi"><span class="k-ElpiKeyword">==&gt;</span></code> that was introduced in Elpi 2.0, but
there is code out there using <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code>. Elpi 2.0 raises a warning if the
right hand side of <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code> is a conjenction with no parentheses.</p>
<p>A concrete example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-elpi-lang-v-chk28"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

   <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
     of x <span class=" -ElpiVariable">A</span> <span class="k k-ElpiKeyword">=&gt;</span> of x <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">,</span> of x <span class=" -ElpiVariable">C</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">42</span>-<span class="mi">58</span>
The standard <span class="kr">Œª</span><span class="nv">Prolog</span> <span class="nv">infix</span> <span class="nv">operator</span> <span class="nv">for</span> <span class="nv">implication</span> =&gt; has higher precedence
than conjunction. This means that &#39;A =&gt; B, C&#39; reads &#39;(A =&gt; B), C&#39;.
This <span class="kr">is</span> a common mistake since it makes A <span class="kp">only</span> available to B (<span class="kn">and</span> not to C
<span class="kr">as</span> many newcomers may expect).
If this <span class="kr">is</span> really what you want write &#39;(A =&gt; B), C&#39; to silence this warning.
Otherwise write &#39;A =&gt; (B, C)&#39;, or use the alternative implication operator ==&gt;.
<span class="kn">Infix</span> ==&gt;  has lower precedence than conjunction, hence
&#39;A ==&gt; B, C&#39; reads &#39;A ==&gt; (B, C)&#39; <span class="kn">and</span> means the same <span class="kr">as</span> &#39;A =&gt; (B, C)&#39;.
[<span class="nb">elpi</span>.implication-precedence,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">47</span>-<span class="mi">48</span>
A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">57</span>-<span class="mi">58</span>
B <span class="kr">is</span> linear: name it _B (discard) or B_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">65</span>-<span class="mi">66</span>
C <span class="kr">is</span> linear: name it _C (discard) or C_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command stlc failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk29"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
    of x <span class=" -ElpiVariable">A</span> <span class="k k-ElpiKeyword">=&gt;</span> (of x <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">,</span> of x <span class=" -ElpiVariable">C</span>) <span class="c">% both goals see of x A</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">126</span>-<span class="mi">127</span>
A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">137</span>-<span class="mi">138</span>
B <span class="kr">is</span> linear: name it _B (discard) or B_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">145</span>-<span class="mi">146</span>
C <span class="kr">is</span> linear: name it _C (discard) or C_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = X0</blockquote><blockquote class="alectryon-message">B = X0</blockquote><blockquote class="alectryon-message">C = X0</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk2a"><span class="kn">Elpi</span> <span class="kn">Query</span> stlc <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
    of x <span class=" -ElpiVariable">A</span> <span class="k k-ElpiKeyword">==&gt;</span> of x <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">,</span> of x <span class=" -ElpiVariable">C</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">218</span>-<span class="mi">219</span>
A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">229</span>-<span class="mi">230</span>
B <span class="kr">is</span> linear: name it _B (discard) or B_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">237</span>-<span class="mi">238</span>
C <span class="kr">is</span> linear: name it _C (discard) or C_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.linear-variable,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = X0</blockquote><blockquote class="alectryon-message">B = X0</blockquote><blockquote class="alectryon-message">C = X0</blockquote></div></div></small></span></pre></div>
<div class="section" id="backtracking-1">
<h3><a class="toc-backref" href="#toc-entry-21">Backtracking</a></h3>
<p>Backtracking can lead to weird execution traces. The <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L718">std.do!</a> predicate
should be used to write non-backtracking code.</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span> <span class="n-ElpiFunction">not-a-backtracking-one</span>.
not-a-backtracking-one <span class="k-ElpiKeyword">:-</span> condition<span class="k-ElpiKeyword">,</span> <span class="k-ElpiKeyword">!,</span> std.do! <span class="k-ElpiKeyword">[</span>
  step<span class="k-ElpiKeyword">,</span>
  (generate<span class="k-ElpiKeyword">,</span> test<span class="o">)</span><span class="k-ElpiKeyword">,</span>
  step<span class="k-ElpiKeyword">,</span>
<span class="k-ElpiKeyword">]</span><span class="o">.</span>
</pre>
<p>In the example above once <code class="e elpi">condition</code> holds we start a sequence of
steps which we will not reconsider. Locally, backtracking is still
available, e.g. between <code class="e elpi">generate</code> and <code class="e elpi">test</code>.
See also the <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L730">std.spy-do!</a> predicate which prints each and every step,
and the <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/26d13b5f4f8524fd01b8f88f4cffb2e8f835fef0/builtin-doc/elpi-builtin.elpi#L488">std.spy</a> one which can be used to spy on a single one.</p>
</div>
<div class="section" id="unification-variables-v-s-imperative-variables">
<h3><a class="toc-backref" href="#toc-entry-22">Unification variables v.s. Imperative variables</a></h3>
<p>Unification variables sit in between variables in imperative programming and
functional programming. In imperative programming a variable can hold a value,
and that value can change over time via assignment. In functional languages
variables always hold a value, and that value never changes. In logic programming
a unification variable can either be unset (no value) or set to a value that
never changes. Backtracking goes back in time, it is not visible to the program.</p>
<p>As a result of this, code like</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span> <span class="n-ElpiFunction">bad-example</span>.
bad-example <span class="k-ElpiKeyword">:-</span> <span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">is</span> <span class="m-ElpiInteger">1</span> <span class="k-ElpiKeyword">+</span> <span class="m-ElpiInteger">2</span><span class="k-ElpiKeyword">,</span> <span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">is</span> <span class="m-ElpiInteger">4</span> <span class="k-ElpiKeyword">+</span> <span class="m-ElpiInteger">5</span><span class="o">.</span>
</pre>
<p>fails, because <code class="e elpi"><span class="n-ElpiVariable">X</span></code> cannot be at the same time 3 and 9. Initially
<code class="e elpi"><span class="n-ElpiVariable">X</span></code> is unset, then it is set to 3, and finally the programmer is
asserting that 3 (the value hold by <code class="e elpi"><span class="n-ElpiVariable">X</span></code>) is equal to 9.
The second call to <code class="e elpi"><span class="k-ElpiKeyword">is</span></code> does not change the value carried by <code class="e elpi"><span class="n-ElpiVariable">X</span></code>!</p>
<p>Unification, and hence the <code class="e elpi"><span class="k-ElpiKeyword">=</span></code> predicate, plays two roles.
When <code class="e elpi"><span class="n-ElpiVariable">X</span></code> is unset, <code class="e elpi"><span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">=</span> v</code> sets the variable.
When <code class="e elpi"><span class="n-ElpiVariable">X</span></code> is set to <code class="e elpi">u</code>, <code class="e elpi"><span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">=</span> v</code> checks if the value
of <code class="e elpi"><span class="n-ElpiVariable">X</span></code> is equal to <code class="e elpi">u</code>: it is equivalent to  <code class="e elpi">u <span class="k-ElpiKeyword">=</span> v</code>.</p>
</div>
</div>
</div>
<div class="section" id="further-reading">
<h1><a class="toc-backref" href="#toc-entry-23">Further reading</a></h1>
<p>The <a class="reference external" href="http://www.lix.polytechnique.fr/~dale/lProlog/">ŒªProlog website</a>
contains useful links to ŒªProlog related material.</p>
<p>Papers and other documentation about Elpi can be found at
the <a class="reference external" href="https://github.com/LPCIC/elpi/">Elpi home on github</a>.</p>
<p>Three more tutorials specific to Elpi as an extension language for Coq
can be found in the <a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/examples/">examples folder</a>.
You can continue by reading the one about the 
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_HOAS.html">HOAS for Coq terms</a>.</p>
</div>
</div>
</div>
</div></body>
</html>
