<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="author" content="Enrico Tassi" />
<title>Tutorial on Coq commands</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-coq-commands">
<h1 class="title">Tutorial on Coq commands</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<script>
var style = document.createElement('style');
style.textContent = `
  table.docinfo {
     border-top: none;
     border-bottom: none;
     margin: auto;
  }
  #alectryon-toggle-0 {
     display: none;
  }
  label[for="alectryon-toggle-0"] {
     display: none;
  }
  .alectryon-io {
     border-left-style: dotted;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  pre.alectryon-block {
     padding-left: 1em;
  }
  label.alectryon-input.alectryon-failed {
     text-decoration: red wavy underline;
  }
  .alectryon-io label.alectryon-input::after , .alectryon-banner .alectryon-bubble::before {
    content: '';
    background: url("data:image/svg+xml,%3Csvg width='14' height='14' viewBox='0 0 3.704 3.704' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill-rule='evenodd' stroke='%23000' stroke-width='.264'%3E%3Cpath d='M.794.934h2.115M.794 1.463h1.455M.794 1.992h1.852'/%3E%3C/g%3E%3Cpath d='M.132.14v2.646h.794v.661l.926-.661h1.72V.14z' fill='none' stroke='%23000' stroke-width='.265'/%3E%3C/svg%3E") top right no-repeat;
    height: 14px;
    width: 14px;
    border-style: none;
    border-radius: 0px;
  }
  code.coq , code.elpi {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.note, div.tip {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
  .ghref {
    cursor: help;
    text-decoration: underline dotted;
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
  }

  .elpi {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
   }

  .highlight .-ElpiFunction , .highlight .n-ElpiFunction { color: #795E26 }
  .highlight .-ElpiVariable , .highlight .n-ElpiVariable { color: #0000ff }
  .highlight .k-ElpiKeyword { color: #AF00DB }
  .highlight .k-ElpiMode { color: #811f3f }
  .highlight .m-ElpiInteger { color: #098658 }
  .highlight .si { color: rgb(94, 93, 93) }

  .elpi .n-ElpiFunction { color: #795E26 }
  .elpi .n-ElpiVariable { color: #0000ff }
  .elpi .k-ElpiKeyword { color: #AF00DB }
  .elpi .k-ElpiMode { color: #811f3f }
  .elpi .m-ElpiInteger { color: #098658 }
  .elpi .s2 { color: #a31515 }
  .elpi .c { color: #008000 }
  .elpi .kt { color: #2b91af }
  .elpi .si { color: rgb(94, 93, 93) }

  .admonition-title:after { content: ":" }
  .admonition-title { display: inline; margin-right: 0.5em }
  .admonition-title + p { display: inline }

  .important .admonition-title { color: rgb(197, 70, 91) }
  .important { background-color: rgb(272, 237, 243) }

  .note .admonition-title { color: rgb(42, 134, 57) }
  .note { background-color: rgb(222, 247, 222); }


`;
document.getElementsByTagName('head')[0].appendChild(style);

</script><!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with programming constructs that are
designed to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq spefic data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This tutorial assumes the reader is familiar with Elpi and the HOAS
representation of Coq terms; if it is not the case, please take a look at
these other tutorials first:
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_elpi_lang.html">Elpi tutorial</a>
and 
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_HOAS.html">Coq HOAS tutorial</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#defining-commands" id="toc-entry-1">Defining commands</a></li>
<li><a class="reference internal" href="#command-arguments" id="toc-entry-2">Command arguments</a><ul>
<li><a class="reference internal" href="#processing-raw-arguments" id="toc-entry-3">Processing raw arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="toc-entry-4">Examples</a><ul>
<li><a class="reference internal" href="#synthesizing-a-term" id="toc-entry-5">Synthesizing a term</a></li>
<li><a class="reference internal" href="#abstracting-an-inductive" id="toc-entry-6">Abstracting an inductive</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-dbs-to-store-data-across-calls" id="toc-entry-7">Using DBs to store data across calls</a><ul>
<li><a class="reference internal" href="#inspecting-a-db" id="toc-entry-8">Inspecting a Db</a></li>
</ul>
</li>
<li><a class="reference internal" href="#polishing-a-command" id="toc-entry-9">Polishing a command</a><ul>
<li><a class="reference internal" href="#attributes" id="toc-entry-10">Attributes</a></li>
<li><a class="reference internal" href="#extending-the-command-grammar" id="toc-entry-11">Extending the command grammar</a></li>
<li><a class="reference internal" href="#reporting-errors" id="toc-entry-12">Reporting errors</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="defining-commands">
<h1><a class="toc-backref" href="#toc-entry-1">Defining commands</a></h1>
<p>Let's create a simple command, called &quot;hello&quot;, which prints <code class="e elpi"><span class="s2">&quot;Hello&quot;</span></code>
followed by the arguments we pass to it:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="nb">elpi</span> <span class="kn">Require Import</span> <span class="nb">elpi</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> hello.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="c">% main is, well, the entry point</span>
  main <span class=" -ElpiVariable">Arguments</span> <span class="k k-ElpiKeyword">:-</span> coq.say <span class="s2">&quot;Hello&quot;</span> <span class=" -ElpiVariable">Arguments</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span></span></pre><p>The program declaration is made of 3 parts.</p>
<p>The first one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Command</span> <span class="n">hello</span><span class="o">.</span></code> sets the current program to hello.
Since it is declared as a <code class="highlight coq"><span class="n">Command</span></code> some code is loaded automatically:</p>
<ul class="simple">
<li>APIs (eg <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L514">coq.say</a>) and data types (eg Coq <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L77">term</a> s) are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/coq-builtin.elpi">coq-builtin.elpi</a></li>
<li>some utilities, like <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L105">copy</a> or <a class="libred ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/elpi-reduction.elpi#L15">whd1</a> are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-command-template.elpi">elpi-command-template.elpi</a></li>
</ul>
<p>The second one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> loads some extra code.
The <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> family of commands lets one accumulate code
taken from:</p>
<ul class="simple">
<li>verbatim text <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="si">lp:{{</span> code <span class="si">}}</span></code></li>
<li>source files <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">File</span> <span class="n">path</span></code></li>
<li>data bases (Db) <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">Db</span> <span class="n">name</span></code></li>
</ul>
<p>Accumulating code via inline text or file is equivalent, the AST of <code class="highlight coq"><span class="n">code</span></code>
is stored in the .vo file (the external file does not need to be installed).
We postpone the description of data bases to a dedicated section.</p>
<p>Once all the code is accumulated <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Typecheck</span></code> verifies that the
code does not contain the most frequent kind of mistakes. This command
considers some mistakes minor and only warns about them. You can
pass <code class="highlight coq"><span class="o">-</span><span class="n">w</span> <span class="o">+</span><span class="n">elpi</span><span class="o">.</span><span class="n">typecheck</span></code> to <code class="highlight coq"><span class="n">coqc</span></code> to turn these warnings into errors.</p>
<p>We can now run our program!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk0"><span class="kn">Elpi</span> hello <span class="s2">&quot;world!&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str world!]</blockquote></div></div></small></span></pre><p>You should see the following output (hover the bubble next to the
code if you are reading this online):</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Hello [str world!]</pre><p>The  string <code class="highlight coq"><span class="s2">&quot;world!&quot;</span></code> we passed to the command is received by the code
as <code class="e elpi">(str <span class="s2">&quot;world!&quot;</span><span class="o">)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L514">coq.say</a> won't print quotes around strings</p>
</div>
</div>
<div class="section" id="command-arguments">
<h1><a class="toc-backref" href="#toc-entry-2">Command arguments</a></h1>
<p>Let's pass different kind of arguments to <code class="highlight coq"><span class="n">hello</span></code>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk1"><span class="kn">Elpi</span> hello <span class="mi">46</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [int <span class="mi">46</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk2"><span class="kn">Elpi</span> hello there.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str there]</blockquote></div></div></small></span></pre><p>This time we passed to the command a number and an identifier.
Identifiers are received as strings, and can contain dots, but no spaces.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk3"><span class="kn">Elpi</span> hello my friend.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str my, str friend]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk4"><span class="kn">Elpi</span> hello this.<span class="kr">is</span>.a.qualified.name.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str this.<span class="kr">is</span>.a.qualified.name]</blockquote></div></div></small></span></pre><p>Indeed the first invocation passes two arguments, of type string, while
the second a single one, again a string containing dots.</p>
<p>There are a few more types of arguments a command can receive:</p>
<ul class="simple">
<li>terms, delimited by <code class="highlight coq"><span class="o">(</span></code> and <code class="highlight coq"><span class="o">)</span></code></li>
<li>toplevel declarations, like <code class="highlight coq"><span class="kn">Inductive</span> <span class="o">..</span></code>, <code class="highlight coq"><span class="kn">Definition</span> <span class="o">..</span></code>, etc..
which are introduced by their characterizing keyword.</li>
</ul>
<p>Let's try with a term.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk5"><span class="kn">Elpi</span> hello (<span class="mi">0</span> = <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello 
[trm
  (app
    [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), <span class="kn">global</span> (indc ¬´O¬ª), 
     app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]])]</blockquote></div></div></small></span></pre><p>Since Coq-Elpi 1.15, terms are received in elaborated form, meaning
that the elaborator of Coq is used to pre-process them.
In the example above the type argument to <code class="highlight coq"><span class="n">eq</span></code> has
been synthesized to be <code class="highlight coq"><span class="n">nat</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk6"><span class="kn">Elpi</span> hello <span class="kn">Definition</span> <span class="nf">test</span> := <span class="mi">0</span> = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello 
[const-decl test 
  (some
    (app
      [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), <span class="kn">global</span> (indc ¬´O¬ª), 
       app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]])) (arity (sort prop))]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk7"><span class="kn">Elpi</span> hello <span class="kn">Record</span> <span class="nf">test</span> := { f1 : nat; f2 : f1 = <span class="mi">1</span> }.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello 
[indt-decl
  (record test (sort (typ ¬´<span class="kt">Set</span>¬ª)) Build_test 
    (<span class="bp">field</span> [coercion off, canonical tt] f1 (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
      <span class="bp">field</span> [coercion off, canonical tt] f2 
       (app
         [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), c0, 
          app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]) c1 \ <span class="kr">end</span>-record))]</blockquote></div></div></small></span></pre><p>Global declarations are received in elaborated form as well.
In the case of <code class="highlight coq"><span class="kn">Definition</span> <span class="nf">test</span></code> the optional body (would be
<code class="e elpi">none</code> for an <code class="highlight coq"><span class="kn">Axiom</span></code> declaration) is present
while the omitted type is inferred (to be <code class="highlight coq"><span class="kt">Prop</span></code>).</p>
<p>In the case of the <code class="highlight coq"><span class="kn">Record</span></code> declaration remark that each field has a few
attributes, like being a coercions (the <code class="highlight coq"><span class="o">:&gt;</span></code> in Coq's syntax). Also note that
the type of the record (which was omitted) defaults to <code class="highlight coq"><span class="kt">Type</span></code>.
Finally note that the type of the second field
sees <code class="e elpi">c0</code> (the value of the first field).</p>
<p>See the <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L50">argument</a> data type
for a detailed decription of all the arguments a command can receive.</p>
<div class="section" id="processing-raw-arguments">
<h2><a class="toc-backref" href="#toc-entry-3">Processing raw arguments</a></h2>
<p>It is sometimes useful to receive arguments in raw format, 
so that no elaboration has been performed.
This can be achieved by using the 
<code class="highlight coq"><span class="o">#[</span><span class="n">arguments</span><span class="o">(</span><span class="n">raw</span><span class="o">)]</span></code> attributed when the command is declared.</p>
<p>Then, thre are two ways to process term arguments:
typechecking and elaboration.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[arguments(raw)] <span class="kn">Elpi</span> <span class="kn">Command</span> check_arg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  main <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    std.assert-ok! (coq.typecheck <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">Ty</span>) <span class="s2">&quot;argument illtyped&quot;</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;The type of&quot;</span> <span class=" -ElpiVariable">T</span> <span class="s2">&quot;is&quot;</span> <span class=" -ElpiVariable">Ty</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk8"><span class="kn">Elpi</span> check_arg (<span class="mi">1</span> = <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kp">type of</span> 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], <span class="kn">global</span> (indc ¬´O¬ª)] <span class="kr">is</span> 
sort prop</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk9"><span class="kn">Elpi</span> check_arg (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">argument illtyped: Illegal application: 
The term <span class="s2">&quot;@eq&quot;</span> of type <span class="s2">&quot;forall A : Type, A -&gt; A -&gt; Prop&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;nat&quot;</span> : <span class="s2">&quot;Type&quot;</span>
 <span class="s2">&quot;1&quot;</span> : <span class="s2">&quot;nat&quot;</span>
 <span class="s2">&quot;true&quot;</span> : <span class="s2">&quot;bool&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;bool&quot;</span> which should be coercible to <span class="s2">&quot;nat&quot;</span>.</blockquote></div></div></small></span></pre><p>The command <code class="highlight coq"><span class="n">check_arg</span></code> receives a term <code class="e elpi"><span class="n-ElpiVariable">T</span></code> and type checks it, then it
prints the term and its type.</p>
<p>The <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1360">coq.typecheck</a> API has 3 arguments: a term, its type and a
<a class="stdtype ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L252">diagnostic</a> which can either be <code class="e elpi">ok</code> or <code class="e elpi">(error <span class="n-ElpiVariable">Message</span><span class="o">)</span></code>.
The <a class="stdlib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L461">assert-ok!</a> combinator checks if the diagnostic is <code class="e elpi">ok</code>,
and if not it prints the error message and bails out.</p>
<p>The first invocation succeeds while the second one fails and prints
the type checking error (given by Coq) following the string passed to
<code class="e elpi">std.assert-ok!</code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">bool2nat</span> (b : bool) := <span class="kr">if</span> b <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chka" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chka"><span class="kn">Elpi</span> check_arg (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">argument illtyped: Illegal application: 
The term <span class="s2">&quot;@eq&quot;</span> of type <span class="s2">&quot;forall A : Type, A -&gt; A -&gt; Prop&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;nat&quot;</span> : <span class="s2">&quot;Type&quot;</span>
 <span class="s2">&quot;1&quot;</span> : <span class="s2">&quot;nat&quot;</span>
 <span class="s2">&quot;true&quot;</span> : <span class="s2">&quot;bool&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;bool&quot;</span> which should be coercible to <span class="s2">&quot;nat&quot;</span>.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chkb"><span class="kn">Check</span> (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> = true
     : <span class="kt">Prop</span></blockquote></div></div></small></span></pre><p>The command still fails even if we told Coq how to inject booleans values
into the natural numbers. Indeed the <code class="highlight coq"><span class="kn">Check</span></code> commands works.</p>
<p>The call to <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1360">coq.typecheck</a> modifies the term in place, it can assign
implicit arguments (like the type parameter of <code class="highlight coq"><span class="n">eq</span></code>) but it cannot modify the
structure of the term. To do so, one has to use the
<a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1379">coq.elaborate-skeleton</a> API.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[arguments(raw)]
<span class="kn">Elpi</span> <span class="kn">Command</span> elaborate_arg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  main <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    std.assert-ok! (coq.elaborate-skeleton <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">T1</span>) <span class="s2">&quot;illtyped arg&quot;</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;T=&quot;</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;T1=&quot;</span> <span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;Ty=&quot;</span> <span class=" -ElpiVariable">Ty</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chkc"><span class="kn">Elpi</span> elaborate_arg (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">T= 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), X0, app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  <span class="kn">global</span> (indc ¬´true¬ª)]</blockquote><blockquote class="alectryon-message">T1= 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  app [<span class="kn">global</span> (const ¬´bool2nat¬ª), <span class="kn">global</span> (indc ¬´true¬ª)]]</blockquote><blockquote class="alectryon-message">Ty= sort prop</blockquote></div></div></small></span></pre><p>Remark how <code class="e elpi"><span class="n-ElpiVariable">T</span></code> is not touched by the call to this API, and how <code class="e elpi"><span class="n-ElpiVariable">T1</span></code>
is a copy of <code class="e elpi"><span class="n-ElpiVariable">T</span></code> where the hole after <code class="highlight coq"><span class="n">eq</span></code> is synthesized and the value
<code class="highlight coq"><span class="n">true</span></code> injected to <code class="highlight coq"><span class="n">nat</span></code> by using <code class="highlight coq"><span class="n">bool2nat</span></code>.</p>
<p>It is also possible to manipulate term arguments before typechecking
them, but note that all the considerations on holes in the tutorial about
the HOAS representation of Coq terms apply here. An example of tool
taking advantage of this possibility is Hierarchy Builder: the declarations
it receives would not typecheck in the current context, but do once the
context is temporarily augmented with ad-hoc canonical structure instances.</p>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#toc-entry-4">Examples</a></h1>
<div class="section" id="synthesizing-a-term">
<h2><a class="toc-backref" href="#toc-entry-5">Synthesizing a term</a></h2>
<p>Synthesizing a term typically involves reading an existing declaration
and writing a new one. The relevant APIs are in the <code class="highlight coq"><span class="n">coq</span><span class="o">.</span><span class="n">env</span><span class="o">.*</span></code> namespace
and are named after the global refence they manipulate, eg <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L664">coq.env.const</a>
for reading and <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L749">coq.env.add-const</a> for writing.</p>
<p>Here we implement a little command that given an inductive type name
generates a term of type <code class="highlight coq"><span class="n">nat</span></code> whose value is the number of constructors
of the given inductive type.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> constructors_num.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">int-&gt;nat</span> <span class="k k-ElpiMode">i:</span><span class="kt">int</span>, <span class="k k-ElpiMode">o:</span><span class="kt">term</span>.
int-&gt;nat <span class="m m-ElpiInteger">0</span> <span class="si">{{</span> <span class="mi">0</span> <span class="si">}}</span>.
int-&gt;nat <span class=" -ElpiVariable">N</span> <span class="si">{{</span> S <span class="si">lp:</span><span class=" -ElpiVariable">X</span> <span class="si">}}</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">M</span> <span class="k k-ElpiKeyword">is</span> <span class=" -ElpiVariable">N</span> <span class="k k-ElpiKeyword">-</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> int-&gt;nat <span class=" -ElpiVariable">M</span> <span class=" -ElpiVariable">X</span>.

main <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">IndName</span><span class="k k-ElpiKeyword">,</span> str <span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
  std.assert! (coq.locate <span class=" -ElpiVariable">IndName</span> (indt <span class=" -ElpiVariable">GR</span>)) <span class="s2">&quot;not an inductive type&quot;</span><span class="k k-ElpiKeyword">,</span>
  coq.env.indt <span class=" -ElpiVariable">GR</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Kn</span> <span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">,</span>      <span class="c">% the names of the constructors</span>
  std.length <span class=" -ElpiVariable">Kn</span> <span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span>                   <span class="c">% count them</span>
  int-&gt;nat <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Nnat</span><span class="k k-ElpiKeyword">,</span>                   <span class="c">% turn the integer into a nat</span>
  coq.env.add-const <span class=" -ElpiVariable">Name</span> <span class=" -ElpiVariable">Nnat</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>. <span class="c">% save it</span>

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> constructors_num bool nK_bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chkd"><span class="kn">Print</span> nK_bool.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nK_bool = <span class="mi">2</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> constructors_num <span class="kt">False</span> nK_False.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chke"><span class="kn">Print</span> nK_False.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nK_False = <span class="mi">0</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chkf"><span class="kn">Elpi</span> constructors_num plus nK_plus.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">not an inductive type: coq.locate plus (indt X0)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk10"><span class="kn">Elpi</span> constructors_num not_there bla.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Global</span> reference not found: not_there</blockquote></div></div></small></span></pre><p>The command starts by locating the first argument and asserting it points to
an inductive type. This line is idiomatic: <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L588">coq.locate</a> aborts if
the string cannot be located, and if it relates it to a <code class="e elpi">gref</code> which is not
<code class="e elpi">indt</code> (for example <code class="e elpi">const plus</code>) <a class="stdlib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L457">assert!</a> aborts with the given
error message.</p>
<p><a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L614">coq.env.indt</a> lets one access all the details of an inductive type,
here we just use the list of constructors.
The twin API <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L625">coq.env.indt-decl</a> lets
one access the declaration of the inductive in HOAS form, which might be
easier to manipulate in other situations, like the next example.</p>
<p>Then the program crafts a natural number and declares a constant for it.</p>
</div>
<div class="section" id="abstracting-an-inductive">
<h2><a class="toc-backref" href="#toc-entry-6">Abstracting an inductive</a></h2>
<p>For the sake of introducing <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L105">copy</a>, the swiss army knife of ŒªProlog, we
write a command which takes an inductive type declaration and builds a new
one abstracting the former one on a given term. The new inductive has a
parameter in place of the occurrences of that term.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> <span class="kp">abstract</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="c">% a renaming function which adds a &#39; to an ident (a string)</span>
  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">prime</span> <span class="k k-ElpiMode">i:</span><span class="kt">id</span>, <span class="k k-ElpiMode">o:</span><span class="kt">id</span>.
  prime <span class=" -ElpiVariable">S</span> <span class=" -ElpiVariable">S1</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">S1</span> <span class="k k-ElpiKeyword">is</span> <span class=" -ElpiVariable">S</span> <span class="k k-ElpiKeyword">^</span> <span class="s2">&quot;&#39;&quot;</span>.

  main <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">Ind</span><span class="k k-ElpiKeyword">,</span> trm <span class=" -ElpiVariable">Param</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>

    <span class="c">% the term to be abstracted out, P of type PTy</span>
    std.assert-ok!
      (coq.elaborate-skeleton <span class=" -ElpiVariable">Param</span> <span class=" -ElpiVariable">PTy</span> <span class=" -ElpiVariable">P</span>)
      <span class="s2">&quot;illtyped parameter&quot;</span><span class="k k-ElpiKeyword">,</span>

    <span class="c">% fetch the old declaration</span>
    std.assert! (coq.locate <span class=" -ElpiVariable">Ind</span> (indt <span class=" -ElpiVariable">I</span>)) <span class="s2">&quot;not an inductive type&quot;</span><span class="k k-ElpiKeyword">,</span>
    coq.env.indt-decl <span class=" -ElpiVariable">I</span> <span class=" -ElpiVariable">Decl</span><span class="k k-ElpiKeyword">,</span>

    <span class="c">% let&#39;s start to craft the new declaration by putting a</span>
    <span class="c">% parameter A which has the type of P</span>
    <span class=" -ElpiVariable">NewDecl</span> <span class="k k-ElpiKeyword">=</span> parameter <span class="s2">&quot;A&quot;</span> explicit <span class=" -ElpiVariable">PTy</span> <span class=" -ElpiVariable">Decl&#39;</span><span class="k k-ElpiKeyword">,</span>

    <span class="c">% let&#39;s make a copy, capturing all occurrences of P with a</span>
    <span class="c">% (which stands for the parameter)</span>
    (<span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">a</span>\ copy <span class=" -ElpiVariable">P</span> a <span class="k k-ElpiKeyword">=&gt;</span> copy-indt-decl <span class=" -ElpiVariable">Decl</span> (<span class=" -ElpiVariable">Decl&#39;</span> a))<span class="k k-ElpiKeyword">,</span>

    <span class="c">% to avoid name clashes, we rename the type and its constructors</span>
    <span class="c">% (we don&#39;t need to rename the parameters)</span>
    coq.rename-indt-decl (<span class="k k-ElpiKeyword">=</span>) prime prime <span class=" -ElpiVariable">NewDecl</span> <span class=" -ElpiVariable">DeclRenamed</span><span class="k k-ElpiKeyword">,</span>

    <span class="c">% we type check the inductive declaration, since abstracting</span>
    <span class="c">% random terms may lead to illtyped declarations (type theory</span>
    <span class="c">% is hard)</span>
    std.assert-ok!
      (coq.typecheck-indt-decl <span class=" -ElpiVariable">DeclRenamed</span>)
      <span class="s2">&quot;can&#39;t be abstracted&quot;</span><span class="k k-ElpiKeyword">,</span>

    coq.env.add-indt <span class=" -ElpiVariable">DeclRenamed</span> <span class=" -ElpiVariable">_</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tree</span> := leaf | node : tree -&gt; option nat -&gt; tree -&gt; tree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kp">abstract</span> tree (option nat).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk11"><span class="kn">Print</span> tree&#39;.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span> <span class="nf">tree&#39;</span> (<span class="nv">A</span> : <span class="kt">Set</span>) : <span class="kt">Set</span> :=
    leaf&#39; : tree&#39; A
  | node&#39; : tree&#39; A -&gt; A -&gt; tree&#39; A -&gt; tree&#39; A.

<span class="kn">Arguments</span> tree&#39; A%type_scope
<span class="kn">Arguments</span> leaf&#39; A%type_scope
<span class="kn">Arguments</span> node&#39; A%type_scope _ _ _</blockquote></div></div></small></span></pre><p>As expected <code class="highlight coq"><span class="n">tree'</span></code> has a parameter <code class="highlight coq"><span class="n">A</span></code>.</p>
<p>Now let's focus on <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L105">copy</a>. The standard
coq library (loaded by the command template) contains a definition of copy
for terms and declarations.</p>
<p>An excerpt:</p>
<pre class="code elpi literal-block">
copy <span class="n-ElpiVariable">X</span> <span class="n-ElpiVariable">X</span> <span class="k-ElpiKeyword">:-</span> name <span class="n-ElpiVariable">X</span><span class="o">.</span>      <span class="c">% checks X is a bound variable
</span>copy (global <span class="n-ElpiVariable">_</span> <span class="k-ElpiKeyword">as</span> <span class="n-ElpiVariable">C</span><span class="o">)</span> <span class="n-ElpiVariable">C</span><span class="o">.</span>
copy (fun <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">T</span> <span class="n-ElpiVariable">F</span><span class="o">)</span> (fun <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">T1</span> <span class="n-ElpiVariable">F1</span><span class="o">)</span> <span class="k-ElpiKeyword">:-</span>
  copy <span class="n-ElpiVariable">T</span> <span class="n-ElpiVariable">T1</span><span class="k-ElpiKeyword">,</span> <span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ copy (<span class="n-ElpiVariable">F</span> x<span class="o">)</span> (<span class="n-ElpiVariable">F1</span> x<span class="o">).</span>
copy (app <span class="n-ElpiVariable">L</span><span class="o">)</span> (app <span class="n-ElpiVariable">L1</span><span class="o">)</span> <span class="k-ElpiKeyword">:-</span> std.map <span class="n-ElpiVariable">L</span> copy <span class="n-ElpiVariable">L1</span><span class="o">.</span>
</pre>
<p><code class="e elpi">copy</code> implements the identity: it builds, recursively, a copy of the first
term into the second argument. Unless one loads in the context a new rule,
which takes precedence over the identity ones. Here we load:</p>
<pre class="code elpi literal-block">
copy <span class="n-ElpiVariable">P</span> a
</pre>
<p>which, at run time, looks like</p>
<pre class="code elpi literal-block">
copy (app <span class="k-ElpiKeyword">[</span>global <span class="o">(</span>indt <span class="err">¬´</span>option<span class="err">¬ª</span><span class="o">)</span><span class="k-ElpiKeyword">,</span> global <span class="o">(</span>indt <span class="err">¬´</span>nat<span class="err">¬ª</span><span class="o">)</span><span class="k-ElpiKeyword">]</span><span class="o">)</span> c0
</pre>
<p>and that rule masks the one for <code class="highlight coq"><span class="n">app</span></code> when the sub-term being copied is
exactly <code class="highlight coq"><span class="n">option</span> <span class="n">nat</span></code>. The API <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L140">copy-indt-decl</a> copies an inductive
declaration and calls <code class="highlight coq"><span class="n">copy</span></code> on all the terms it contains (e.g. the
type of the constructors).</p>
<p>The <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L105">copy</a> predicate is very flexible, but sometimes one needs to collect
some data along the way. The sibling API <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L160">fold-map</a> lets one do that.</p>
<p>An excerpt:</p>
<pre class="code elpi literal-block">
fold-map (fun <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">T</span> <span class="n-ElpiVariable">F</span><span class="o">)</span> <span class="n-ElpiVariable">A</span> (fun <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">T1</span> <span class="n-ElpiVariable">F1</span><span class="o">)</span> <span class="n-ElpiVariable">A2</span> <span class="k-ElpiKeyword">:-</span>
  fold-map <span class="n-ElpiVariable">T</span> <span class="n-ElpiVariable">A</span> <span class="n-ElpiVariable">T1</span> <span class="n-ElpiVariable">A1</span><span class="k-ElpiKeyword">,</span> <span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ fold-map (<span class="n-ElpiVariable">F</span> x<span class="o">)</span> <span class="n-ElpiVariable">A1</span> (<span class="n-ElpiVariable">F1</span> x<span class="o">)</span> <span class="n-ElpiVariable">A2</span><span class="o">.</span>
</pre>
<p>For example one can use <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L160">fold-map</a> to collect into a list all the occurrences
of inductive type constructors in a given term, then use the list to postulate
the right number of binders for them, and finally use <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L105">copy</a> to capture them.</p>
</div>
</div>
<div class="section" id="using-dbs-to-store-data-across-calls">
<h1><a class="toc-backref" href="#toc-entry-7">Using DBs to store data across calls</a></h1>
<p>A Db can be created with the command:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Db</span> name.db <span class="si">lp:{{</span> some code. <span class="si">}}</span>.</span></span></pre><p>and a Db can be later extended via <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span></code>.
As a convention, we like Db names to end in a .db suffix.</p>
<p>A Db is pretty much like a regular program but can be <em>shared</em> among
other programs and is accumulated <em>by name</em>.
Since is a Db is accumulated <em>when a program runs</em> the <em>current
contents of the Db are used</em>.
Moreover the Db can be extended by Elpi programs themselves
thanks to the API <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1668">coq.elpi.accumulate</a>, enabling code to save a state
which is then visible at subsequent runs.</p>
<p>The initial contents of a Db, <code class="highlight coq"><span class="n">some</span> <span class="n">code</span></code> in the example
above, is usually just the type declaration for the predicates part of the Db,
and maybe a few default rules.
Let's define a Db.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Db</span> age.db <span class="si">lp:{{</span>

  <span class="c">% A typical Db is made of one main predicate</span>
  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">age</span> <span class="k k-ElpiMode">o:</span><span class="kt">string</span>, <span class="k k-ElpiMode">o:</span><span class="kt">int</span>.

  <span class="c">% the Db is empty for now, we put a rule giving a</span>
  <span class="c">% descriptive error and we name that rule &quot;age.fail&quot;.</span>
  <span class="k k-ElpiMode">:name</span> <span class="s2">&quot;age.fail&quot;</span>
  age <span class=" -ElpiVariable">Name</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span> coq.error <span class="s2">&quot;I don&#39;t know who&quot;</span> <span class=" -ElpiVariable">Name</span> <span class="s2">&quot;is!&quot;</span>.

<span class="si">}}</span>.</span></span></pre><p>Elpi rules can be given a name via the <code class="e elpi"><span class="err">:</span>name</code> attribute. Named rules
serve as anchor-points for new rules when added to the Db.</p>
<p>Let's define a <code class="highlight coq"><span class="n">Command</span></code> that makes use of a Db.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> age.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> age.db.  <span class="c">(* we accumulate the Db *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  main <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    age <span class=" -ElpiVariable">Name</span> <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class=" -ElpiVariable">Name</span> <span class="s2">&quot;is&quot;</span> <span class=" -ElpiVariable">A</span> <span class="s2">&quot;years old&quot;</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk12"><span class="kn">Elpi</span> age bob.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">I don&#39;t know who bob <span class="kr">is</span>!</blockquote></div></div></small></span></pre><p>Let's put some data in the Db. Given that the Db contains a catch-all rule,
we need the new ones to be put before it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> age.db <span class="si">lp:{{</span>

  <span class="k k-ElpiMode">:before</span> <span class="s2">&quot;age.fail&quot;</span>     <span class="c">% we place this rule before the catch all</span>
  age <span class="s2">&quot;bob&quot;</span> <span class="m m-ElpiInteger">24</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk13"><span class="kn">Elpi</span> age bob.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bob <span class="kr">is</span> <span class="mi">24</span> years old</blockquote></div></div></small></span></pre><p>Extending data bases this way is fine, but requires the user of our command
to be familiar with Elpi's syntax, which is not very nice. Instead,
we can write a new program that uses the <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1668">coq.elpi.accumulate</a> API
to extend the Db.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> set_age.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> age.db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
  main <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">,</span> int <span class=" -ElpiVariable">Age</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    <span class=" -ElpiVariable">TheNewRule</span> <span class="k k-ElpiKeyword">=</span> age <span class=" -ElpiVariable">Name</span> <span class=" -ElpiVariable">Age</span><span class="k k-ElpiKeyword">,</span>
    coq.elpi.accumulate <span class=" -ElpiVariable">_</span> <span class="s2">&quot;age.db&quot;</span>
      (clause <span class=" -ElpiVariable">_</span> (before <span class="s2">&quot;age.fail&quot;</span>) <span class=" -ElpiVariable">TheNewRule</span>).

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> set_age <span class="s2">&quot;alice&quot;</span> <span class="mi">21</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk14"><span class="kn">Elpi</span> age <span class="s2">&quot;alice&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">alice <span class="kr">is</span> <span class="mi">21</span> years old</blockquote></div></div></small></span></pre><p>Additions to a Db are a Coq object, a bit like a Notation or a Type Class
instance: these object live inside a Coq module (or a Coq file) and become
active when that module is Imported.</p>
<p>Deciding to which Coq module these
extra rules belong is important and <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1668">coq.elpi.accumulate</a> provides
a few options to tune that. Here we passed <code class="e elpi"><span class="n-ElpiVariable">_</span></code>, that uses the default
setting. See the <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1661">scope</a> and <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1652">clause</a> data types for more info.</p>
<div class="section" id="inspecting-a-db">
<span id="inspecting"></span><h2><a class="toc-backref" href="#toc-entry-8">Inspecting a Db</a></h2>
<p>So far we did query a Db but sometimes one needs to inspect the whole
contents.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> print_all_ages.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> age.db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiMode">:before</span> <span class="s2">&quot;age.fail&quot;</span>
  age <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span> <span class="k k-ElpiKeyword">!,</span> fail. <span class="c">% softly</span>

  main <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">:-</span>
    std.findall (age <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>) <span class=" -ElpiVariable">Rules</span><span class="k k-ElpiKeyword">,</span>
    std.forall <span class=" -ElpiVariable">Rules</span> print-rule.

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">print-rule</span> <span class="k k-ElpiMode">i:</span><span class="kt">prop</span>.
  print-rule (age <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">N</span>) <span class="k k-ElpiKeyword">:-</span> coq.say <span class=" -ElpiVariable">P</span> <span class="s2">&quot;is&quot;</span> <span class=" -ElpiVariable">N</span> <span class="s2">&quot;years old&quot;</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk15"><span class="kn">Elpi</span> print_all_ages.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bob <span class="kr">is</span> <span class="mi">24</span> years old</blockquote><blockquote class="alectryon-message">alice <span class="kr">is</span> <span class="mi">21</span> years old</blockquote></div></div></small></span></pre><p>The <a class="stdlib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L379">std.findall</a> predicate gathers in a list all solutions to
a query, while <a class="stdlib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L623">std.forall</a> iterates a predicate over a list.
It is important to notice that <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L526">coq.error</a> is a fatal error which
aborts an Elpi program. Here we shadow the catch all clause with a regular
failure so that <a class="stdlib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L379">std.findall</a> can complete to list all the results.</p>
</div>
</div>
<div class="section" id="polishing-a-command">
<h1><a class="toc-backref" href="#toc-entry-9">Polishing a command</a></h1>
<p>The details do make the difference, some times.</p>
<div class="section" id="attributes">
<h2><a class="toc-backref" href="#toc-entry-10">Attributes</a></h2>
<p>Elpi programs can be prefixed with attributes, like <code class="highlight coq"><span class="o">#[</span><span class="n">local</span><span class="o">]</span></code>.
Attributes are not passed as arguments but rather as a rule in the context,
a bit like the option <code class="e elpi"><span class="k-ElpiKeyword">&#64;</span>holes!</code> we have seen before.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> attr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  main <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    attributes <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span> <span class="c">% we fetch the list of attributes from the context</span>
    coq.say <span class=" -ElpiVariable">A</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk16">#[this, more(stuff=<span class="s2">&quot;33&quot;</span>)] <span class="kn">Elpi</span> attr.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[attribute <span class="nb">elpi</span>.loc 
  (leaf-loc File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">10</span>, column <span class="mi">31</span>, character <span class="mi">175</span>:), 
 attribute this (leaf-str ), 
 attribute more (node [attribute stuff (leaf-str <span class="mi">33</span>)])]</blockquote></div></div></small></span></pre><p>The first attribute, <code class="e elpi">elpi.loc</code> is always present and corresponds to the
location in the source file of the command. Then we find an attribute for
<code class="e elpi"><span class="s2">&quot;this&quot;</span></code> holding the emptry string and an attribute for <code class="e elpi"><span class="s2">&quot;more.stuff&quot;</span></code> holding
the string <code class="e elpi"><span class="s2">&quot;33&quot;</span></code>.</p>
<p>Attributes are usually validated (parsed) and turned into regular options
using <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L620">coq.parse-attributes</a> and a description of their types using 
the <a class="libtype ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi/coq-lib.elpi#L662">attribute-type</a> data type:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> parse_attr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">some-code</span>.
  some-code <span class="k k-ElpiKeyword">:-</span>
    get-option <span class="s2">&quot;more.stuff&quot;</span> <span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span> get-option <span class="s2">&quot;this&quot;</span> <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">,</span> coq.say <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">B</span>.

  main <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    attributes <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span>
    coq.parse-attributes <span class=" -ElpiVariable">A</span> <span class="k k-ElpiKeyword">[</span>
      att <span class="s2">&quot;this&quot;</span> bool<span class="k k-ElpiKeyword">,</span>
      att <span class="s2">&quot;more.stuff&quot;</span> int<span class="k k-ElpiKeyword">,</span>
    <span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">Opts</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;options=&quot;</span> <span class=" -ElpiVariable">Opts</span><span class="k k-ElpiKeyword">,</span>
    <span class=" -ElpiVariable">Opts</span> <span class="k k-ElpiKeyword">=&gt;</span> some-code.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk17">#[this, more(stuff=<span class="s2">&quot;33&quot;</span>)] <span class="kn">Elpi</span> parse_attr.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">options= 
[get-option <span class="nb">elpi</span>.loc File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">19</span>, column <span class="mi">31</span>, character <span class="mi">358</span>:, 
 get-option this tt, get-option more.stuff <span class="mi">33</span>]</blockquote><blockquote class="alectryon-message"><span class="mi">33</span> tt</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk18">#[unknown] <span class="kn">Elpi</span> parse_attr.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Attribute unknown <span class="kr">is</span> not supported</blockquote></div></div></small></span></pre><p>Note that <code class="e elpi">get-option</code> links a string with a datum of type <code class="e elpi">any</code>, which means
no type checking is performed on it. It is recommended to wrap calls to
get-option into other predicates typed in a more precise way. Eg:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span> <span class="n-ElpiFunction">get-my-option</span> <span class="k-ElpiMode">o:</span><span class="kt">int</span>.
get-my-option <span class="n-ElpiVariable">I</span> <span class="k-ElpiKeyword">:-</span> get-option <span class="s2">&quot;my-option-name&quot;</span> <span class="n-ElpiVariable">I</span><span class="o">.</span>
</pre>
</div>
<div class="section" id="extending-the-command-grammar">
<h2><a class="toc-backref" href="#toc-entry-11">Extending the command grammar</a></h2>
<p>Elpi programs can be exported as regular Coq commands, so that the
final user does not need to type <code class="highlight coq"><span class="n">Elpi</span></code> to invoke them.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> Say.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span> main <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span> coq.say <span class=" -ElpiVariable">S</span>. <span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> Say. <span class="c">(* extend the Coq command grammar *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk19">Say <span class="s2">&quot;That is all folks!&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">That <span class="kr">is</span> <span class="kp">all</span> folks!</blockquote></div></div></small></span></pre><p>Not yet...</p>
<p>Coq offers no equivalent of <code class="highlight coq"><span class="kn">Tactic Notation</span></code> for commands.
Still Elpi commands accept any symbol or keyword as strings.
It is up to the programmer to catch and report parse errors.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> Go.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
  main <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">Src</span><span class="k k-ElpiKeyword">,</span> str <span class="s2">&quot;=&gt;&quot;</span><span class="k k-ElpiKeyword">,</span> str <span class=" -ElpiVariable">Tgt</span><span class="k k-ElpiKeyword">,</span> str <span class="s2">&quot;/&quot;</span><span class="k k-ElpiKeyword">,</span> str <span class=" -ElpiVariable">F</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span> <span class="k k-ElpiKeyword">!,</span>
    coq.say <span class="s2">&quot;going from&quot;</span> <span class=" -ElpiVariable">Src</span> <span class="s2">&quot;to&quot;</span> <span class=" -ElpiVariable">Tgt</span> <span class="s2">&quot;via&quot;</span> <span class=" -ElpiVariable">F</span>.
  main <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.error <span class="s2">&quot;Parse error! Use: go &lt;from&gt; =&gt; &lt;to&gt; / &lt;via&gt;&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> Go.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk1a">Go source =&gt; target / plane.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">going <span class="kn">from</span> source to target via plane</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk1b">Go nowhere.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Parse error! Use: go &lt;<span class="kn">from</span>&gt; =&gt; &lt;to&gt; / &lt;via&gt;</blockquote></div></div></small></span></pre></div>
<div class="section" id="reporting-errors">
<h2><a class="toc-backref" href="#toc-entry-12">Reporting errors</a></h2>
<p>Last, (good) Elpi programs should fail reporting intellegible error messages,
as the previous one.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span> main <span class="k k-ElpiKeyword">[]</span>. <span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk1c">bad <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command bad failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small></span></pre><p>If they just fail, they produce the following generic
error:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->The elpi tactic/command bad failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</pre><p>You should use the <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L526">coq.error</a> API or the <a class="stdlib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/elpi-builtin.elpi#L457">assert!</a> one
to abort a program. There is a dedicated <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L1507">coq.ltac.fail</a> API to abort
tactics.</p>
<p>Warnings can be reported using the <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/68b0cd79f13607bdad6c65f36f442326fdb7383c/coq-builtin.elpi#L520">coq.warning</a> which lets you
pick a name and category. In turn these can be used to disable or make fatal
your warnings (as any other Coq warning).</p>
<p>This is really the end, unless you want to learn more about writing
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_tactic.html">tactics</a>
in Elpi, in that case look at that tutorial ;-)</p>
</div>
</div>
</div>
</div>
</div></body>
</html>
