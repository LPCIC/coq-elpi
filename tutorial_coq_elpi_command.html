<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.22.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Enrico Tassi" />
<title>Tutorial on Coq commands</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.20.0+0.20.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-coq-commands">
<h1 class="title">Tutorial on Coq commands</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<script>
var style = document.createElement('style');
style.textContent = `
  table.docinfo {
     border-top: none;
     border-bottom: none;
     margin: auto;
  }
  #alectryon-toggle-0 {
     display: none;
  }
  label[for="alectryon-toggle-0"] {
     display: none;
  }
  .alectryon-io {
     border-left-style: dotted;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  pre.alectryon-block {
     padding-left: 1em;
  }
  label.alectryon-input.alectryon-failed {
     text-decoration: red wavy underline;
  }
  .alectryon-io label.alectryon-input::after , .alectryon-banner .alectryon-bubble::before {
    content: '';
    background: url("data:image/svg+xml,%3Csvg width='14' height='14' viewBox='0 0 3.704 3.704' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill-rule='evenodd' stroke='%23000' stroke-width='.264'%3E%3Cpath d='M.794.934h2.115M.794 1.463h1.455M.794 1.992h1.852'/%3E%3C/g%3E%3Cpath d='M.132.14v2.646h.794v.661l.926-.661h1.72V.14z' fill='none' stroke='%23000' stroke-width='.265'/%3E%3C/svg%3E") top right no-repeat;
    height: 14px;
    width: 14px;
    border-style: none;
    border-radius: 0px;
  }
  code.coq , code.elpi {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.note, div.tip {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
  .ghref {
    cursor: help;
    text-decoration: underline dotted;
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
  }

  .elpi {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
   }

  .highlight .-ElpiFunction , .highlight .n-ElpiFunction { color: #795E26 }
  .highlight .-ElpiVariable , .highlight .n-ElpiVariable { color: #0000ff }
  .highlight .k-ElpiKeyword { color: #AF00DB }
  .highlight .k-ElpiMode { color: #811f3f }
  .highlight .m-ElpiInteger { color: #098658 }
  .highlight .si { color: rgb(94, 93, 93) }

  .elpi .n-ElpiFunction { color: #795E26 }
  .elpi .n-ElpiVariable { color: #0000ff }
  .elpi .k-ElpiKeyword { color: #AF00DB }
  .elpi .k-ElpiMode { color: #811f3f }
  .elpi .m-ElpiInteger { color: #098658 }
  .elpi .s2 { color: #a31515 }
  .elpi .c { color: #008000 }
  .elpi .kt { color: #2b91af }
  .elpi .si { color: rgb(94, 93, 93) }

  .admonition-title:after { content: ":" }
  .admonition-title { display: inline; margin-right: 0.5em }
  .admonition-title + p { display: inline }

  .important .admonition-title { color: rgb(197, 70, 91) }
  .important { background-color: rgb(272, 237, 243) }

  .note .admonition-title { color: rgb(42, 134, 57) }
  .note { background-color: rgb(222, 247, 222); }

   h1 {
      font-size: 28px;
      font-weight: 500;
      letter-spacing: 0;
      line-height: 1.5em;
      padding-bottom: 15px;
      position: relative;
      font-family: "Gill Sans Extrabold", sans-serif;
   }
   h1:before {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      height: 5px;
      width: 55px;
      background-color: #111;
   }
   h1:after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 2px;
      height: 1px;
      width: 95%;
      background-color: #333;
   }

   h2 {
      font-size: 24px;
      font-weight: 500;
      letter-spacing: 0;
      line-height: 1.5em;
      padding-bottom: 15px;
      position: relative;
      font-family: "Gill Sans Extrabold", sans-serif;
   }
   h2:before {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      height: 3px;
      width: 55px;
      background-color: #111;
   }
   h2:after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 2px;
      height: 1px;
      width: 95%;
      background-color: #333;
   }

   h3 {
      font-size: 20px;
      font-weight: 500;
      letter-spacing: 0;
      line-height: 1.5em;
      padding-bottom: 15px;
      position: relative;
      font-family: "Gill Sans Extrabold", sans-serif;
   }
   h3:after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 2px;
      height: 1px;
      width: 95%;
      background-color: #333;
   }
`;
document.getElementsByTagName('head')[0].appendChild(style);

</script><!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with programming constructs that are
designed to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq specific data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This tutorial assumes the reader is familiar with Elpi and the HOAS
representation of Coq terms; if it is not the case, please take a look at
these other tutorials first:
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_elpi_lang.html">Elpi tutorial</a>
and 
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_HOAS.html">Coq HOAS tutorial</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title"><a class="reference internal" href="#top">Contents</a></p>
<ul class="simple">
<li><a class="reference internal" href="#defining-commands" id="toc-entry-1">Defining commands</a></li>
<li><a class="reference internal" href="#command-arguments" id="toc-entry-2">Command arguments</a><ul>
<li><a class="reference internal" href="#processing-raw-arguments" id="toc-entry-3">Processing raw arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="toc-entry-4">Examples</a><ul>
<li><a class="reference internal" href="#synthesizing-a-term" id="toc-entry-5">Synthesizing a term</a></li>
<li><a class="reference internal" href="#abstracting-an-inductive" id="toc-entry-6">Abstracting an inductive</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-dbs-to-store-data-across-calls" id="toc-entry-7">Using DBs to store data across calls</a><ul>
<li><a class="reference internal" href="#inspecting-a-db" id="toc-entry-8">Inspecting a Db</a></li>
</ul>
</li>
<li><a class="reference internal" href="#polishing-a-command" id="toc-entry-9">Polishing a command</a><ul>
<li><a class="reference internal" href="#attributes" id="toc-entry-10">Attributes</a></li>
<li><a class="reference internal" href="#extending-the-command-grammar" id="toc-entry-11">Extending the command grammar</a></li>
<li><a class="reference internal" href="#reporting-errors" id="toc-entry-12">Reporting errors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing-and-execution" id="toc-entry-13">Parsing and Execution</a></li>
</ul>
</div>
<div class="section" id="defining-commands">
<h1><a class="toc-backref" href="#toc-entry-1">Defining commands</a></h1>
<p>Let's create a simple command, called &quot;hello&quot;, which prints <code class="e elpi"><span class="s2">&quot;Hello&quot;</span></code>
followed by the arguments we pass to it:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk0"><span class="kn">From</span> <span class="nb">elpi</span> <span class="kn">Require Import</span> <span class="nb">elpi</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Serlib plugin: rocq-<span class="nb">elpi</span>.<span class="nb">elpi</span> <span class="kr">is</span> not available: serlib support <span class="kr">is</span> missing.
Incremental checking <span class="kr">for</span> commands <span class="kr">in</span> this plugin will be impacted.</blockquote><blockquote class="alectryon-message">[Loading ML file rocq-<span class="nb">elpi</span>.<span class="nb">elpi</span> ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> hello.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span><span class="c">% main is, well, the entry point</span>
<span class="w">  </span>main<span class="w"> </span><span class=" -ElpiVariable">Arguments</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.say<span class="w"> </span><span class="s2">&quot;Hello&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Arguments</span>.

<span class="si">}}</span>.</span></span></pre><p>The program declaration is made of 3 parts.</p>
<p>The first one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Command</span> <span class="n">hello</span><span class="o">.</span></code> sets the current program to hello.
Since it is declared as a <code class="highlight coq"><span class="n">Command</span></code> some code is loaded automatically:</p>
<ul class="simple">
<li>APIs (eg <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L554">coq.say</a>) and data types (eg Coq <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L199">term</a> s) are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/builtin-doc/coq-builtin.elpi">coq-builtin.elpi</a></li>
<li>some utilities, like <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L98">copy</a> or <a class="reference external libred ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/elpi-reduction.elpi#L15">whd1</a> are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-command-template.elpi">elpi-command-template.elpi</a></li>
</ul>
<p>The second one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> loads some extra code.
The <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> family of commands lets one accumulate code
taken from:</p>
<ul class="simple">
<li>verbatim text <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="si">lp:{{</span><span class="w"> </span>code<span class="w"> </span><span class="si">}}</span></code></li>
<li>source files <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">File</span> <span class="n">path</span></code></li>
<li>data bases (Db) <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">Db</span> <span class="n">name</span></code></li>
</ul>
<p>Accumulating code via inline text or file is equivalent, the AST of <code class="highlight coq"><span class="n">code</span></code>
is stored in the .vo file (the external file does not need to be installed).
We postpone the description of data bases to a dedicated section.</p>
<p>When some code is accumulated Elpi verifies that the
code does not contain the most frequent kind of mistakes, via some
type checking and linting. Some mistakes are minor and Elpi only warns about
them. You can pass <code class="highlight coq"><span class="o">-</span><span class="n">w</span> <span class="o">+</span><span class="n">elpi</span><span class="o">.</span><span class="n">typecheck</span></code> to <code class="highlight coq"><span class="n">coqc</span></code> to turn these warnings into
errors.</p>
<p>We can now run our program!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk1"><span class="kn">Elpi</span> hello <span class="s2">&quot;world!&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str world!]</blockquote></div></div></small></span></pre><p>You should see the following output (hover the bubble next to the
code if you are reading this online):</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Hello [str world!]</pre><p>The  string <code class="highlight coq"><span class="s2">&quot;world!&quot;</span></code> we passed to the command is received by the code
as <code class="e elpi"><span class="p">(</span>str<span class="w"> </span><span class="s2">&quot;world!&quot;</span><span class="p">)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L554">coq.say</a> won't print quotes around strings</p>
</div>
</div>
<div class="section" id="command-arguments">
<h1><a class="toc-backref" href="#toc-entry-2">Command arguments</a></h1>
<p>Let's pass different kind of arguments to <code class="highlight coq"><span class="n">hello</span></code>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk2"><span class="kn">Elpi</span> hello <span class="mi">46</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [int <span class="mi">46</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk3"><span class="kn">Elpi</span> hello there.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str there]</blockquote></div></div></small></span></pre><p>This time we passed to the command a number and an identifier.
Identifiers are received as strings, and can contain dots, but no spaces.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk4"><span class="kn">Elpi</span> hello my friend.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str my, str friend]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk5"><span class="kn">Elpi</span> hello this.<span class="kr">is</span>.a.qualified.name.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello [str this.<span class="kr">is</span>.a.qualified.name]</blockquote></div></div></small></span></pre><p>Indeed the first invocation passes two arguments, of type string, while
the second a single one, again a string containing dots.</p>
<p>There are a few more types of arguments a command can receive:</p>
<ul class="simple">
<li>terms, delimited by <code class="highlight coq"><span class="o">(</span></code> and <code class="highlight coq"><span class="o">)</span></code></li>
<li>toplevel declarations, like <code class="highlight coq"><span class="kn">Inductive</span> <span class="o">..</span></code>, <code class="highlight coq"><span class="kn">Definition</span> <span class="o">..</span></code>, etc..
which are introduced by their characterizing keyword.</li>
</ul>
<p>Let's try with a term.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk6"><span class="kn">Elpi</span> hello (<span class="mi">0</span> = <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello 
[trm
  (app
    [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), <span class="kn">global</span> (indc ¬´O¬ª), 
     app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]])]</blockquote></div></div></small></span></pre><p>Since Coq-Elpi 1.15, terms are received in elaborated form, meaning
that the elaborator of Coq is used to pre-process them.
In the example above the type argument to <code class="highlight coq"><span class="n">eq</span></code> has
been synthesized to be <code class="highlight coq"><span class="n">nat</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk7"><span class="kn">Elpi</span> hello <span class="kn">Definition</span> <span class="nf">test</span> := <span class="mi">0</span> = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello 
[const-decl test 
  (some
    (app
      [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), <span class="kn">global</span> (indc ¬´O¬ª), 
       app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]])) (arity (sort prop))]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk8"><span class="kn">Elpi</span> hello <span class="kn">Record</span> <span class="nf">test</span> := { f1 : nat; f2 : f1 = <span class="mi">1</span> }.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Hello 
[indt-decl
  (record test (sort (typ ¬´<span class="kt">Set</span>¬ª)) Build_test 
    (<span class="bp">field</span> [coercion off, canonical tt] f1 (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
      <span class="bp">field</span> [coercion off, canonical tt] f2 
       (app
         [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), c0, 
          app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]) c1 \ <span class="kr">end</span>-record))]</blockquote></div></div></small></span></pre><p>Global declarations are received in elaborated form as well.
In the case of <code class="highlight coq"><span class="kn">Definition</span> <span class="nf">test</span></code> the optional body (would be
<code class="e elpi">none</code> for an <code class="highlight coq"><span class="kn">Axiom</span></code> declaration) is present
while the omitted type is inferred (to be <code class="highlight coq"><span class="kt">Prop</span></code>).</p>
<p>In the case of the <code class="highlight coq"><span class="kn">Record</span></code> declaration remark that each field has a few
attributes, like being a coercions (the <code class="highlight coq"><span class="o">:&gt;</span></code> in Coq's syntax). Also note that
the type of the record (which was omitted) defaults to <code class="highlight coq"><span class="kt">Type</span></code>.
Finally note that the type of the second field
sees <code class="e elpi">c0</code> (the value of the first field).</p>
<p>See the <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L66">argument</a> data type
for a detailed description of all the arguments a command can receive.</p>
<div class="section" id="processing-raw-arguments">
<h2><a class="toc-backref" href="#toc-entry-3">Processing raw arguments</a></h2>
<p>It is sometimes useful to receive arguments in raw format, 
so that no elaboration has been performed.
This can be achieved by using the 
<code class="highlight coq"><span class="o">#[</span><span class="n">arguments</span><span class="o">(</span><span class="n">raw</span><span class="o">)]</span></code> attributed when the command is declared.</p>
<p>Then, there are two ways to process term arguments:
typechecking and elaboration.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[arguments(raw)] <span class="kn">Elpi</span> <span class="kn">Command</span> check_arg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>std.assert-ok!<span class="w"> </span><span class="p">(</span>coq.typecheck<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;argument illtyped&quot;</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;The type of&quot;</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class="s2">&quot;is&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk9"><span class="kn">Elpi</span> check_arg (<span class="mi">1</span> = <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kp">type of</span> 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], <span class="kn">global</span> (indc ¬´O¬ª)] <span class="kr">is</span> 
sort prop</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chka" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chka"><span class="kn">Elpi</span> check_arg (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">argument illtyped: Illegal application: 
The term <span class="s2">&quot;@eq&quot;</span> of type <span class="s2">&quot;forall A : Type, A -&gt; A -&gt; Prop&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;nat&quot;</span> : <span class="s2">&quot;Type&quot;</span>
 <span class="s2">&quot;1&quot;</span> : <span class="s2">&quot;nat&quot;</span>
 <span class="s2">&quot;true&quot;</span> : <span class="s2">&quot;bool&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;bool&quot;</span> which should be a subtype of <span class="s2">&quot;nat&quot;</span>.</blockquote></div></div></small></span></pre><p>The command <code class="highlight coq"><span class="n">check_arg</span></code> receives a term <code class="e elpi"><span class="n-ElpiVariable">T</span></code> and type checks it, then it
prints the term and its type.</p>
<p>The <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1457">coq.typecheck</a> API has 3 arguments: a term, its type and a
<a class="reference external stdtype ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L290">diagnostic</a> which can either be <code class="e elpi">ok</code> or <code class="e elpi"><span class="p">(</span>error<span class="w"> </span><span class="n-ElpiVariable">Message</span><span class="p">)</span></code>.
The <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L492">assert-ok!</a> combinator checks if the diagnostic is <code class="e elpi">ok</code>,
and if not it prints the error message and bails out.</p>
<p>The first invocation succeeds while the second one fails and prints
the type checking error (given by Coq) following the string passed to
<code class="e elpi">std.assert-ok!</code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">bool2nat</span> (b : bool) := <span class="kr">if</span> b <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chkb"><span class="kn">Elpi</span> check_arg (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">argument illtyped: Illegal application: 
The term <span class="s2">&quot;@eq&quot;</span> of type <span class="s2">&quot;forall A : Type, A -&gt; A -&gt; Prop&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;nat&quot;</span> : <span class="s2">&quot;Type&quot;</span>
 <span class="s2">&quot;1&quot;</span> : <span class="s2">&quot;nat&quot;</span>
 <span class="s2">&quot;true&quot;</span> : <span class="s2">&quot;bool&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;bool&quot;</span> which should be a subtype of <span class="s2">&quot;nat&quot;</span>.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chkc"><span class="kn">Check</span> (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> = true
     : <span class="kt">Prop</span></blockquote></div></div></small></span></pre><p>The command still fails even if we told Coq how to inject booleans values
into the natural numbers. Indeed the <code class="highlight coq"><span class="kn">Check</span></code> commands works.</p>
<p>The call to <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1457">coq.typecheck</a> modifies the term in place, it can assign
implicit arguments (like the type parameter of <code class="highlight coq"><span class="n">eq</span></code>) but it cannot modify the
structure of the term. To do so, one has to use the
<a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1476">coq.elaborate-skeleton</a> API.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[arguments(raw)]
<span class="kn">Elpi</span> <span class="kn">Command</span> elaborate_arg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>trm<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>std.assert-ok!<span class="w"> </span><span class="p">(</span>coq.elaborate-skeleton<span class="w"> </span><span class=" -ElpiVariable">T</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span><span class="w"> </span><span class=" -ElpiVariable">T1</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;illtyped arg&quot;</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;T=&quot;</span><span class="w"> </span><span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;T1=&quot;</span><span class="w"> </span><span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;Ty=&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Ty</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chkd"><span class="kn">Elpi</span> elaborate_arg (<span class="mi">1</span> = true).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">T= 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), X0, app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  <span class="kn">global</span> (indc ¬´true¬ª)]</blockquote><blockquote class="alectryon-message">T1= 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  app [<span class="kn">global</span> (const ¬´bool2nat¬ª), <span class="kn">global</span> (indc ¬´true¬ª)]]</blockquote><blockquote class="alectryon-message">Ty= sort prop</blockquote></div></div></small></span></pre><p>Remark how <code class="e elpi"><span class="n-ElpiVariable">T</span></code> is not touched by the call to this API, and how <code class="e elpi"><span class="n-ElpiVariable">T1</span></code>
is a copy of <code class="e elpi"><span class="n-ElpiVariable">T</span></code> where the hole after <code class="highlight coq"><span class="n">eq</span></code> is synthesized and the value
<code class="highlight coq"><span class="n">true</span></code> injected to <code class="highlight coq"><span class="n">nat</span></code> by using <code class="highlight coq"><span class="n">bool2nat</span></code>.</p>
<p>It is also possible to manipulate term arguments before typechecking
them, but note that all the considerations on holes in the tutorial about
the HOAS representation of Coq terms apply here. An example of tool
taking advantage of this possibility is Hierarchy Builder: the declarations
it receives would not typecheck in the current context, but do once the
context is temporarily augmented with ad-hoc canonical structure instances.</p>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#toc-entry-4">Examples</a></h1>
<div class="section" id="synthesizing-a-term">
<h2><a class="toc-backref" href="#toc-entry-5">Synthesizing a term</a></h2>
<p>Synthesizing a term typically involves reading an existing declaration
and writing a new one. The relevant APIs are in the <code class="highlight coq"><span class="n">coq</span><span class="o">.</span><span class="n">env</span><span class="o">.*</span></code> namespace
and are named after the global reference they manipulate, eg <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L709">coq.env.const</a>
for reading and <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L798">coq.env.add-const</a> for writing.</p>
<p>Here we implement a little command that given an inductive type name
generates a term of type <code class="highlight coq"><span class="n">nat</span></code> whose value is the number of constructors
of the given inductive type.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> constructors_num.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">int-&gt;nat</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">int</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">term</span>.
int-&gt;nat<span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="si">{{</span> <span class="mi">0</span> <span class="si">}}</span>.
int-&gt;nat<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="si">{{</span> S <span class="si">lp:</span><span class=" -ElpiVariable">X</span> <span class="si">}}</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="k k-ElpiKeyword">-</span><span class="w"> </span><span class="mi">1</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>int-&gt;nat<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class=" -ElpiVariable">X</span>.

main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">IndName</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>str<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">  </span>std.assert!<span class="w"> </span><span class="p">(</span>coq.locate<span class="w"> </span><span class=" -ElpiVariable">IndName</span><span class="w"> </span><span class="p">(</span>indt<span class="w"> </span><span class=" -ElpiVariable">GR</span><span class="p">))</span><span class="w"> </span><span class="s2">&quot;not an inductive type&quot;</span><span class="k k-ElpiKeyword">,</span>
<span class="w">  </span>coq.env.indt<span class="w"> </span><span class=" -ElpiVariable">GR</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">Kn</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">,</span><span class="w">      </span><span class="c">% the names of the constructors</span>
<span class="w">  </span>std.length<span class="w"> </span><span class=" -ElpiVariable">Kn</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span><span class="w">                   </span><span class="c">% count them</span>
<span class="w">  </span>int-&gt;nat<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class=" -ElpiVariable">Nnat</span><span class="k k-ElpiKeyword">,</span><span class="w">                   </span><span class="c">% turn the integer into a nat</span>
<span class="w">  </span>coq.env.add-const<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">Nnat</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span>.<span class="w"> </span><span class="c">% save it</span>

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> constructors_num bool nK_bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chke"><span class="kn">Print</span> nK_bool.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nK_bool = <span class="mi">2</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> constructors_num <span class="kt">False</span> nK_False.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chkf"><span class="kn">Print</span> nK_False.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nK_False = <span class="mi">0</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk10"><span class="kn">Elpi</span> constructors_num plus nK_plus.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">not an inductive type: coq.locate plus (indt X0)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk11"><span class="kn">Elpi</span> constructors_num not_there bla.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Global</span> reference not found: not_there</blockquote></div></div></small></span></pre><p>The command starts by locating the first argument and asserting it points to
an inductive type. This line is idiomatic: <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L627">coq.locate</a> aborts if
the string cannot be located, and if it relates it to a <code class="e elpi">gref</code> which is not
<code class="e elpi">indt</code> (for example <code class="e elpi">const<span class="w"> </span>plus</code>) <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L488">assert!</a> aborts with the given
error message.</p>
<p><a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L657">coq.env.indt</a> lets one access all the details of an inductive type,
here we just use the list of constructors.
The twin API <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L669">coq.env.indt-decl</a> lets
one access the declaration of the inductive in HOAS form, which might be
easier to manipulate in other situations, like the next example.</p>
<p>Then the program crafts a natural number and declares a constant for it.</p>
</div>
<div class="section" id="abstracting-an-inductive">
<h2><a class="toc-backref" href="#toc-entry-6">Abstracting an inductive</a></h2>
<p>For the sake of introducing <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L98">copy</a>, the swiss army knife of ŒªProlog, we
write a command which takes an inductive type declaration and builds a new
one abstracting the former one on a given term. The new inductive has a
parameter in place of the occurrences of that term.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> <span class="kp">abstract</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span><span class="c">% a renaming function which adds a &#39; to an ident (a string)</span>
<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">prime</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">id</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">id</span>.
<span class="w">  </span>prime<span class="w"> </span><span class=" -ElpiVariable">S</span><span class="w"> </span><span class=" -ElpiVariable">S1</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class=" -ElpiVariable">S1</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span><span class=" -ElpiVariable">S</span><span class="w"> </span><span class="k k-ElpiKeyword">^</span><span class="w"> </span><span class="s2">&quot;&#39;&quot;</span>.

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">id</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">id</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">id</span>.
<span class="w">  </span>id<span class="w"> </span><span class=" -ElpiVariable">X</span><span class="w"> </span><span class=" -ElpiVariable">X</span>.

<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">Ind</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>trm<span class="w"> </span><span class=" -ElpiVariable">Param</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>

<span class="w">    </span><span class="c">% the term to be abstracted out, P of type PTy</span>
<span class="w">    </span>std.assert-ok!
<span class="w">      </span><span class="p">(</span>coq.elaborate-skeleton<span class="w"> </span><span class=" -ElpiVariable">Param</span><span class="w"> </span><span class=" -ElpiVariable">PTy</span><span class="w"> </span><span class=" -ElpiVariable">P</span><span class="p">)</span>
<span class="w">      </span><span class="s2">&quot;illtyped parameter&quot;</span><span class="k k-ElpiKeyword">,</span>

<span class="w">    </span><span class="c">% fetch the old declaration</span>
<span class="w">    </span>std.assert!<span class="w"> </span><span class="p">(</span>coq.locate<span class="w"> </span><span class=" -ElpiVariable">Ind</span><span class="w"> </span><span class="p">(</span>indt<span class="w"> </span><span class=" -ElpiVariable">I</span><span class="p">))</span><span class="w"> </span><span class="s2">&quot;not an inductive type&quot;</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.indt-decl<span class="w"> </span><span class=" -ElpiVariable">I</span><span class="w"> </span><span class=" -ElpiVariable">Decl</span><span class="k k-ElpiKeyword">,</span>

<span class="w">    </span><span class="c">% let&#39;s start to craft the new declaration by putting a</span>
<span class="w">    </span><span class="c">% parameter A which has the type of P</span>
<span class="w">    </span><span class="p">(</span><span class=" -ElpiVariable">NewDecl</span><span class="w"> </span><span class="k k-ElpiKeyword">:</span><span class="w"> </span>indt-decl<span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span>parameter<span class="w"> </span><span class="s2">&quot;A&quot;</span><span class="w"> </span>explicit<span class="w"> </span><span class=" -ElpiVariable">PTy</span><span class="w"> </span><span class=" -ElpiVariable">Decl&#39;</span><span class="k k-ElpiKeyword">,</span>

<span class="w">    </span><span class="c">% let&#39;s make a copy, capturing all occurrences of P with a</span>
<span class="w">    </span><span class="c">% (which stands for the parameter)</span>
<span class="w">    </span><span class="p">(</span><span class="k k-ElpiKeyword">pi</span><span class="w"> </span><span class=" -ElpiVariable">a</span>\<span class="w"> </span><span class="p">(</span>copy<span class="w"> </span><span class=" -ElpiVariable">P</span><span class="w"> </span>a<span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">==&gt;</span><span class="w"> </span>copy-indt-decl<span class="w"> </span><span class=" -ElpiVariable">Decl</span><span class="w"> </span><span class="p">(</span><span class=" -ElpiVariable">Decl&#39;</span><span class="w"> </span>a<span class="p">))</span><span class="k k-ElpiKeyword">,</span>

<span class="w">    </span><span class="c">% to avoid name clashes, we rename the type and its constructors</span>
<span class="w">    </span><span class="c">% (we don&#39;t need to rename the parameters)</span>
<span class="w">    </span>coq.rename-indt-decl<span class="w"> </span>id<span class="w"> </span>prime<span class="w"> </span>prime<span class="w"> </span><span class=" -ElpiVariable">NewDecl</span><span class="w"> </span><span class=" -ElpiVariable">DeclRenamed</span><span class="k k-ElpiKeyword">,</span>

<span class="w">    </span><span class="c">% we type check the inductive declaration, since abstracting</span>
<span class="w">    </span><span class="c">% random terms may lead to illtyped declarations (type theory</span>
<span class="w">    </span><span class="c">% is hard)</span>
<span class="w">    </span>std.assert-ok!
<span class="w">      </span><span class="p">(</span>coq.typecheck-indt-decl<span class="w"> </span><span class=" -ElpiVariable">DeclRenamed</span><span class="p">)</span>
<span class="w">      </span><span class="s2">&quot;can&#39;t be abstracted&quot;</span><span class="k k-ElpiKeyword">,</span>

<span class="w">    </span>coq.env.add-indt<span class="w"> </span><span class=" -ElpiVariable">DeclRenamed</span><span class="w"> </span><span class=" -ElpiVariable">_</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tree</span> := leaf | node : tree -&gt; option nat -&gt; tree -&gt; tree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kp">abstract</span> tree (option nat).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk12"><span class="kn">Print</span> tree&#39;.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span> <span class="nf">tree&#39;</span> (<span class="nv">A</span> : <span class="kt">Set</span>) : <span class="kt">Set</span> :=
    leaf&#39; : tree&#39; A
  | node&#39; : tree&#39; A -&gt; A -&gt; tree&#39; A -&gt; tree&#39; A.

<span class="kn">Arguments</span> tree&#39; A%type_scope
<span class="kn">Arguments</span> leaf&#39; A%type_scope
<span class="kn">Arguments</span> node&#39; A%type_scope _ _ _</blockquote></div></div></small></span></pre><p>As expected <code class="highlight coq"><span class="n">tree'</span></code> has a parameter <code class="highlight coq"><span class="n">A</span></code>.</p>
<p>Now let's focus on <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L98">copy</a>. The standard
coq library (loaded by the command template) contains a definition of copy
for terms and declarations.</p>
<p>An excerpt:</p>
<pre class="code elpi literal-block">
copy<span class="w"> </span><span class="n-ElpiVariable">X</span><span class="w"> </span><span class="n-ElpiVariable">X</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w"> </span>name<span class="w"> </span><span class="n-ElpiVariable">X</span><span class="o">.</span><span class="w">      </span><span class="c">% checks X is a bound variable
</span>copy<span class="w"> </span><span class="p">(</span>global<span class="w"> </span><span class="n-ElpiVariable">_</span><span class="w"> </span><span class="k-ElpiKeyword">as</span><span class="w"> </span><span class="n-ElpiVariable">C</span><span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">C</span><span class="o">.</span><span class="w">
</span>copy<span class="w"> </span><span class="p">(</span>fun<span class="w"> </span><span class="n-ElpiVariable">N</span><span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">F</span><span class="p">)</span><span class="w"> </span><span class="p">(</span>fun<span class="w"> </span><span class="n-ElpiVariable">N</span><span class="w"> </span><span class="n-ElpiVariable">T1</span><span class="w"> </span><span class="n-ElpiVariable">F1</span><span class="p">)</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w">
  </span>copy<span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">T1</span><span class="k-ElpiKeyword">,</span><span class="w"> </span><span class="k-ElpiKeyword">pi</span><span class="w"> </span><span class="n-ElpiVariable">x</span>\<span class="w"> </span>copy<span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">F</span><span class="w"> </span>x<span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">F1</span><span class="w"> </span>x<span class="p">)</span><span class="o">.</span><span class="w">
</span>copy<span class="w"> </span><span class="p">(</span>app<span class="w"> </span><span class="n-ElpiVariable">L</span><span class="p">)</span><span class="w"> </span><span class="p">(</span>app<span class="w"> </span><span class="n-ElpiVariable">L1</span><span class="p">)</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w"> </span>std.map<span class="w"> </span><span class="n-ElpiVariable">L</span><span class="w"> </span>copy<span class="w"> </span><span class="n-ElpiVariable">L1</span><span class="o">.</span>
</pre>
<p><code class="e elpi">copy</code> implements the identity: it builds, recursively, a copy of the first
term into the second argument. Unless one loads in the context a new rule,
which takes precedence over the identity ones. Here we load:</p>
<pre class="code elpi literal-block">
copy<span class="w"> </span><span class="n-ElpiVariable">P</span><span class="w"> </span>a
</pre>
<p>which, at run time, looks like</p>
<pre class="code elpi literal-block">
copy<span class="w"> </span><span class="p">(</span>app<span class="w"> </span><span class="k-ElpiKeyword">[</span>global<span class="w"> </span><span class="p">(</span>indt<span class="w"> </span><span class="err">¬´</span>option<span class="err">¬ª</span><span class="p">)</span><span class="k-ElpiKeyword">,</span><span class="w"> </span>global<span class="w"> </span><span class="p">(</span>indt<span class="w"> </span><span class="err">¬´</span>nat<span class="err">¬ª</span><span class="p">)</span><span class="k-ElpiKeyword">]</span><span class="p">)</span><span class="w"> </span>c0
</pre>
<p>and that rule masks the one for <code class="highlight coq"><span class="n">app</span></code> when the sub-term being copied is
exactly <code class="highlight coq"><span class="n">option</span> <span class="n">nat</span></code>. The API <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L133">copy-indt-decl</a> copies an inductive
declaration and calls <code class="highlight coq"><span class="n">copy</span></code> on all the terms it contains (e.g. the
type of the constructors).</p>
<p>The <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L98">copy</a> predicate is very flexible, but sometimes one needs to collect
some data along the way. The sibling API <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L153">fold-map</a> lets one do that.</p>
<p>An excerpt:</p>
<pre class="code elpi literal-block">
fold-map<span class="w"> </span><span class="p">(</span>fun<span class="w"> </span><span class="n-ElpiVariable">N</span><span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">F</span><span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">A</span><span class="w"> </span><span class="p">(</span>fun<span class="w"> </span><span class="n-ElpiVariable">N</span><span class="w"> </span><span class="n-ElpiVariable">T1</span><span class="w"> </span><span class="n-ElpiVariable">F1</span><span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">A2</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w">
  </span>fold-map<span class="w"> </span><span class="n-ElpiVariable">T</span><span class="w"> </span><span class="n-ElpiVariable">A</span><span class="w"> </span><span class="n-ElpiVariable">T1</span><span class="w"> </span><span class="n-ElpiVariable">A1</span><span class="k-ElpiKeyword">,</span><span class="w"> </span><span class="k-ElpiKeyword">pi</span><span class="w"> </span><span class="n-ElpiVariable">x</span>\<span class="w"> </span>fold-map<span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">F</span><span class="w"> </span>x<span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">A1</span><span class="w"> </span><span class="p">(</span><span class="n-ElpiVariable">F1</span><span class="w"> </span>x<span class="p">)</span><span class="w"> </span><span class="n-ElpiVariable">A2</span><span class="o">.</span>
</pre>
<p>For example one can use <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L153">fold-map</a> to collect into a list all the occurrences
of inductive type constructors in a given term, then use the list to postulate
the right number of binders for them, and finally use <a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L98">copy</a> to capture them.</p>
</div>
</div>
<div class="section" id="using-dbs-to-store-data-across-calls">
<h1><a class="toc-backref" href="#toc-entry-7">Using DBs to store data across calls</a></h1>
<p>A Db can be created with the command:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Db</span> name.db <span class="si">lp:{{</span><span class="w"> </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">some-pred</span>.<span class="w"> </span><span class="si">}}</span>.</span></span></pre><p>and a Db can be later extended via <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span></code>.
As a convention, we like Db names to end in a .db suffix.</p>
<p>A Db is pretty much like a regular program but can be <em>shared</em> among
other programs and is accumulated <em>by name</em>.
Since is a Db is accumulated <em>when a program runs</em> the <em>current
contents of the Db are used</em>.
Moreover the Db can be extended by Elpi programs themselves
thanks to the API <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1851">coq.elpi.accumulate</a>, enabling code to save a state
which is then visible at subsequent runs.</p>
<p>The initial contents of a Db, <code class="highlight coq"><span class="n">pred</span> <span class="n">some</span><span class="o">-</span><span class="n">pred</span><span class="o">.</span></code> in the example
above, is usually just the type declaration for the predicates part of the Db,
and maybe a few default rules.
Let's define a Db.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Db</span> age.db <span class="si">lp:{{</span>

<span class="w">  </span><span class="c">% A typical Db is made of one main predicate</span>
<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">age</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">string</span><span class="k k-ElpiMode">,</span><span class="w"> </span><span class="k k-ElpiMode">o:</span><span class="kt">int</span>.

<span class="w">  </span><span class="c">% the Db is empty for now, we put a rule giving a</span>
<span class="w">  </span><span class="c">% descriptive error and we name that rule &quot;age.fail&quot;.</span>
<span class="w">  </span><span class="k k-ElpiMode">:name</span><span class="w"> </span><span class="s2">&quot;age.fail&quot;</span>
<span class="w">  </span>age<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.error<span class="w"> </span><span class="s2">&quot;I don&#39;t know who&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class="s2">&quot;is!&quot;</span>.

<span class="si">}}</span>.</span></span></pre><p>Elpi rules can be given a name via the <code class="e elpi"><span class="k-ElpiKeyword">:</span>name</code> attribute. Named rules
serve as anchor-points for new rules when added to the Db.</p>
<p>Let's define a <code class="highlight coq"><span class="n">Command</span></code> that makes use of a Db.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> age.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> age.db.  <span class="c">(* we accumulate the Db *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>age<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class="s2">&quot;is&quot;</span><span class="w"> </span><span class=" -ElpiVariable">A</span><span class="w"> </span><span class="s2">&quot;years old&quot;</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk13"><span class="kn">Elpi</span> age bob.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">I don&#39;t know who bob <span class="kr">is</span>!</blockquote></div></div></small></span></pre><p>Let's put some data in the Db. Given that the Db contains a catch-all rule,
we need the new ones to be put before it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> age.db <span class="si">lp:{{</span>

<span class="w">  </span><span class="k k-ElpiMode">:before</span><span class="w"> </span><span class="s2">&quot;age.fail&quot;</span><span class="w">     </span><span class="c">% we place this rule before the catch all</span>
<span class="w">  </span>age<span class="w"> </span><span class="s2">&quot;bob&quot;</span><span class="w"> </span><span class="mi">24</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk14"><span class="kn">Elpi</span> age bob.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bob <span class="kr">is</span> <span class="mi">24</span> years old</blockquote></div></div></small></span></pre><p>Extending data bases this way is fine, but requires the user of our command
to be familiar with Elpi's syntax, which is not very nice. Instead,
we can write a new program that uses the <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1851">coq.elpi.accumulate</a> API
to extend the Db.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> set_age.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> age.db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>int<span class="w"> </span><span class=" -ElpiVariable">Age</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span><span class=" -ElpiVariable">TheNewRule</span><span class="w"> </span><span class="k k-ElpiKeyword">=</span><span class="w"> </span>age<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">Age</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.elpi.accumulate<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;age.db&quot;</span>
<span class="w">      </span><span class="p">(</span>clause<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="p">(</span>before<span class="w"> </span><span class="s2">&quot;age.fail&quot;</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">TheNewRule</span><span class="p">)</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> set_age <span class="s2">&quot;alice&quot;</span> <span class="mi">21</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk15"><span class="kn">Elpi</span> age <span class="s2">&quot;alice&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">alice <span class="kr">is</span> <span class="mi">21</span> years old</blockquote></div></div></small></span></pre><p>Additions to a Db are a Coq object, a bit like a Notation or a Type Class
instance: these object live inside a Coq module (or a Coq file) and become
active when that module is Imported.</p>
<p>Deciding to which Coq module these
extra rules belong is important and <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1851">coq.elpi.accumulate</a> provides
a few options to tune that. Here we passed <code class="e elpi"><span class="n-ElpiVariable">_</span></code>, that uses the default
setting. See the <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1843">scope</a> and <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1831">clause</a> data types for more info.</p>
<div class="section" id="inspecting-a-db">
<span id="inspecting"></span><h2><a class="toc-backref" href="#toc-entry-8">Inspecting a Db</a></h2>
<p>So far we did query a Db but sometimes one needs to inspect the whole
contents.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> print_all_ages.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> age.db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span><span class="k k-ElpiMode">:before</span><span class="w"> </span><span class="s2">&quot;age.fail&quot;</span>
<span class="w">  </span>age<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!,</span><span class="w"> </span>fail.<span class="w"> </span><span class="c">% softly</span>

<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>std.findall<span class="w"> </span><span class="p">(</span>age<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">Rules</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>std.forall<span class="w"> </span><span class=" -ElpiVariable">Rules</span><span class="w"> </span>print-rule.

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">print-rule</span><span class="w"> </span><span class="k k-ElpiMode">i:</span><span class="kt">prop</span>.
<span class="w">  </span>print-rule<span class="w"> </span><span class="p">(</span>age<span class="w"> </span><span class=" -ElpiVariable">P</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="p">)</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">P</span><span class="w"> </span><span class="s2">&quot;is&quot;</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="s2">&quot;years old&quot;</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk16"><span class="kn">Elpi</span> print_all_ages.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bob <span class="kr">is</span> <span class="mi">24</span> years old</blockquote><blockquote class="alectryon-message">alice <span class="kr">is</span> <span class="mi">21</span> years old</blockquote></div></div></small></span></pre><p>The <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L408">std.findall</a> predicate gathers in a list all solutions to
a query, while <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L667">std.forall</a> iterates a predicate over a list.
It is important to notice that <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L569">coq.error</a> is a fatal error which
aborts an Elpi program. Here we shadow the catch all clause with a regular
failure so that <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L408">std.findall</a> can complete to list all the results.</p>
</div>
</div>
<div class="section" id="polishing-a-command">
<h1><a class="toc-backref" href="#toc-entry-9">Polishing a command</a></h1>
<p>The details do make the difference, some times.</p>
<div class="section" id="attributes">
<h2><a class="toc-backref" href="#toc-entry-10">Attributes</a></h2>
<p>Elpi programs can be prefixed with attributes, like <code class="highlight coq"><span class="o">#[</span><span class="n">local</span><span class="o">]</span></code>.
Attributes are not passed as arguments but rather as a rule in the context,
a bit like the option <code class="e elpi"><span class="k-ElpiKeyword">&#64;</span>holes!</code> we have seen before.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> attr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span>main<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>attributes<span class="w"> </span><span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class="c">% we fetch the list of attributes from the context</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">A</span>.

<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk17">#[this, more(stuff=<span class="s2">&quot;33&quot;</span>)] <span class="kn">Elpi</span> attr.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This command does not support these attributes: more,
this. [unsupported-attributes,parsing,default]</blockquote><blockquote class="alectryon-message">[attribute <span class="nb">elpi</span>.loc 
  (leaf-loc File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">10</span>, column <span class="mi">31</span>, characters <span class="mi">175</span>-<span class="mi">179</span>:), 
 attribute <span class="nb">elpi</span>.phase (leaf-str interp), attribute this (leaf-str ), 
 attribute more (node [attribute stuff (leaf-str <span class="mi">33</span>)])]</blockquote></div></div></small></span></pre><p>The first attribute, <code class="e elpi">elpi.loc</code> is always present and corresponds to the
location in the source file of the command. Then we find an attribute for
<code class="e elpi"><span class="s2">&quot;this&quot;</span></code> holding the empty string and an attribute for <code class="e elpi"><span class="s2">&quot;more.stuff&quot;</span></code> holding
the string <code class="e elpi"><span class="s2">&quot;33&quot;</span></code>.</p>
<p>Attributes are usually validated (parsed) and turned into regular options
using <a class="reference external lib-common ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib-common.elpi#L25">coq.parse-attributes</a> and a description of their types using 
the <a class="reference external libtype-common ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib-common.elpi#L65">attribute-type</a> data type:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> parse_attr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk18"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>

<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">some-code</span>.
<span class="w">  </span>some-code<span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>get-option<span class="w"> </span><span class="s2">&quot;more.stuff&quot;</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>get-option<span class="w"> </span><span class="s2">&quot;this&quot;</span><span class="w"> </span><span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class=" -ElpiVariable">B</span>.

<span class="w">  </span>main<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>attributes<span class="w"> </span><span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.parse-attributes<span class="w"> </span><span class=" -ElpiVariable">A</span><span class="w"> </span><span class="k k-ElpiKeyword">[</span>
<span class="w">      </span>att<span class="w"> </span><span class="s2">&quot;this&quot;</span><span class="w"> </span>bool<span class="k k-ElpiKeyword">,</span>
<span class="w">      </span>att<span class="w"> </span><span class="s2">&quot;more.stuff&quot;</span><span class="w"> </span>int<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">Opts</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;options=&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Opts</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class=" -ElpiVariable">Opts</span><span class="w"> </span><span class="k k-ElpiKeyword">==&gt;</span><span class="w"> </span>some-code.

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Toplevel input, characters <span class="mi">302</span>-<span class="mi">306</span>
skipping static analysis of flexible rule: Opts
[<span class="nb">elpi</span>.flex-clause,<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>,default]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk19">#[this, more(stuff=<span class="s2">&quot;33&quot;</span>)] <span class="kn">Elpi</span> parse_attr.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This command does not support these attributes: more,
this. [unsupported-attributes,parsing,default]</blockquote><blockquote class="alectryon-message">options= 
[get-option <span class="nb">elpi</span>.loc File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">18</span>, column <span class="mi">31</span>, characters <span class="mi">358</span>-<span class="mi">368</span>:, 
 get-option <span class="nb">elpi</span>.phase interp, get-option this tt, get-option more.stuff <span class="mi">33</span>]</blockquote><blockquote class="alectryon-message"><span class="mi">33</span> tt</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk1a">#[unknown] <span class="kn">Elpi</span> parse_attr.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This command does not support this attribute: unknown.
[unsupported-attributes,parsing,default]</blockquote><blockquote class="alectryon-message">Attribute unknown <span class="kr">is</span> not supported</blockquote></div></div></small></span></pre><p>Note that <code class="e elpi">get-option</code> links a string with a datum of type <code class="e elpi">any</code>, which means
no type checking is performed on it. It is recommended to wrap calls to
get-option into other predicates typed in a more precise way. Eg:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span><span class="w"> </span><span class="n-ElpiFunction">get-my-option</span><span class="w"> </span><span class="k-ElpiMode">o:</span><span class="kt">int</span>.<span class="w">
</span>get-my-option<span class="w"> </span><span class="n-ElpiVariable">I</span><span class="w"> </span><span class="k-ElpiKeyword">:-</span><span class="w"> </span>get-option<span class="w"> </span><span class="s2">&quot;my-option-name&quot;</span><span class="w"> </span><span class="n-ElpiVariable">I</span><span class="o">.</span>
</pre>
</div>
<div class="section" id="extending-the-command-grammar">
<h2><a class="toc-backref" href="#toc-entry-11">Extending the command grammar</a></h2>
<p>Elpi programs can be exported as regular Coq commands, so that the
final user does not need to type <code class="highlight coq"><span class="n">Elpi</span></code> to invoke them.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> Say.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span><span class="w"> </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.say<span class="w"> </span><span class=" -ElpiVariable">S</span>.<span class="w"> </span><span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> Say. <span class="c">(* extend the Coq command grammar *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk1b">Say <span class="s2">&quot;That is all folks!&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">That <span class="kr">is</span> <span class="kp">all</span> folks!</blockquote></div></div></small></span></pre><p>Not yet...</p>
<p>Coq offers no equivalent of <code class="highlight coq"><span class="kn">Tactic Notation</span></code> for commands.
Still Elpi commands accept any symbol or keyword as strings.
It is up to the programmer to catch and report parse errors.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> Go.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">Src</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>str<span class="w"> </span><span class="s2">&quot;=&gt;&quot;</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>str<span class="w"> </span><span class=" -ElpiVariable">Tgt</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>str<span class="w"> </span><span class="s2">&quot;/&quot;</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>str<span class="w"> </span><span class=" -ElpiVariable">F</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class="k k-ElpiKeyword">!,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;going from&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Src</span><span class="w"> </span><span class="s2">&quot;to&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Tgt</span><span class="w"> </span><span class="s2">&quot;via&quot;</span><span class="w"> </span><span class=" -ElpiVariable">F</span>.
<span class="w">  </span>main<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.error<span class="w"> </span><span class="s2">&quot;Parse error! Use: go &lt;from&gt; =&gt; &lt;to&gt; / &lt;via&gt;&quot;</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> Go.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk1c">Go source =&gt; target / plane.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">going <span class="kn">from</span> source to target via plane</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk1d">Go nowhere.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Parse error! Use: go &lt;<span class="kn">from</span>&gt; =&gt; &lt;to&gt; / &lt;via&gt;</blockquote></div></div></small></span></pre></div>
<div class="section" id="reporting-errors">
<h2><a class="toc-backref" href="#toc-entry-12">Reporting errors</a></h2>
<p>Last, (good) Elpi programs should fail reporting intelligible error messages,
as the previous one.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span><span class="w"> </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[]</span>.<span class="w"> </span><span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk1e">bad <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="nb">elpi</span> tactic/command bad failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</blockquote></div></div></small></span></pre><p>If they just fail, they produce the following generic
error:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->The elpi tactic/command bad failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</pre><p>You should use the <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L569">coq.error</a> API or the <a class="reference external stdlib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/elpi-builtin.elpi#L488">assert!</a> one
to abort a program. There is a dedicated <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1613">coq.ltac.fail</a> API to abort
tactics.</p>
<p>Warnings can be reported using the <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L563">coq.warning</a> which lets you
pick a name and category. In turn these can be used to disable or make fatal
your warnings (as any other Coq warning).</p>
</div>
</div>
<div class="section" id="parsing-and-execution">
<h1><a class="toc-backref" href="#toc-entry-13">Parsing and Execution</a></h1>
<p>Since version 8.18 Coq has separate parsing and execution phases,
respectively called synterp and interp.</p>
<p>Since Coq has an extensible grammar the parsing phase is not entirely
performed by the parser: after parsing one sentence Coq evaluates its
synterp action. The synterp actions of a command like <code class="highlight coq"><span class="kn">Import</span> <span class="n">A</span><span class="o">.</span></code> are
the subset of its effect which affect parsing, like enabling a notation.
Later, during the execution phase, Coq evaluates its
interp actions, which include effects like putting lemma in scope or
enabling type class instances etc. Synterp actions are quick, if only because
they don't really manipulate Coq terms, hence no type checking and the like.</p>
<p>Being able to parse an entire document quickly
is important for developing reactive
user interfaces, but requires some extra work when defining new commands,
in particular to identify their synterp.
Each command defined with Coq-Elpi is split into two programs,
one running during the parsing phase and the other one during the execution
phase. Each API that affects the parser, i.e. APIs dealing with modules
and sections like begin/end-module or import/export, is available to both the
synterp and the interp program under the same name, but its actual effect is
limited to what concerns the current phase. Hence all these APIs have to be
called at <em>both</em> synterp and interp time and <em>in the same order</em>.</p>
<p>At synterp time the data types and the APIs are restricted, in particular
Coq terms are not available. When a command argument contains a term, that
term is replaced by <code class="highlight coq"><span class="n">_</span></code> at synterp time. In the following example, the synterp
program can see the name of the definition and the fact that a body was given,
but not the value of the body.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> hello_synterp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>const-decl<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">Body</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.say<span class="w"> </span><span class="s2">&quot;synterp&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class="s2">&quot;:=&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Body</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>const-decl<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">Body</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>coq.say<span class="w"> </span><span class="s2">&quot;interp&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class="s2">&quot;:=&quot;</span><span class="w"> </span><span class=" -ElpiVariable">Body</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk1f"><span class="kn">Elpi</span> hello_synterp <span class="kn">Definition</span> <span class="nf">x</span> := <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">synterp x := some _</blockquote><blockquote class="alectryon-message">interp x := 
some
 (app [<span class="kn">global</span> (indc ¬´S¬ª), app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]])</blockquote></div></div></small></span></pre><p>This simple command has no real synterp action, one could safely remove
the synterp code. On the contrary when a command performs actions affecting
the parser then it must come equipped with some synterp code performing
the corresponding actions.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;&gt;&gt;&#39; y&quot;</span> := (x &gt; y) (<span class="kn">at level</span> <span class="mi">40</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">w</span> := <span class="mi">3</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> import_module.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.locate-module<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class=" -ElpiVariable">MP</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.import-module<span class="w"> </span><span class=" -ElpiVariable">MP</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.locate<span class="w"> </span><span class="s2">&quot;w&quot;</span><span class="w"> </span><span class="p">(</span>const<span class="w"> </span><span class=" -ElpiVariable">GR</span><span class="p">)</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.const<span class="w"> </span><span class=" -ElpiVariable">GR</span><span class="w"> </span><span class="p">(</span>some<span class="w"> </span><span class="si">{{</span> <span class="mi">3</span> <span class="si">}}</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-command-v-chk20"><span class="kn">Elpi</span> import_module Notations.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command did perform no (more) actions during the
parsing phase (aka synterp), while during the
execution phase (aka interp) it tried to perform a
import-module action. Interp actions must <span class="kr">match</span>
synterp actions. For example <span class="kr">if</span> a module was imported
during the synterp phase, <span class="kr">then</span> it must also be
imported during the interp one.
The command lacks code <span class="kr">for</span> the synterp phase. In order
to add code to this phase use &#39;#[synterp] <span class="kn">Elpi</span>
Accumulate&#39;. See also
https://lpcic.github.io/coq-<span class="nb">elpi</span>/tutorial_coq_elpi_command.html#parsing-<span class="kn">and</span>-execution</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* oops, we forgot to declare code for the synterp phase. Here it is *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[</span>str<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.locate-module<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class=" -ElpiVariable">MP</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.import-module<span class="w"> </span><span class=" -ElpiVariable">MP</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> import_module Notations.</span></span></pre><p>Elpi reports a descriptive error message if actions affecting the parser are
not declared in the synterp code of the command.</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->The command did perform no (more) actions during the
parsing phase (aka synterp), while during the
execution phase (aka interp) it tried to perform a
import-module action. Interp actions must match
synterp actions. For example if a module was imported
during the synterp phase, then it must also be
imported during the interp one.
The command lacks code for the synterp phase. In order
to add code to this phase use &#39;#[synterp] Elpi
Accumulate&#39;. See also
https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_command.html#parsing-and-execution</pre><p>Thanks to the synterp code, Coq can parse the document without even looking
at the interp code.</p>
<p>Sometimes it is necessary to pass data from the synterp code to the interp one.
Passing data can be done in two ways. the former is by using the <code class="e elpi">main-synterp</code>
and <code class="e elpi">main-interp</code> entry points.</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span><span class="w"> </span><span class="n-ElpiFunction">main-synterp</span><span class="w"> </span><span class="k-ElpiMode">i:</span><span class="kt">list</span><span class="w"> </span><span class="kt">argument</span><span class="k-ElpiMode">,</span><span class="w"> </span><span class="k-ElpiMode">o:</span><span class="kt">any</span>.<span class="w">
</span><span class="k-ElpiKeyword">pred</span><span class="w"> </span><span class="n-ElpiFunction">main-interp</span><span class="w"> </span><span class="k-ElpiMode">i:</span><span class="kt">list</span><span class="w"> </span><span class="kt">argument</span><span class="k-ElpiMode">,</span><span class="w"> </span><span class="k-ElpiMode">i:</span><span class="kt">any</span>.
</pre>
<p>Unlike <code class="e elpi">main</code> the former outputs a datum while the latter receives it
in input. In the following command we create a (empty) module with a random
name. Even if the name is random, the two phases need to agree on it, hence
we pass the name from one to the other.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> mk_random_module.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main-synterp<span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>random.self_init<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>random.int<span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span><span class="s2">&quot;Module&quot;</span><span class="w"> </span><span class="k k-ElpiKeyword">^</span><span class="w"> </span>{std.any-&gt;string<span class="w"> </span><span class=" -ElpiVariable">N</span>},
<span class="w">    </span>coq.env.begin-module<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span>none<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.end-module<span class="w"> </span><span class=" -ElpiVariable">_</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main-interp<span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.env.begin-module<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span>none<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.end-module<span class="w"> </span><span class=" -ElpiVariable">MP</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.say<span class="w"> </span><span class="s2">&quot;The module is&quot;</span><span class="w"> </span><span class=" -ElpiVariable">MP</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk21"><span class="kn">Elpi</span> mk_random_module.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The module <span class="kr">is</span> ¬´tutorial_coq_elpi_command.Module32¬ª</blockquote></div></div></small></span></pre><p>If the only data to be passed to the interp phase is the list of
synterp actions, then a few APIs can come in handy.
The synterp phase has access to the API <a class="reference external builtin-synterp ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin-synterp.elpi#L404">coq.synterp-actions</a>
that lists the actions performed so far. The interp phase can use
<a class="reference external lib ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/elpi/coq-lib.elpi#L641">coq.replay-synterp-action</a> and <a class="reference external builtin ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1921">coq.next-synterp-action</a> to
replay an action or peek the next one to be performed.</p>
<p>An excerpt of the <a class="reference external type ghref" href="https://github.com/LPCIC/coq-elpi/blob/997aa9b76bc6576dd589089aeee9120ce5e0b983/builtin-doc/coq-builtin.elpi#L1903">synterp-action</a>.</p>
<pre class="code elpi literal-block">
<span class="c">% Action executed during the parsing phase (aka synterp)
</span><span class="k-ElpiKeyword">kind</span><span class="w"> </span><span class="n-ElpiFunction">synterp-action</span><span class="w"> </span><span class="kt">type</span>.<span class="w">
</span><span class="k-ElpiKeyword">type</span><span class="w"> </span><span class="n-ElpiFunction">begin-module</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="kt">-&gt;</span><span class="w"> </span><span class="kt">synterp-action</span>.<span class="w">
</span><span class="k-ElpiKeyword">type</span><span class="w"> </span><span class="n-ElpiFunction">end-module</span><span class="w"> </span><span class="kt">modpath</span><span class="w"> </span><span class="kt">-&gt;</span><span class="w"> </span><span class="kt">synterp-action</span>.
</pre>
<p>The following command creates a stack of modules and puts in there
the given definition. The synterp phase saves the actions when the top of the
stack is reached, and passes them to the interp phase that replays them before
putting a definition inside. Finally the interp phase replays all the missing
actions.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> put_inside.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main-synterp<span class="w"> </span><span class="k k-ElpiKeyword">[</span>int<span class="w"> </span><span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">ActionsUpToNow</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="k k-ElpiKeyword">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="w"> </span><span class="k k-ElpiKeyword">-</span><span class="w"> </span><span class="mi">1</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.begin-module<span class="w"> </span><span class="s2">&quot;Box&quot;</span><span class="w"> </span>none<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>main-synterp<span class="w"> </span><span class="k k-ElpiKeyword">[</span>int<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">ActionsUpToNow</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.end-module<span class="w"> </span><span class=" -ElpiVariable">_</span>.
<span class="w">  </span>main-synterp<span class="w"> </span><span class="k k-ElpiKeyword">[</span>int<span class="w"> </span><span class="mi">0</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">ActionsUpToNow</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.synterp-actions<span class="w"> </span><span class=" -ElpiVariable">ActionsUpToNow</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main-interp<span class="w"> </span><span class="k k-ElpiKeyword">[</span>int<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">,</span><span class="w"> </span>const-decl<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class="p">(</span>some<span class="w"> </span><span class=" -ElpiVariable">BO</span><span class="p">)</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">]</span><span class="w"> </span><span class=" -ElpiVariable">Before</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>std.forall<span class="w"> </span><span class=" -ElpiVariable">Before</span><span class="w"> </span>coq.replay-synterp-action<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.add-const<span class="w"> </span><span class=" -ElpiVariable">Name</span><span class="w"> </span><span class=" -ElpiVariable">BO</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>replay-missing.
<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">replay-missing</span>.
<span class="w">  </span>replay-missing<span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.replay-synterp-action<span class="w"> </span>{coq.next-synterp-action},
<span class="w">    </span>replay-missing.
<span class="w">  </span>replay-missing.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> put_inside <span class="mi">4</span> <span class="kn">Definition</span> <span class="nf">foo</span> (<span class="nv">n</span> : nat) := n + <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk22"><span class="kn">Print</span> Box.Box.Box.Box.foo.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Box.Box.Box.Box.foo =
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n + <span class="mi">2</span>
     : nat -&gt; nat

<span class="kn">Arguments</span> Box.Box.Box.Box.foo n%nat_scope</blockquote></div></div></small></span></pre><p>This last example delegates to the synterp phase the creation of an arbitrary
complex module structure, a structure the interp phase does not need to be aware
of. The data passed to the interp phase is sufficient to replicate it without
too much effort.</p>
<p>Finally, as regular commands, data bases can be used to store a state which
is available at subsequent calls. Data bases used in the two phases live
in different name spaces, and are only available to the corresponding phase.
The <code class="highlight coq"><span class="o">#[</span><span class="n">synterp</span><span class="o">]</span></code> attribute tells <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Db</span></code> to create a data base for the
synterp phase. Here a simple command saving a state in the synterp phase.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Db</span> counter.db <span class="si">lp:{{</span><span class="w"> </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">tick</span>.<span class="w"> </span><span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Command</span> mk_next_module.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="kn">Db</span> counter.db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[synterp] <span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>std.findall<span class="w"> </span>tick<span class="w"> </span><span class=" -ElpiVariable">L</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>std.length<span class="w"> </span><span class=" -ElpiVariable">L</span><span class="w"> </span><span class=" -ElpiVariable">N</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span><span class=" -ElpiVariable">M</span><span class="w"> </span><span class="k k-ElpiKeyword">is</span><span class="w"> </span><span class="s2">&quot;NextModule&quot;</span><span class="w"> </span><span class="k k-ElpiKeyword">^</span><span class="w"> </span>{std.any-&gt;string<span class="w"> </span><span class=" -ElpiVariable">N</span>},
<span class="w">    </span>coq.env.begin-module<span class="w"> </span><span class=" -ElpiVariable">M</span><span class="w"> </span>none<span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.env.end-module<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">,</span>
<span class="w">    </span>coq.elpi.accumulate<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class="s2">&quot;counter.db&quot;</span><span class="w"> </span><span class="p">(</span>clause<span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span><span class=" -ElpiVariable">_</span><span class="w"> </span>tick<span class="p">)</span>.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> <span class="si">lp:{{</span>
<span class="w">  </span>main<span class="w"> </span><span class="k k-ElpiKeyword">[]</span><span class="w"> </span><span class="k k-ElpiKeyword">:-</span><span class="w"> </span>replay-missing.
<span class="w">  </span><span class="k k-ElpiKeyword">pred</span><span class="w"> </span><span class=" -ElpiFunction">replay-missing</span>.
<span class="w">  </span>replay-missing<span class="w"> </span><span class="k k-ElpiKeyword">:-</span>
<span class="w">    </span>coq.replay-synterp-action<span class="w"> </span>{coq.next-synterp-action},
<span class="w">    </span>replay-missing.
<span class="w">  </span>replay-missing.
<span class="si">}}</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> mk_next_module.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> mk_next_module.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> mk_next_module.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-command-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-command-v-chk23"><span class="kn">Print Module</span> NextModule2.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Module</span> <span class="nf">NextModule2</span> := Struct  <span class="kn">End</span></blockquote></div></div></small></span></pre><p>This is really the end, unless you want to learn more about writing
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_tactic.html">tactics</a>
in Elpi, in that case look at that tutorial ;-)</p>
</div>
</div>
</div>
</div></body>
</html>
